{
  "5672a98bdbdd995fad00000f": "def rps(p1, p2):\r\n    beats = {'rock': 'scissors', 'scissors': 'paper', 'paper': 'rock'}\r\n    if beats[p1] == p2:\r\n    return \"Player 1 won!\"\r\n    if beats[p2] == p1:\r\n    return \"Player 2 won!\"\r\n    return \"Draw!\"\r\n",
  "50ee6b0bdeab583673000025": "a = \"code\"\nb = \"wa.rs\"\nname = a + b\n",
  "5ae62fcf252e66d44d00008e": "def expression_matter(a, b, c):\r\n    return max(a * b * c, a + b + c, (a + b) * c, a * (b + c))\r\n",
  "5899dc03bc95b1bf1b0000ad": "def invert(lst):\r\n    return [- x for x in lst]\r\n",
  "57f24e6a18e9fad8eb000296": "def how_much_i_love_you(nb_petals):\r\n    return [\"I love you\", \"a little\", \"a lot\", \"passionately\", \"madly\", \"not at all\"][nb_petals % 6 - 1]  # g\r\n",
  "57cebe1dc6fdc20c57000ac9": "def find_short(s):\r\n    return min(len(x) for x in s . split())\r\n",
  "54ba84be607a92aa900000f1": "def is_isogram(string):\r\n    return len(string) == len(set(string . lower()))\r\n",
  "5526fc09a1bbd946250002dc": "def find_outlier(int):\r\n    odds = [x for x in int if x % 2 != 0]\r\n    evens = [x for x in int if x % 2 == 0]\r\n    return odds[0] if len(odds) < len(evens) else evens[0]\r\n",
  "59ca8246d751df55cc00014c": "def hero(bullets, dragons):\r\n    return bullets >= dragons * 2\r\n",
  "57a0e5c372292dd76d000d7e": "def repeat_str(repeat, string):\r\n    return repeat * string\r\n",
  "5a2be17aee1aaefe2a000151": "def array_plus_array(arr1, arr2):\r\n    return sum(arr1 + arr2)\r\n",
  "61123a6f2446320021db987d": "def prev_mult_of_three(n):\r\n    while n % 3:\r\n    n / /= 10\r\n    return n or None\r\n",
  "529eef7a9194e0cbc1000255": "def is_anagram(test, original):\r\n    return sorted(original . lower()) == sorted(test . lower())\r\n",
  "55c28f7304e3eaebef0000da": "def create_array(n):\r\n    res = []\r\n    i = 1\r\n    while i <= n:\r\n    res += [i]\r\n    i += 1\r\n    return res\r\n",
  "5875b200d520904a04000003": "def enough(cap, on, wait):\r\n    return max(0, wait - (cap - on))\r\n",
  "56efc695740d30f963000557": "def to_alternating_case(string):\r\n    return string . swapcase()\r\n",
  "51fda2d95d6efda45e00004e": "class User:\r\n    Ranks = [- 8, - 7, - 6, - 5, - 4, - 3, - 2, - 1, 1, 2, 3, 4, 5, 6, 7, 8]\r\n\r\n    def __init__(self):\r\n    self . __rank = - 8\r\n    self . __progress = 0\r\n    @ property\r\n    def rank(self):\r\n    return self . __rank\r\n    @ property\r\n    def progress(self):\r\n    return self . __progress\r\n    def inc_progress(self, kata_rank):\r\n    self . __validate_rank(kata_rank)\r\n    progress_made = self . __calc_progress(kata_rank)\r\n    new_progress = self . progress + progress_made\r\n    extra_rank, progress_left = self . __calc_rank(new_progress)\r\n    self . __update_rank(extra_rank)\r\n    self . __update_progress(progress_left)\r\n\r\n    def __validate_rank(self, in_rank):\r\n    if (in_rank not in self . Ranks):\r\n    raise ValueError(\"Rank must be in range [-8,-1]U[1,8]\")\r\n\r\n    def __calc_progress(self, kata_rank):\r\n    diff = self . Ranks . index(kata_rank) - self . Ranks . index(self . rank)\r\n    if (kata_rank > self . rank):\r\n    return 10 * diff * * 2\r\n    elif (kata_rank == self . rank):\r\n    return 3\r\n    elif (diff == - 1):\r\n    return 1\r\n    else:\r\n    return 0\r\n    def __calc_rank(self, new_progress):\r\n    extra_rank = 0\r\n    progress_left = new_progress\r\n    if (new_progress > 99 and self . rank < 8):\r\n    extra_rank = new_progress / / 100\r\n    progress_left = new_progress % 100\r\n    return extra_rank, progress_left\r\n    def __update_progress(self, new_progress):\r\n    self . __progress = new_progress\r\n    if (self . rank == 8 and self . progress > 0):\r\n    self . __progress = 0\r\n    def __update_rank(self, extra_rank):\r\n    new_rank = self . rank + extra_rank\r\n    if (self . rank < 0 and new_rank >= 0):\r\n    new_rank = new_rank + 1\r\n    if (new_rank > 8):\r\n    self . __rank = 8\r\n    else:\r\n    self . __rank = new_rank\r\n",
  "577ff15ad648a14b780000e7": "def greet(language):\r\n    return {\r\n        'czech': 'Vitejte',\r\n        'danish': 'Velkomst',\r\n        'dutch': 'Welkom',\r\n        'english': 'Welcome',\r\n        'estonian': 'Tere tulemast',\r\n        'finnish': 'Tervetuloa',\r\n        'flemish': 'Welgekomen',\r\n        'french': 'Bienvenue',\r\n        'german': 'Willkommen',\r\n        'irish': 'Failte',\r\n        'italian': 'Benvenuto',\r\n        'latvian': 'Gaidits',\r\n        'lithuanian': 'Laukiamas',\r\n        'polish': 'Witamy',\r\n        'spanish': 'Bienvenido',\r\n        'swedish': 'Valkommen',\r\n        'welsh': 'Croeso'\r\n    }. get(language, 'Welcome')\r\n",
  "547274e24481cfc469000416": "def God():\r\n    return [Man(), Woman()]\r\n\r\n    class Human (object):\r\n    pass\r\n    class Man (Human):\r\n    pass\r\n    class Woman (Human):\r\n    pass\r\n",
  "5254ca2719453dcc0b00027d": "import itertools\n\n\ndef permutations(string):\n    return list(\"\" . join(p) for p in set(itertools . permutations(string)))\n",
  "56541980fa08ab47a0000040": "from re import sub\n\n\ndef printer_error(s):\n    return \"{}/{}\" . format(len(sub(\"[a-m]\", '', s)), len(s))\n",
  "56f6ad906b88de513f000d96": "def bonus_time(salary, bonus):\r\n    return \"${}\" . format(salary * (10 if bonus else 1))\r\n",
  "59fca81a5712f9fa4700159a": "def to_binary(n):\r\n    return int(f' { n : b } ')\r\n",
  "5265326f5fda8eb1160004c8": "def number_to_string(num):\r\n    return str(num)\r\n",
  "540c33513b6532cd58000259": "def sum_args(* args):\r\n    return sum(args)\r\n",
  "56f69d9f9400f508fb000ba7": "def monkey_count(n):\r\n    return range(1, n + 1)\r\n",
  "57e92e91b63b6cbac20001e5": "def duty_free(price, discount, holiday_cost):\r\n    saving = price * discount / 100.0\r\n    return int(holiday_cost / saving)\r\n",
  "5545f109004975ea66000086": "def is_divisible(n, x, y):\r\n    return n % x == 0 and n % y == 0\r\n",
  "5519a584a73e70fa570005f5": "import numpy as np\r\n\r\n\r\nclass PrimeSieve:\r\n    def __init__(self, maximum):\r\n    self . primes = [2, 3]\r\n    # self.sieve = [0] * (maximum + 1)\r\n    self . sieve = np . zeros(maximum + 1, dtype=np . int8)\r\n    for p in self . primes:\r\n    self . sieve[p * p:: p] = 1\r\n    def extend(self):\r\n    p = self . primes[- 1] + 2\r\n    while self . sieve[p]:\r\n        p += 2\r\n    self . sieve[p * p:: p] = 1\r\n    self . primes . append(p)\r\n    return p\r\n    class Primes:\r\n    @ staticmethod\r\n    def stream():\r\n    prime_sieve = PrimeSieve(2 * 10 * * 7)\r\n    yield from iter(prime_sieve . primes)\r\n    yield from iter(prime_sieve . extend, 0)\r\n",
  "5266876b8f4bf2da9b000362": "def likes(names):\r\n    n = len(names)\r\n    return {\r\n        0: 'no one likes this',\r\n        1: '{} likes this',\r\n        2: '{} and {} like this',\r\n        3: '{}, {} and {} like this',\r\n        4: '{}, {} and {others} others like this'\r\n    }[min(4, n)]. format(* names[: 3], others=n - 2)\r\n",
  "55192f4ecd82ff826900089e": "def divide(weight):\r\n    return weight > 2 and weight % 2 == 0\r\n",
  "5779f894ec8832493f00002d": "from collections import Counter\n\n\ndef fib_digits(n):\n    a, b = 0, 1\n    for i in range(n):\n        a, b = b, a + b\n    return sorted(((b, int(a)) for a, b in Counter(str(a)). items()), reverse=True)\n",
  "58649884a1659ed6cb000072": "def update_light(current):\r\n    return {\"green\": \"yellow\", \"yellow\": \"red\", \"red\": \"green\"}[current]\r\n",
  "515e271a311df0350d00000f": "def square_sum(numbers):\r\n    return sum(x * * 2 for x in numbers)\r\n",
  "57126304cdbf63c6770012bd": "def isDigit(string):\r\n    try:\r\n    float(string)\r\n    return True\r\n    except:\r\n    return False\r\n",
  "57a049e253ba33ac5e000212": "from math import factorial\n",
  "551b4501ac0447318f0009cd": "def boolean_to_string(b):\r\n    return str(b)\r\n",
  "563b74ddd19a3ad462000054": "def stringy(size):\r\n    return ('10' * size)[: size]\r\n",
  "52a382ee44408cea2500074c": "import numpy as np\n\n\ndef determinant(a):\n    return round(np . linalg . det(np . matrix(a)))\n",
  "55d8618adfda93c89600012e": "def what_is(x):\r\n    if x == 42:\r\n    return 'everything'\r\n    elif x == 42 * 42:\r\n    return 'everything squared'\r\n    else:\r\n    return 'nothing'\r\n",
  "523b4ff7adca849afe000035": "def greet():\r\n    return \"hello world!\"\r\n",
  "56b7771481290cc283000f28": "def last_fib_digit(n):\r\n    return [0, 1, 1, 2, 3, 5, 8, 3, 1, 4, 5, 9, 4, 3, 7, 0, 7, 7, 4, 1, 5, 6, 1, 7, 8, 5, 3, 8, 1, 9, 0, 9, 9, 8, 7, 5, 2, 7, 9, 6, 5, 1, 6, 7, 3, 0, 3, 3, 6, 9, 5, 4, 9, 3, 2, 5, 7, 2, 9, 1][n % 60]\r\n",
  "529adbf7533b761c560004e5": "def memoized(f):\r\n    cache = {}\r\n    def wrapped(k):\r\n    v = cache . get(k)\r\n    if v is None:\r\n    v = cache[k] = f(k)\r\n    return v\r\n    return wrapped\r\n    @ memoized\r\n    def fibonacci(n):\r\n    if n in [0, 1]:\r\n    return n\r\n    return fibonacci(n - 1) + fibonacci(n - 2)\r\n",
  "51b66044bce5799a7f000003": "from collections import OrderedDict\r\nimport re\r\nROMAN_NUMERALS = OrderedDict([\r\n    ('M', 1000),\r\n    ('CM', 900),\r\n    ('D', 500),\r\n    ('CD', 400),\r\n    ('C', 100),\r\n    ('XC', 90),\r\n    ('L', 50),\r\n    ('XL', 40),\r\n    ('X', 10),\r\n    ('IX', 9),\r\n    ('V', 5),\r\n    ('IV', 4),\r\n    ('I', 1),\r\n])\r\n\r\nDECIMAL_TO_ROMAN = [(v, k) for k, v in ROMAN_NUMERALS . items()]\r\n\r\nROMAN_RE = '|' . join(ROMAN_NUMERALS)\r\n\r\n\r\nclass RomanNumerals (object):\r\n    @ staticmethod\r\n    def from_roman(roman):\r\n    return sum(ROMAN_NUMERALS[d] for d in re . findall(ROMAN_RE, roman))\r\n\r\n    @ staticmethod\r\n    def to_roman(decimal):\r\n    result = []\r\n    for number, roman in DECIMAL_TO_ROMAN:\r\n    while decimal >= number:\r\n    decimal -= number\r\n    result . append(roman)\r\n    return '' . join(result)\r\n",
  "5552101f47fc5178b1000050": "def dig_pow(n, p):\r\n    s = 0\r\n    for i, c in enumerate(str(n)):\r\n    s += pow(int(c), p + i)\r\n    return s / n if s % n == 0 else - 1\r\n",
  "5467e4d82edf8bbf40000155": "def Descending_Order(num):\r\n    return int(\"\" . join(sorted(str(num), reverse=True)))\r\n",
  "52756e5ad454534f220001ef": "def lcs(x, y):\r\n    if len(x) == 0 or len(y) == 0:\r\n    return ''\r\n    if x[- 1] == y[- 1]:\r\n    return lcs(x[: - 1], y[: - 1]) + x[- 1]\r\n    else:\r\n    lcs1 = lcs(x, y[: - 1])\r\n    lcs2 = lcs(x[: - 1], y)\r\n    if len(lcs1) > len(lcs2):\r\n    return lcs1\r\n    else:\r\n    return lcs2\r\n",
  "5547cc7dcad755e480000004": "def removNb(n):\r\n    total = n * (n + 1) / 2\r\n    sol = []\r\n    for a in range(1, n + 1):\r\n    b = (total - a) / (a + 1.0)\r\n    if b . is_integer() and b <= n:\r\n    sol . append((a, int(b)))\r\n    return sol\r\n",
  "51f2d1cafc9c0f745c00037d": "def solution(string, ending):\r\n    return string . endswith(ending)\r\n",
  "5ce9c1000bab0b001134f5af": "def quarter_of(month):\r\n    # your code here\r\n    if month in range(1, 4):\r\n    return 1\r\n    elif month in range(4, 7):\r\n    return 2\r\n    elif month in range(7, 10):\r\n    return 3\r\n    elif month in range(10, 13):\r\n    return 4\r\n",
  "56598d8076ee7a0759000087": "from math import ceil\r\n\r\n\r\ndef calculate_tip(amount, rating):\r\n    tips = {\r\n        'terrible': 0,\r\n        'poor': .05,\r\n        'good': .1,\r\n        'great': .15,\r\n        'excellent': .2\r\n    }\r\n    if rating . lower() in tips:\r\n    return ceil(amount * tips[rating . lower()])\r\n    else:\r\n    return 'Rating not recognised'\r\n",
  "551dc350bf4e526099000ae5": "def song_decoder(song):\r\n    return \" \" . join(song . replace('WUB', ' '). split())\r\n",
  "526571aae218b8ee490006f4": "def countBits(n):\r\n    return bin(n). count(\"1\")\r\n",
  "566efcfbf521a3cfd2000056": "def reverse_fun(n):\r\n    for i in range(len(n)):\r\n    n = n[: i] + n[i:][:: - 1]\r\n    return n\r\n",
  "593b1909e68ff627c9000186": "def nickname_generator(name):\r\n    return \"Error: Name too short\" if len(name) < 4 else name[: 3 + (name[2] in \"aeiuo\")]\r\n",
  "57d6b40fbfcdc5e9280002ee": "from itertools import chain\n\n\ndef how_many_bees(hive):\n    return bool(hive) and sum(s . count('bee') + s . count('eeb') for s in map('' . join, chain(hive, zip(* hive))))\n",
  "5aa736a455f906981800360d": "def feast(beast, dish):\r\n    return beast[0] == dish[0] and dish[- 1] == beast[- 1]\r\n",
  "55cbd4ba903825f7970000f5": "def get_grade(s1, s2, s3):\r\n    m = (s1 + s2 + s3) / 3.0\r\n    if 90 <= m <= 100:\r\n    return 'A'\r\n    elif 80 <= m < 90:\r\n    return 'B'\r\n    elif 70 <= m < 80:\r\n    return 'C'\r\n    elif 60 <= m < 70:\r\n    return 'D'\r\n    return \"F\"\r\n",
  "59a8570b570190d313000037": "def sum_cubes(n):\r\n    return sum(i * * 3 for i in range(0, n + 1))\r\n",
  "521c2db8ddc89b9b7a0000c1": "import numpy as np\r\n\r\n\r\ndef snail(array):\r\n    m = []\r\n    array = np . array(array)\r\n    while len(array) > 0:\r\n    m += array[0]. tolist()\r\n    array = np . rot90(array[1:])\r\n    return m\r\n",
  "58f8a3a27a5c28d92e000144": "def first_non_consecutive(arr):\r\n    if not arr:\r\n        return 0\r\n    for i, x in enumerate(arr[: - 1]):\r\n    if x + 1 != arr[i + 1]:\r\n    return arr[i + 1]\r\n",
  "56747fd5cb988479af000028": "def get_middle(s):\r\n    index, odd = divmod(len(s), 2)\r\n    return s[index] if odd else s[index - 1: index + 1]\r\n",
  "57a0556c7cb1f31ab3000ad7": "def make_upper_case(s): return s . upper()\n",
  "5174a4c0f2769dd8b1000003": "def solution(nums):\r\n    return sorted(nums) if nums else []\r\n",
  "53e30ec0116393fe1a00060b": "from collections import OrderedDict\n\n\ndef unique(integers):\n    return list(OrderedDict . fromkeys(integers))\n",
  "5f55ecd770692e001484af7d": "def mirror(data: list) - > list:\r\n    arr = sorted(data)\r\n    return arr + arr[- 2:: - 1]\r\n",
  "55685cd7ad70877c23000102": "def make_negative(number):\r\n    return - abs(number)\r\n",
  "54d512e62a5e54c96200019e": "def primeFactors(n):\n    i = 2\n    r = ''\n    while n != 1:\n    k = 0\n    while n % i == 0:\n    n = n / i\n    k += 1\n    if k == 1:\n    r = r + '(' + str(i) + ')'\n    elif k == 0:\n        pass\n    else:\n    r = r + '(' + str(i) + '**' + str(k) + ')'\n    i += 1\n    return r\n",
  "541c8630095125aba6000c00": "def digital_root(n):\r\n    return n if n < 10 else digital_root(sum(map(int, str(n))))\r\n",
  "54b72c16cd7f5154e9000457": "def decodeBits(bits):\r\n    import re\r\n    # remove trailing and leading 0's\r\n    bits = bits . strip('0')\r\n\r\n    # find the least amount of occurrences of either a 0 or 1, and that is the time hop\r\n    time_unit = min(len(m) for m in re . findall(r'1+|0+', bits))\r\n\r\n    # hop through the bits and translate to morse\r\n    return bits[:: time_unit]. replace('111', '-'). replace('1', '.'). replace('0000000', ' '). replace('000', ' '). replace('0', '')\r\n\r\n    def decodeMorse(morseCode):\r\n    return ' ' . join('' . join(MORSE_CODE[l] for l in w . split()) for w in morseCode . split(' '))\r\n",
  "55fd2d567d94ac3bc9000064": "def row_sum_odd_numbers(n):\r\n    # your code here\r\n    return n * * 3\r\n",
  "55f9bca8ecaa9eac7100004a": "def past(h, m, s):\r\n    return (3600 * h + 60 * m + s) * 1000\r\n",
  "5bb148b840196d1be50000b1": "def convert(s):\r\n    w2n = dict(zip(dict . fromkeys(s . upper()), '1023456789'))\r\n    return int('0' + '' . join([w2n[ch] for ch in s . upper()]))\r\n",
  "55ccdf1512938ce3ac000056": "def is_lock_ness_monster(s):\r\n    return any(i in s for i in ('tree fiddy', 'three fifty', '3.50'))\r\n",
  "5625618b1fe21ab49f00001f": "def say_hello(name):\r\n    return f\"Hello, { name } \"\r\n",
  "5672682212c8ecf83e000050": "from collections import deque\r\n\r\n\r\ndef dbl_linear(n):\r\n    h = 1\r\n    cnt = 0\r\n    q2, q3 = deque([]), deque([])\r\n    while True:\r\n    if (cnt >= n):\r\n    return h\r\n    q2 . append(2 * h + 1)\r\n    q3 . append(3 * h + 1)\r\n    h = min(q2[0], q3[0])\r\n    if h == q2[0]:\r\n        h = q2 . popleft()\r\n    if h == q3[0]:\r\n        h = q3 . popleft()\r\n    cnt += 1\r\n",
  "57a429e253ba3381850000fb": "def bmi(weight, height):\r\n    bmi = weight / height * * 2\r\n    if bmi <= 18.5:\r\n    return \"Underweight\"\r\n    elif bmi <= 25:\r\n    return \"Normal\"\r\n    elif bmi <= 30:\r\n    return \"Overweight\"\r\n    else:\r\n    return \"Obese\"\r\n",
  "57036f007fd72e3b77000023": "class Solution:\r\n\r\n    @ staticmethod\r\n    def main(self, * args):\r\n    print(\"Hello World!\")\r\n",
  "559590633066759614000063": "def min_max(lst):\r\n    return [min(lst), max(lst)]\r\n",
  "52549d3e19453df56f0000fe": "def fib(n):\r\n    a, b = 0, 1\r\n    for _ in range(n - 1):\r\n    a, b = b, a + b\r\n    return a\r\n",
  "54ff0d1f355cfd20e60001fc": "def factorial(n):\r\n    if n < 0 or n > 12:\r\n    raise ValueError\r\n    return 1 if n <= 1 else n * factorial(n - 1)\r\n",
  "56b7f2f3f18876033f000307": "def in_asc_order(arr):\r\n    return arr == sorted(arr)\r\n",
  "523b66342d0c301ae400003b": "def multiply(x, y):\r\n    return x * y\r\n",
  "53af2b8861023f1d88000832": "def areYouPlayingBanjo(name):\r\n    if name[0]. lower() == 'r':\r\n    return name + ' plays banjo'\r\n    else:\r\n    return name + ' does not play banjo'\r\n",
  "57356c55867b9b7a60000bd7": "def basic_op(operator, value1, value2):\r\n    if operator == '+':\r\n    return value1 + value2\r\n    if operator == '-':\r\n    return value1 - value2\r\n    if operator == '/':\r\n    return value1 / value2\r\n    if operator == '*':\r\n    return value1 * value2\r\n",
  "57f781872e3d8ca2a000007e": "def maps(a):\r\n    return [2 * x for x in a]\r\n",
  "554e4a2f232cdd87d9000038": "import string\n\n\ndef DNA_strand(dna):\n    return dna . translate(string . maketrans(\"ATCG\", \"TAGC\"))\n    # Python 3.4 solution || you don't need to import anything :)\n    # return dna.translate(str.maketrans(\"ATCG\",\"TAGC\"))\n",
  "580dda86c40fa6c45f00028a": "def cube_odd(arr):\r\n    return sum(n * * 3 for n in arr if n % 2) if all(type(n) == int for n in arr) else None\r\n",
  "5416f1834c24604c46000696": "def cycle(sequence):\r\n    for j, x in enumerate(sequence):\r\n    i = sequence . index(x)\r\n    if 0 <= i < j:\r\n    return [i, j - i]\r\n    return []\r\n",
  "5a3fe3dde1ce0e8ed6000097": "def century(year):\r\n    return (year + 99) / / 100\r\n",
  "555a67db74814aa4ee0001b5": "def is_even(n):\r\n    return n % 2 == 0\r\n",
  "6071ef9cbe6ec400228d9531": "def calculator(txt):\r\n    a, op, b = txt . split()\r\n    a, b = len(a), len(b)\r\n    return '.' * eval(f' { a } { op } { b } ')\r\n",
  "525c1a07bb6dda6944000031": "websites = [\"codewars\"] * 1000\n",
  "5865918c6b569962950002a1": "def strCount(string, letter):\r\n    return string . count(letter)\r\n",
  "5601409514fc93442500010b": "def better_than_average(class_points, your_points):\r\n    return your_points > sum(class_points) / len(class_points)\r\n",
  "57680d0128ed87c94f000bfd": "def find_word(board, word):\r\n    grid = [l + [''] for l in board] + [[''] * (len(board[0]) + 1)]\r\n    def rc(x, y, i):\r\n    if i == len(word):\r\n        return True\r\n    if grid[x][y] != word[i]:\r\n        return False\r\n    grid[x][y] = ''\r\n    r = any(rc(x + u, y + v, i + 1)\r\n            for u in range(- 1, 2)\r\n            for v in range(- 1, 2))\r\n    grid[x][y] = word[i]\r\n    return r\r\n    return any(rc(x, y, 0)\r\n               for x in range(len(board))\r\n               for y in range(len(board[x])))\r\n",
  "544675c6f971f7399a000e79": "def string_to_number(s):\r\n    return int(s)\r\n",
  "59590976838112bfea0000fa": "def beggars(values, n):\r\n    return [sum(values[i:: n]) for i in range(n)]\r\n",
  "57eadb7ecd143f4c9c0000a3": "def abbrevName(name):\r\n    return '.' . join(w[0] for w in name . split()). upper()\r\n",
  "57f780909f7e8e3183000078": "def grow(arr):\r\n\t product = 1\r\n for i in arr :\r\n\t\t product *= i \r\n return product",
  "54cb771c9b30e8b5250011d4": "def height(n, m):\n    h, t = 0, 1\n    for i in range(1, n + 1):\n    t = t * (m - i + 1) / / i\n    h += t\n    return h\n",
  "5a48fab7bdb9b5b3690009b6": "import numpy as np\n\n\ndef reorder(a, b):\n    return np . roll(np . arange(a). reshape(2, - 1), b, 1). tolist()\n",
  "591588d49f4056e13f000001": "LINES = \"{0} of beer on the wall, {0} of beer.\\nTake one down and pass it around, {1} of beer on the wall.\"\nSONG = '\\n' . join(LINES . format(\"{} bottles\" . format(\n    n), \"{} bottle\" . format(n - 1) + \"s\" * (n != 2)) for n in range(99, 1, - 1))\nSONG += \"\"\" \n 1 bottle of beer on the wall, 1 bottle of beer. \n Take one down and pass it around, no more bottles of beer on the wall. \n No more bottles of beer on the wall, no more bottles of beer. \n Go to the store and buy some more, 99 bottles of beer on the wall.\"\"\"\n\n\ndef HQ9(code):\n    return {'H': 'Hello World!', 'Q': 'Q', '9': SONG}. get(code, None)\n",
  "529bf0e9bdf7657179000008": "correct = [1, 2, 3, 4, 5, 6, 7, 8, 9]\r\n\r\n\r\ndef validSolution(board):\r\n    # check rows\r\n    for row in board:\r\n    if sorted(row) != correct:\r\n    return False\r\n    # check columns\r\n    for column in zip(* board):\r\n    if sorted(column) != correct:\r\n    return False\r\n    # check regions\r\n    for i in range(3):\r\n    for j in range(3):\r\n    region = []\r\n    for line in board[i * 3:(i + 1) * 3]:\r\n    region += line[j * 3:(j + 1) * 3]\r\n\r\n    if sorted(region) != correct:\r\n    return False\r\n    # if everything correct\r\n    return True\r\n",
  "523a86aa4230ebb5420001e1": "def anagrams(word, words): return [\n    item for item in words if sorted(item) == sorted(word)]\n",
  "55cb632c1a5d7b3ad0000145": "def hoopCount(n):\r\n    return \"Keep at it until you get it\" if n < 10 else \"Great, now move on to tricks\"\r\n",
  "5a805d8cafa10f8b930005ba": "def nearest_sq(n):\r\n    return round(n * * 0.5) * * 2\r\n",
  "5390bac347d09b7da40006f6": "def to_jaden_case(string):\r\n    return ' ' . join(word . capitalize() for word in string . split())\r\n",
  "54b724efac3d5402db00065e": "def decodeMorse(morseCode):\r\n    return ' ' . join('' . join(MORSE_CODE[letter] for letter in word . split(' ')) for word in morseCode . strip(). split(' '))\r\n",
  "51c8991dee245d7ddf00000e": "def reverseWords(str):\r\n    return \" \" . join(str . split(\" \")[:: - 1])\r\n",
  "54da539698b8a2ad76000228": "def isValidWalk(walk):\r\n    return len(walk) == 10 and walk . count('n') == walk . count('s') and walk . count('e') == walk . count('w')\r\n",
  "57ec8bd8f670e9a47a000f89": "def mouth_size(animal):\r\n    return 'small' if animal . lower() == 'alligator' else 'wide'\r\n",
  "53369039d7ab3ac506000467": "def bool_to_word(bool):\r\n    return \"Yes\" if bool else \"No\"\r\n",
  "578553c3a1b8d5c40300037c": "def binary_array_to_number(arr):\r\n    return int(\"\" . join(map(str, arr)), 2)\r\n",
  "5a00e05cc374cb34d100000d": "def reverseseq(n):\r\n    return list(range(n, 0, - 1))\r\n",
  "56f173a35b91399a05000cb7": "def find_longest(strng):\r\n    return max(len(a) for a in strng . split())\r\n",
  "56fa3c5ce4d45d2a52001b3c": "def xor(a, b):\r\n    return a != b\r\n",
  "55e2de13b668981d3300003d": "from re import compile\nREGEX = compile(r\"(-?\\d*)(x?)\\^?(-?\\d*)\"). fullmatch\n\n\ndef differentiate(poly):\n    a, x, n = REGEX(poly). groups()\n    a, n = int(- 1 if a == '-' else a or 1), int(n or bool(x))\n    if n == 0 or n == 1:\n        return f\" { a * n } \"\n    if n == 2:\n        return f\" { a * n } x\"\n    return f\" { a * n } x^ { n - 1 } \"\n",
  "5412509bd436bd33920011bc": "# return masked string\ndef maskify(cc):\n    return \"#\" * (len(cc) - 4) + cc[- 4:]\n",
  "5277c8a221e209d3f6000b56": "def validBraces(string):\r\n    braces = {\"(\": \")\", \"[\": \"]\", \"{\": \"}\"}\r\n    stack = []\r\n    for character in string:\r\n    if character in braces . keys():\r\n    stack . append(character)\r\n    else:\r\n    if len(stack) == 0 or braces[stack . pop()] != character:\r\n    return False\r\n    return len(stack) == 0\r\n",
  "57a2013acf1fa5bfc4000921": "def find_average(array):\r\n    return sum(array) / len(array) if array else 0\r\n",
  "5946a0a64a2c5b596500019a": "def split_and_add(numbers, n):\r\n    for _ in range(n):\r\n    middle = len(numbers) / / 2\r\n    left = numbers[: middle]\r\n    right = numbers[middle:]\r\n    numbers = [a + b for a,\r\n               b in zip((len(right) - len(left)) * [0] + left, right)]\r\n    if len(numbers) == 1:\r\n    return numbers\r\n    return numbers\r\n",
  "5810ad962b321bac8f000178": "from random import shuffle\r\n\r\n\r\ndef shuffled_deck():\r\n    arr = [f' { x } { i } ' for x in \"HCDS\" for i in range(1, 14)]\r\n    shuffle(arr)\r\n    return arr\r\n",
  "582cb0224e56e068d800003c": "def litres(time):\r\n    return time / / 2\r\n",
  "5772da22b89313a4d50012f7": "def greet(name, owner):\r\n    return \"Hello boss\" if name == owner else \"Hello guest\"\r\n",
  "570409d3d80ec699af001bf9": "def fusc(n):\r\n    assert type(n) == int and n >= 0\r\n    if n < 2:\r\n    return n\r\n    if n % 2 == 0:\r\n    return fusc(n / / 2)\r\n    else:\r\n    return fusc(n / / 2) + fusc(n / / 2 + 1)\r\n",
  "53da3dbb4a5168369a0000fe": "def even_or_odd(number):\r\n    return 'Odd' if number % 2 else 'Even'\r\n",
  "568dcc3c7f12767a62000038": "def set_alarm(employed, vacation):\r\n    return employed and not vacation\r\n",
  "5862f663b4e9d6f12b00003b": "def guess_blue(blue_start, red_start, blue_pulled, red_pulled):\n    blue_remaining = blue_start - blue_pulled\n    red_remaining = red_start - red_pulled\n    return blue_remaining / (blue_remaining + red_remaining)\n",
  "563f037412e5ada593000114": "def calculate_years(principal, interest, tax, desired):\r\n    years = 0\r\n    while principal < desired:\r\n    principal += (interest * principal) * (1 - tax)\r\n    years += 1\r\n    return years\r\n",
  "55a2d7ebe362935a210000b2": "def findSmallestInt(arr):\r\n    return min(arr)\r\n",
  "52a78825cdfc2cfc87000005": "import re\r\nfrom operator import mul, truediv as div, add, sub\r\nOPS = {'*': mul, '/': div, '-': sub, '+': add}\r\n\r\n\r\ndef calc(expression):\r\n    tokens = re . findall(r'[.\\d]+|[()+*/-]', expression)\r\n    return parse_AddSub(tokens, 0)[0]\r\n\r\n    def parse_AddSub(tokens, iTok):\r\n\r\n    v, iTok = parse_MulDiv(tokens, iTok)\r\n\r\n    while iTok < len(tokens) and tokens[iTok] != ')':\r\n    tok = tokens[iTok]\r\n    if tok in '-+':\r\n    v2, iTok = parse_MulDiv(tokens, iTok + 1)\r\n    v = OPS[tok](v, v2)\r\n\r\n    return v, iTok\r\n    def parse_MulDiv(tokens, iTok):\r\n\r\n    v, iTok = parse_Term(tokens, iTok)\r\n\r\n    while iTok < len(tokens) and tokens[iTok] in '*/':\r\n    op = tokens[iTok]\r\n    v2, iTok = parse_Term(tokens, iTok + 1)\r\n    v = OPS[op](v, v2)\r\n\r\n    return v, iTok\r\n    def parse_Term(tokens, iTok):\r\n    tok = tokens[iTok]\r\n\r\n    if tok == '(':\r\n    v, iTok = parse_AddSub(tokens, iTok + 1)\r\n    if iTok < len(tokens) and tokens[iTok] != ')':\r\n        raise Exception()\r\n\r\n    elif tok == '-':\r\n    v, iTok = parse_Term(tokens, iTok + 1)\r\n    v, iTok = - v, iTok - 1\r\n    else:\r\n    v = float(tok)\r\n\r\n    return v, iTok + 1\r\n",
  "55d277882e139d0b6000005d": "def find_average(nums):\r\n    return sum(nums) / len(nums) if nums else 0\r\n",
  "52f787eb172a8b4ae1000a34": "def zeros(n):\n    \"\"\" \n    No factorial is going to have fewer zeros than the factorial of a smaller \n    number. \n    Each multiple of 5 adds a 0, so first we count how many multiples of 5 are \n    smaller than `n` (`n // 5`). \n    Each multiple of 25 adds two 0's, so next we add another 0 for each multiple \n    of 25 smaller than n. \n    We continue on for all powers of 5 smaller than (or equal to) n. \n    \"\"\"\n    pow_of_5 = 5\n    zeros = 0\n    while n >= pow_of_5:\n    zeros += n / / pow_of_5\n    pow_of_5 *= 5\n    return zeros\n",
  "56f6919a6b88de18ff000b36": "def how_many_dalmatians(n):\r\n    dogs = [\"Hardly any\", \"More than a handful!\",\r\n            \"Woah that's a lot of dogs!\", \"101 DALMATIONS!!!\"]\r\n    return dogs[0] if n <= 10 else dogs[1] if n <= 50 else dogs[3] if n == 101 else dogs[2]\r\n",
  "55f9b48403f6b87a7c0000bd": "def paperwork(n, m):\r\n    return n * m if n > 0 and m > 0 else 0\r\n",
  "52ec24228a515e620b0005ef": "ANSWERS = {\r\n    0: 1,\r\n    1: 1,\r\n    2: 2,\r\n    3: 3,\r\n    4: 5,\r\n    5: 7,\r\n    6: 11,\r\n    7: 15,\r\n    8: 22,\r\n    9: 30,\r\n    10: 42,\r\n    11: 56,\r\n    12: 77,\r\n    13: 101,\r\n    14: 135,\r\n    15: 176,\r\n    16: 231,\r\n    17: 297,\r\n    18: 385,\r\n    19: 490,\r\n    20: 627,\r\n    21: 792,\r\n    22: 1002,\r\n    23: 1255,\r\n    24: 1575,\r\n    25: 1958,\r\n    26: 2436,\r\n    27: 3010,\r\n    28: 3718,\r\n    29: 4565,\r\n    30: 5604,\r\n    31: 6842,\r\n    32: 8349,\r\n    33: 10143,\r\n    34: 12310,\r\n    35: 14883,\r\n    36: 17977,\r\n    37: 21637,\r\n    38: 26015,\r\n    39: 31185,\r\n    40: 37338,\r\n    41: 44583,\r\n    42: 53174,\r\n    43: 63261,\r\n    44: 75175,\r\n    45: 89134,\r\n    46: 105558,\r\n    47: 124754,\r\n    48: 147273,\r\n    49: 173525,\r\n    50: 204226,\r\n    51: 239943,\r\n    52: 281589,\r\n    53: 329931,\r\n    54: 386155,\r\n    55: 451276,\r\n    56: 526823,\r\n    57: 614154,\r\n    58: 715220,\r\n    59: 831820,\r\n    60: 966467,\r\n    61: 1121505,\r\n    62: 1300156,\r\n    63: 1505499,\r\n    64: 1741630,\r\n    65: 2012558,\r\n    66: 2323520,\r\n    67: 2679689,\r\n    68: 3087735,\r\n    69: 3554345,\r\n    70: 4087968,\r\n    71: 4697205,\r\n    72: 5392783,\r\n    73: 6185689,\r\n    74: 7089500,\r\n    75: 8118264,\r\n    76: 9289091,\r\n    77: 10619863,\r\n    78: 12132164,\r\n    79: 13848650,\r\n    80: 15796476,\r\n    81: 18004327,\r\n    82: 20506255,\r\n    83: 23338469,\r\n    84: 26543660,\r\n    85: 30167357,\r\n    86: 34262962,\r\n    87: 38887673,\r\n    88: 44108109,\r\n    89: 49995925,\r\n    90: 56634173,\r\n    91: 64112359,\r\n    92: 72533807,\r\n    93: 82010177,\r\n    94: 92669720,\r\n    95: 104651419,\r\n    96: 118114304,\r\n    97: 133230930,\r\n    98: 150198136,\r\n    99: 169229875,\r\n    100: 190569292,\r\n    101: 214481126,\r\n    102: 241265379,\r\n    103: 271248950,\r\n    104: 304801365,\r\n    105: 342325709,\r\n    106: 384276336,\r\n    107: 431149389,\r\n    108: 483502844,\r\n    109: 541946240,\r\n    110: 607163746,\r\n    111: 679903203,\r\n    112: 761002156,\r\n    113: 851376628,\r\n    114: 952050665,\r\n    115: 1064144451,\r\n    116: 1188908248,\r\n    117: 1327710076,\r\n    118: 1482074143,\r\n    119: 1653668665,\r\n    120: 1844349560,\r\n    121: 2056148051,\r\n    122: 2291320912,\r\n    123: 2552338241,\r\n    124: 2841940500,\r\n    125: 3163127352,\r\n    126: 3519222692,\r\n    127: 3913864295,\r\n    128: 4351078600,\r\n    129: 4835271870,\r\n    130: 5371315400,\r\n    131: 5964539504,\r\n    132: 6620830889,\r\n    133: 7346629512,\r\n    134: 8149040695,\r\n    135: 9035836076,\r\n    136: 10015581680,\r\n    137: 11097645016,\r\n    138: 12292341831,\r\n    139: 13610949895,\r\n    140: 15065878135,\r\n    141: 16670689208,\r\n    142: 18440293320,\r\n    143: 20390982757,\r\n    144: 22540654445,\r\n    145: 24908858009,\r\n    146: 27517052599,\r\n    147: 30388671978,\r\n    148: 33549419497,\r\n    149: 37027355200,\r\n    150: 40853235313,\r\n    151: 45060624582,\r\n    152: 49686288421,\r\n    153: 54770336324,\r\n    154: 60356673280,\r\n    155: 66493182097,\r\n    156: 73232243759,\r\n    157: 80630964769,\r\n    158: 88751778802,\r\n    159: 97662728555,\r\n    160: 107438159466,\r\n    161: 118159068427,\r\n    162: 129913904637,\r\n    163: 142798995930,\r\n    164: 156919475295,\r\n    165: 172389800255,\r\n    166: 189334822579,\r\n    167: 207890420102,\r\n    168: 228204732751,\r\n    169: 250438925115,\r\n    170: 274768617130,\r\n    171: 301384802048,\r\n    172: 330495499613,\r\n    173: 362326859895,\r\n    174: 397125074750,\r\n    175: 435157697830,\r\n    176: 476715857290,\r\n    177: 522115831195,\r\n    178: 571701605655,\r\n    179: 625846753120,\r\n    180: 684957390936,\r\n    181: 749474411781,\r\n    182: 819876908323,\r\n    183: 896684817527,\r\n    184: 980462880430,\r\n    185: 1071823774337,\r\n    186: 1171432692373,\r\n    187: 1280011042268,\r\n    188: 1398341745571,\r\n    189: 1527273599625,\r\n    190: 1667727404093,\r\n    191: 1820701100652,\r\n    192: 1987276856363,\r\n    193: 2168627105469,\r\n    194: 2366022741845,\r\n    195: 2580840212973,\r\n    196: 2814570987591,\r\n    197: 3068829878530,\r\n    198: 3345365983698,\r\n    199: 3646072432125,\r\n    200: 3972999029388,\r\n    201: 4328363658647,\r\n    202: 4714566886083,\r\n    203: 5134205287973,\r\n    204: 5590088317495,\r\n    205: 6085253859260,\r\n    206: 6622987708040,\r\n    207: 7206841706490,\r\n    208: 7840656226137,\r\n    209: 8528581302375,\r\n    210: 9275102575355,\r\n    211: 10085065885767,\r\n    212: 10963707205259,\r\n    213: 11916681236278,\r\n    214: 12950095925895,\r\n    215: 14070545699287,\r\n    216: 15285151248481,\r\n    217: 16601598107914,\r\n    218: 18028182516671,\r\n    219: 19573856161145,\r\n    220: 21248279009367,\r\n    221: 23061871173849,\r\n    222: 25025873760111,\r\n    223: 27152408925615,\r\n    224: 29454549941750,\r\n    225: 31946390696157,\r\n    226: 34643126322519,\r\n    227: 37561133582570,\r\n    228: 40718063627362,\r\n    229: 44132934884255,\r\n    230: 47826239745920,\r\n    231: 51820051838712,\r\n    232: 56138148670947,\r\n    233: 60806135438329,\r\n    234: 65851585970275,\r\n    235: 71304185514919,\r\n    236: 77195892663512,\r\n    237: 83561103925871,\r\n    238: 90436839668817,\r\n    239: 97862933703585,\r\n    240: 105882246722733,\r\n    241: 114540884553038,\r\n    242: 123888443077259,\r\n    243: 133978259344888,\r\n    244: 144867692496445,\r\n    245: 156618412527946,\r\n    246: 169296722391554,\r\n    247: 182973889854026,\r\n    248: 197726516681672,\r\n    249: 213636919820625,\r\n    250: 230793554364681,\r\n    251: 249291451168559,\r\n    252: 269232701252579,\r\n    253: 290726957916112,\r\n    254: 313891991306665,\r\n    255: 338854264248680,\r\n    256: 365749566870782,\r\n    257: 394723676655357,\r\n    258: 425933084409356,\r\n    259: 459545750448675,\r\n    260: 495741934760846,\r\n    261: 534715062908609,\r\n    262: 576672674947168,\r\n    263: 621837416509615,\r\n    264: 670448123060170,\r\n    265: 722760953690372,\r\n    266: 779050629562167,\r\n    267: 839611730366814,\r\n    268: 904760108316360,\r\n    269: 974834369944625,\r\n    270: 1050197489931117,\r\n    271: 1131238503938606,\r\n    272: 1218374349844333,\r\n    273: 1312051800816215,\r\n    274: 1412749565173450,\r\n    275: 1520980492851175,\r\n    276: 1637293969337171,\r\n    277: 1762278433057269,\r\n    278: 1896564103591584,\r\n    279: 2040825852575075,\r\n    280: 2195786311682516,\r\n    281: 2362219145337711,\r\n    282: 2540952590045698,\r\n    283: 2732873183547535,\r\n    284: 2938929793929555,\r\n    285: 3160137867148997,\r\n    286: 3397584011986773,\r\n    287: 3652430836071053,\r\n    288: 3925922161489422,\r\n    289: 4219388528587095,\r\n    290: 4534253126900886,\r\n    291: 4872038056472084,\r\n    292: 5234371069753672,\r\n    293: 5622992691950605,\r\n    294: 6039763882095515,\r\n    295: 6486674127079088,\r\n    296: 6965850144195831,\r\n    297: 7479565078510584,\r\n    298: 8030248384943040,\r\n    299: 8620496275465025,\r\n    300: 9253082936723602,\r\n    301: 9930972392403501,\r\n    302: 10657331232548839,\r\n    303: 11435542077822104,\r\n    304: 12269218019229465,\r\n    305: 13162217895057704,\r\n    306: 14118662665280005,\r\n    307: 15142952738857194,\r\n    308: 16239786535829663,\r\n    309: 17414180133147295,\r\n    310: 18671488299600364,\r\n    311: 20017426762576945,\r\n    312: 21458096037352891,\r\n    313: 23000006655487337,\r\n    314: 24650106150830490,\r\n    315: 26415807633566326,\r\n    316: 28305020340996003,\r\n    317: 30326181989842964,\r\n    318: 32488293351466654,\r\n    319: 34800954869440830,\r\n    320: 37274405776748077,\r\n    321: 39919565526999991,\r\n    322: 42748078035954696,\r\n    323: 45772358543578028,\r\n    324: 49005643635237875,\r\n    325: 52462044228828641,\r\n    326: 56156602112874289,\r\n    327: 60105349839666544,\r\n    328: 64325374609114550,\r\n    329: 68834885946073850,\r\n    330: 73653287861850339,\r\n    331: 78801255302666615,\r\n    332: 84300815636225119,\r\n    333: 90175434980549623,\r\n    334: 96450110192202760,\r\n    335: 103151466321735325,\r\n    336: 110307860425292772,\r\n    337: 117949491546113972,\r\n    338: 126108517833796355,\r\n    339: 134819180623301520,\r\n    340: 144117936527873832,\r\n    341: 154043597379576030,\r\n    342: 164637479165761044,\r\n    343: 175943559810422753,\r\n    344: 188008647052292980,\r\n    345: 200882556287683159,\r\n    346: 214618299743286299,\r\n    347: 229272286871217150,\r\n    348: 244904537455382406,\r\n    349: 261578907351144125,\r\n    350: 279363328483702152,\r\n    351: 298330063062758076,\r\n    352: 318555973788329084,\r\n    353: 340122810048577428,\r\n    354: 363117512048110005,\r\n    355: 387632532919029223,\r\n    356: 413766180933342362,\r\n    357: 441622981929358437,\r\n    358: 471314064268398780,\r\n    359: 502957566506000020,\r\n    360: 536679070310691121,\r\n    361: 572612058898037559,\r\n    362: 610898403751884101,\r\n    363: 651688879997206959,\r\n    364: 695143713458946040,\r\n    365: 741433159884081684,\r\n    366: 790738119649411319,\r\n    367: 843250788562528427,\r\n    368: 899175348396088349,\r\n    369: 958728697912338045,\r\n    370: 1022141228367345362,\r\n    371: 1089657644424399782,\r\n    372: 1161537834849962850,\r\n    373: 1238057794119125085,\r\n    374: 1319510599727473500,\r\n    375: 1406207446561484054,\r\n    376: 1498478743590581081,\r\n    377: 1596675274490756791,\r\n    378: 1701169427975813525,\r\n    379: 1812356499739472950,\r\n    380: 1930656072350465812,\r\n    381: 2056513475336633805,\r\n    382: 2190401332423765131,\r\n    383: 2332821198543892336,\r\n    384: 2484305294265418180,\r\n    385: 2645418340688763701,\r\n    386: 2816759503217942792,\r\n    387: 2998964447736452194,\r\n    388: 3192707518433532826,\r\n    389: 3398704041358160275,\r\n    390: 3617712763867604423,\r\n    391: 3850538434667429186,\r\n    392: 4098034535626594791,\r\n    393: 4361106170762284114,\r\n    394: 4640713124699623515,\r\n    395: 4937873096788191655,\r\n    396: 5253665124416975163,\r\n    397: 5589233202595404488,\r\n    398: 5945790114707874597,\r\n    399: 6324621482504294325,\r\n    400: 6727090051741041926,\r\n    401: 7154640222653942321,\r\n    402: 7608802843339879269,\r\n    403: 8091200276484465581,\r\n    404: 8603551759348655060,\r\n    405: 9147679068859117602,\r\n    406: 9725512513742021729,\r\n    407: 10339097267123947241,\r\n    408: 10990600063775926994,\r\n    409: 11682316277192317780,\r\n    410: 12416677403151190382,\r\n    411: 13196258966925435702,\r\n    412: 14023788883518847344,\r\n    413: 14902156290309948968,\r\n    414: 15834420884488187770,\r\n    415: 16823822787139235544,\r\n    416: 17873792969689876004,\r\n    417: 18987964267331664557,\r\n    418: 20170183018805933659,\r\n    419: 21424521360255636320,\r\n    420: 22755290216580025259,\r\n    421: 24167053021441363961,\r\n    422: 25664640213837714846,\r\n    423: 27253164546230421739,\r\n    424: 28938037257084798150,\r\n    425: 30724985147095051099,\r\n    426: 32620068617410232189,\r\n    427: 34629700713903575934,\r\n    428: 36760667241831527309,\r\n    429: 39020148000237259665,\r\n    430: 41415739207102358378,\r\n    431: 43955477170518116534,\r\n    432: 46647863284229267991,\r\n    433: 49501890409405150715,\r\n    434: 52527070729108240605,\r\n    435: 55733465144636286656,\r\n    436: 59131714309169618645,\r\n    437: 62733071376043079215,\r\n    438: 66549436566966297367,\r\n    439: 70593393646562135510,\r\n    440: 74878248419470886233,\r\n    441: 79418069346443402240,\r\n    442: 84227730407729499781,\r\n    443: 89322956321353645667,\r\n    444: 94720370257893471820,\r\n    445: 100437544171752847604,\r\n    446: 106493051905239118581,\r\n    447: 112906525199196103354,\r\n    448: 119698712782720205954,\r\n    449: 126891542690981418000,\r\n    450: 134508188001572923840,\r\n    451: 142573136155347404229,\r\n    452: 151112262071917313678,\r\n    453: 160152905244553715585,\r\n    454: 169723951046458040965,\r\n    455: 179855916453958267598,\r\n    456: 190581040442651931034,\r\n    457: 201933379285114688629,\r\n    458: 213948907032733069132,\r\n    459: 226665621435831345565,\r\n    460: 240123655613925192081,\r\n    461: 254365395758574199975,\r\n    462: 269435605212954994471,\r\n    463: 285381555241961986287,\r\n    464: 302253162872576636605,\r\n    465: 320103136152993290544,\r\n    466: 338987127249525432549,\r\n    467: 358963893768162876613,\r\n    468: 380095468763120598477,\r\n    469: 402447339861711475160,\r\n    470: 426088638015652413417,\r\n    471: 451092336355096099864,\r\n    472: 477535459708164115593,\r\n    473: 505499305314204629558,\r\n    474: 535069675351607262125,\r\n    475: 566337121865805599675,\r\n    476: 599397204782301852926,\r\n    477: 634350763653787028583,\r\n    478: 671304203896731807232,\r\n    479: 710369798236628238005,\r\n    480: 751666004194993125591,\r\n    481: 795317798414758232180,\r\n    482: 841457028742823649455,\r\n    483: 890222784951928088294,\r\n    484: 941761789114997698055,\r\n    485: 996228806608573411012,\r\n    486: 1053787078862455346513,\r\n    487: 1114608778936426484248,\r\n    488: 1178875491155735802646,\r\n    489: 1246778716001272919665,\r\n    490: 1318520401612270233223,\r\n    491: 1394313503224447816939,\r\n    492: 1474382572040363953132,\r\n    493: 1558964374994977806173,\r\n    494: 1648308547066172438760,\r\n    495: 1742678277747760981187,\r\n    496: 1842351033503159891466,\r\n    497: 1947619317987658064007,\r\n    498: 2058791472042884901563,\r\n    499: 2176192515439287461625,\r\n    500: 2300165032574323995027,\r\n    501: 2431070104309287327876,\r\n    502: 2569288288377098289281,\r\n    503: 2715220650772245313220,\r\n    504: 2869289850802400662045,\r\n    505: 3031941282464413132742,\r\n    506: 3203644275096202070012,\r\n    507: 3384893356244349844341,\r\n    508: 3576209579998154653671,\r\n    509: 3778141924035171537110,\r\n    510: 3991268758958164118300,\r\n    511: 4216199393504640098482,\r\n    512: 4453575699570940947378,\r\n    513: 4704073821002175842062,\r\n    514: 4968405970488126319775,\r\n    515: 5247322318923878793976,\r\n    516: 5541612982013113936133,\r\n    517: 5852110108921301661040,\r\n    518: 6179690078238084808000,\r\n    519: 6525275806549652788115,\r\n    520: 6889839175409542385648,\r\n    521: 7274403582551733377346,\r\n    522: 7680046623716094332553,\r\n    523: 8107902911527474124146,\r\n    524: 8559167038437716736150,\r\n    525: 9035096690829005915201,\r\n    526: 9537015921990240021538,\r\n    527: 10066318591787500106586,\r\n    528: 10624471981512075020731,\r\n    529: 11213020592521695111580,\r\n    530: 11833590138006300416410,\r\n    531: 12487891737367521803652,\r\n    532: 13177726323474524612308,\r\n    533: 13904989273245567335012,\r\n    534: 14671675272840783232475,\r\n    535: 15479883428970761068959,\r\n    536: 16331822638729701493803,\r\n    537: 17229817230617210720599,\r\n    538: 18176312890390861435034,\r\n    539: 19173882885687454484110,\r\n    540: 20225234604409151266221,\r\n    541: 21333216422211708570598,\r\n    542: 22500824915577356165493,\r\n    543: 23731212437346370138355,\r\n    544: 25027695072821279146420,\r\n    545: 26393760995005382968154,\r\n    546: 27833079238879849385687,\r\n    547: 29349508915133986374841,\r\n    548: 30947108885217475101876,\r\n    549: 32630147920163234060900,\r\n    550: 34403115367205050943160,\r\n    551: 36270732348871285128752,\r\n    552: 38237963520943177237554,\r\n    553: 40310029416409244587122,\r\n    554: 42492419404397720872600,\r\n    555: 44790905293907018009131,\r\n    556: 47211555614160398040338,\r\n    557: 49760750604354432757376,\r\n    558: 52445197947746313627407,\r\n    559: 55271949286085137715955,\r\n    560: 58248417552751868050007,\r\n    561: 61382395164161775318496,\r\n    562: 64682073111542943380454,\r\n    563: 68156060996536236172174,\r\n    564: 71813408056839596203570,\r\n    565: 75663625229609055443637,\r\n    566: 79716708303343130521599,\r\n    567: 83983162210640880002321,\r\n    568: 88474026517495817981253,\r\n    569: 93200902166643654187580,\r\n    570: 98175979536033971312388,\r\n    571: 103412067875563710992446,\r\n    572: 108922626189067392956037,\r\n    573: 114721795630860408658491,\r\n    574: 120824433490320564237125,\r\n    575: 127246148840551966562301,\r\n    576: 134003339931725153597473,\r\n    577: 141113233412529912746558,\r\n    578: 148593925468119890197615,\r\n    579: 156464424966082817448060,\r\n    580: 164744698707340387584240,\r\n    581: 173455718882380096095248,\r\n    582: 182619512839056823919887,\r\n    583: 192259215272078129526277,\r\n    584: 202399122950629095580175,\r\n    585: 213064752104884207160129,\r\n    586: 224282898599046831034631,\r\n    587: 236081701023305130945921,\r\n    588: 248490706844586261413858,\r\n    589: 261540941761240642265710,\r\n    590: 275264982414934173206642,\r\n    591: 289697032618827122974972,\r\n    592: 304873003269975366031783,\r\n    593: 320830596120295386610807,\r\n    594: 337609391590065169560935,\r\n    595: 355250940815002702558187,\r\n    596: 373798862128436852709430,\r\n    597: 393298942187883251157044,\r\n    598: 413799241966727832978027,\r\n    599: 435350207840317348270000,\r\n    600: 458004788008144308553622,\r\n    601: 481818554503286362923739,\r\n    602: 506849831053734861481872,\r\n    603: 533159827070679866278987,\r\n    604: 560812778053476538349420,\r\n    605: 589876092712502332463864,\r\n    606: 620420507127059714307352,\r\n    607: 652520246268116112057164,\r\n    608: 686253193233019826880477,\r\n    609: 721701066553229757379480,\r\n    610: 758949605954969709105721,\r\n    611: 798088766967999186006767,\r\n    612: 839212924798226411060795,\r\n    613: 882421087896683264554175,\r\n    614: 927817121679723721849795,\r\n    615: 975509982873756796925504,\r\n    616: 1025613964982134990453294,\r\n    617: 1078248955392080004474789,\r\n    618: 1133540704665979618906662,\r\n    619: 1191621108583631746910145,\r\n    620: 1252628503530795506440909,\r\n    621: 1316707975853817969920561,\r\n    622: 1384011685831426958558879,\r\n    623: 1454699206941558115141676,\r\n    624: 1528937881135168275063375,\r\n    625: 1606903190858354689128371,\r\n    626: 1688779148601189609516729,\r\n    627: 1774758704783877366657989,\r\n    628: 1865044174831202682776536,\r\n    629: 1959847686321528964669495,\r\n    630: 2059391647140527228529479,\r\n    631: 2163909235608484556362424,\r\n    632: 2273644913597837330081136,\r\n    633: 2388854963699932382735982,\r\n    634: 2509808051552031608082535,\r\n    635: 2636785814481962651219075,\r\n    636: 2770083477684418110395121,\r\n    637: 2910010499193691843303014,\r\n    638: 3056891244979232231862474,\r\n    639: 3211065695545980277248740,\r\n    640: 3372890185488482409685019,\r\n    641: 3542738177508596708707874,\r\n    642: 3721001072479541451508397,\r\n    643: 3908089057205582486668934,\r\n    644: 4104431991606013700457110,\r\n    645: 4310480337124871462076948,\r\n    646: 4526706128254173781044298,\r\n    647: 4753603989138067267826945,\r\n    648: 4991692197319220372390544,\r\n    649: 5241513796775816319683700,\r\n    650: 5503637762499727151307095,\r\n    651: 5778660218961559003723580,\r\n    652: 6067205714919484306343541,\r\n    653: 6369928557132709817142929,\r\n    654: 6687514205661440172553650,\r\n    655: 7020680733548749464953877,\r\n    656: 7370180353811425547662139,\r\n    657: 7736801016790889035132284,\r\n    658: 8121368081058512888507057,\r\n    659: 8524746061205131302394950,\r\n    660: 8947840456000332817673697,\r\n    661: 9391599660555044587641517,\r\n    662: 9857016966290401433259592,\r\n    663: 10345132652677367520056676,\r\n    664: 10857036174895938656583295,\r\n    665: 11393868451739000294452939,\r\n    666: 11956824258286445517629485,\r\n    667: 12547154728067493595502055,\r\n    668: 13166169969647255482980383,\r\n    669: 13815241802783448943206160,\r\n    670: 14495806619536377005379418,\r\n    671: 15209368375944215483241988,\r\n    672: 15957501720133631304230773,\r\n    673: 16741855262985451980947171,\r\n    674: 17564154997755650263621500,\r\n    675: 18426207875324210441995136,\r\n    676: 19329905542049511423199336,\r\n    677: 20277228247502764885900784,\r\n    678: 21270248929688765106878025,\r\n    679: 22311137485682880566295780,\r\n    680: 23402165235974892374954302,\r\n    681: 24545709591163085124246501,\r\n    682: 25744258930034131533263392,\r\n    683: 27000417698448800353553865,\r\n    684: 28316911738879831363625420,\r\n    685: 29696593860867277871605321,\r\n    686: 31142449663120060247020395,\r\n    687: 32657603618448918933404658,\r\n    688: 34245325433219728719773420,\r\n    689: 35909036693513349075724695,\r\n    690: 37652317810725762600765183,\r\n    691: 39478915279883795756623331,\r\n    692: 41392749264546866860893416,\r\n    693: 43397921522754943172592795,\r\n    694: 45498723689129703063649450,\r\n    695: 47699645928878027716139269,\r\n    696: 50005385980149860746062163,\r\n    697: 52420858601901549459658530,\r\n    698: 54951205445179608281719072,\r\n    699: 57601805366500810491219000,\r\n    700: 60378285202834474611028659,\r\n    701: 63286531028521032840985510,\r\n    702: 66332699915362724119980694,\r\n    703: 69523232218023552371152320,\r\n    704: 72864864407855341219969825,\r\n    705: 76364642479247406973532354,\r\n    706: 80029935953661656574123574,\r\n    707: 83868452507581852374822598,\r\n    708: 87888253251761884175130183,\r\n    709: 92097768690318501305952845,\r\n    710: 96505815389469697877049934,\r\n    711: 101121613386982294887579670,\r\n    712: 105954804374756131323439197,\r\n    713: 111015470688345108146850290,\r\n    714: 116314155138696524440183805,\r\n    715: 121861881722882938654960142,\r\n    716: 127670177252209281782740521,\r\n    717: 133751093937700984130081285,\r\n    718: 140117232974725477106760252,\r\n    719: 146781769170263852819573505,\r\n    720: 153758476658245881594406593,\r\n    721: 161061755750279477635534762,\r\n    722: 168706660971164630122439117,\r\n    723: 176708930330666271859881567,\r\n    724: 185085015885255746880625875,\r\n    725: 193852115645795752984189381,\r\n    726: 203028206889569986197651315,\r\n    727: 212632080937520072186590492,\r\n    728: 222683379460186024851577401,\r\n    729: 233202632378520643600875145,\r\n    730: 244211297428606706709925517,\r\n    731: 255731801462210865865001525,\r\n    732: 267787583558210323920375877,\r\n    733: 280403140023083872114273884,\r\n    734: 293604071362025285843562670,\r\n    735: 307417131305664218954016427,\r\n    736: 321870277981032622582593573,\r\n    737: 336992727319136467572139095,\r\n    738: 352815008795455957133215652,\r\n    739: 369369023603738655757458075,\r\n    740: 386688105367749941220651375,\r\n    741: 404807083500032850651734059,\r\n    742: 423762349321394151918928481,\r\n    743: 443591925059596733749014862,\r\n    744: 464335535850798483634138280,\r\n    745: 486034684872448271784326296,\r\n    746: 508732731741838107613602755,\r\n    747: 532474974320122372524707631,\r\n    748: 557308734067567635805394638,\r\n    749: 583283445101886813536239875,\r\n    750: 610450747117966916191771809,\r\n    751: 638864582333908382360557376,\r\n    752: 668581296635294279311393900,\r\n    753: 699659745096778286894322787,\r\n    754: 732161402067670820574405230,\r\n    755: 766150476015982127183457373,\r\n    756: 801694029333610862568750951,\r\n    757: 838862103313805798709299373,\r\n    758: 877727848520950325159242658,\r\n    759: 918367660781873199488134935,\r\n    760: 960861323037560814483873080,\r\n    761: 1005292153304074193879898920,\r\n    762: 1051747159001957690209588887,\r\n    763: 1100317197924192833923669753,\r\n    764: 1151097146124113726578727360,\r\n    765: 1204186073016375022219516992,\r\n    766: 1259687423996378387111229150,\r\n    767: 1317709210896221493178043552,\r\n    768: 1378364210608578997366598385,\r\n    769: 1441770172223648126550509165,\r\n    770: 1508050033038752490738311726,\r\n    771: 1577332143815074048889599022,\r\n    772: 1649750503671651735806603894,\r\n    773: 1725445005022910006140645612,\r\n    774: 1804561688982956164492944650,\r\n    775: 1887253011677361609828822380,\r\n    776: 1973678121921532286407950000,\r\n    777: 2064003150743712843868729636,\r\n    778: 2158401513250589964731360493,\r\n    779: 2257054223353982965849642005,\r\n    780: 2360150221898687182164777966,\r\n    781: 2467886718753771981901721670,\r\n    782: 2580469549453004933593920862,\r\n    783: 2698113546994164480174756373,\r\n    784: 2821042929432312216467202070,\r\n    785: 2949491703928193388274450292,\r\n    786: 3083704087940340693022764503,\r\n    787: 3223934948277725160271634798,\r\n    788: 3370450258759473520427114109,\r\n    789: 3523527577258789108163787100,\r\n    790: 3683456542940343404363084600,\r\n    791: 3850539394533563994343413787,\r\n    792: 4025091510519029370421431033,\r\n    793: 4207441972141088280734057870,\r\n    794: 4397934150197476827913759850,\r\n    795: 4596926316595586652827474186,\r\n    796: 4804792281705797515062559743,\r\n    797: 5021922058584382849328869242,\r\n    798: 5248722555182613689484387822,\r\n    799: 5485618295704258477069984050,\r\n    800: 5733052172321422504456911979,\r\n    801: 5991486228508002426815719537,\r\n    802: 6261402475301701333080509487,\r\n    803: 6543303741858946450905285538,\r\n    804: 6837714561722963378455094385,\r\n    805: 7145182096283051986707103605,\r\n    806: 7466277096963606051213804496,\r\n    807: 7801594907743960700949000443,\r\n    808: 8151756509675604512522473567,\r\n    809: 8517409609130970421571757565,\r\n    810: 8899229771588828461969917962,\r\n    811: 9297921602834531195851268718,\r\n    812: 9714219979529959777862768265,\r\n    813: 10148891331187245215547993864,\r\n    814: 10602734975663191221223594155,\r\n    815: 11076584510377034355391142064,\r\n    816: 11571309261543787320061392679,\r\n    817: 12087815793808125625662163707,\r\n    818: 12627049482760689878061744701,\r\n    819: 13189996152918959195978870030,\r\n    820: 13777683783859651786576215682,\r\n    821: 14391184287298069419105856949,\r\n    822: 15031615358023124634594092724,\r\n    823: 15700142401714084441377203063,\r\n    824: 16397980542787591098996821750,\r\n    825: 17126396715550358417594267021,\r\n    826: 17886711842065410771034749979,\r\n    827: 18680303100276877491522988120,\r\n    828: 19508606286081561360311437674,\r\n    829: 20373118273183778133458320225,\r\n    830: 21275399574724765449983360003,\r\n    831: 22217077010838260632179411313,\r\n    832: 23199846486451169343993151122,\r\n    833: 24225475883821531494697782922,\r\n    834: 25295808074486832813101046425,\r\n    835: 26412764055483014097178757689,\r\n    836: 27578346214889968804237171486,\r\n    837: 28794641731961759722351371983,\r\n    838: 30063826117310982372086476080,\r\n    839: 31388166898835484452139885750,\r\n    840: 32770027459303858556350798600,\r\n    841: 34211871031752548278772284453,\r\n    842: 35716264859093977687647313415,\r\n    843: 37285884524590579748861394570,\r\n    844: 38923518460115987806848673270,\r\n    845: 40632072639400673752129300324,\r\n    846: 42414575463747094337180792099,\r\n    847: 44274182847997609942310578598,\r\n    848: 46214183514849300594196193732,\r\n    849: 48238004505931946889525421000,\r\n    850: 50349216918401212177548479675,\r\n    851: 52551541876147039010384562987,\r\n    852: 54848856745079917639394818823,\r\n    853: 57245201602333536237114022805,\r\n    854: 59744785969613964515539259105,\r\n    855: 62351995821331449988466091712,\r\n    856: 65071400878573831543609957267,\r\n    857: 67907762200418949875852866531,\r\n    858: 70866040084540107092698343096,\r\n    859: 73951402289532005957331751320,\r\n    860: 77169232591877674590168543277,\r\n    861: 80525139690988018278755885205,\r\n    862: 84024966476277979232856334449,\r\n    863: 87674799670795146675673859587,\r\n    864: 91480979866491345649258758095,\r\n    865: 95450111966823518214883921610,\r\n    866: 99589076052990565170686659417,\r\n    867: 103905038690755971019484297576,\r\n    868: 108405464695475636367939373595,\r\n    869: 113098129373644577851404473535,\r\n    870: 117991131259998859170817958839,\r\n    871: 123092905369958432777075796052,\r\n    872: 128412236987976529870072690275,\r\n    873: 133958276013169939669531019316,\r\n    874: 139740551884446204479331411000,\r\n    875: 145768989108216487062234772851,\r\n    876: 152053923412691097170490155923,\r\n    877: 158606118553696417431847045996,\r\n    878: 165436783797931931934295220337,\r\n    879: 172557592110602218633091543840,\r\n    880: 179980699075416049556058362840,\r\n    881: 187718762576041099642814429720,\r\n    882: 195784963269243383580949581161,\r\n    883: 204193025881123335512830178821,\r\n    884: 212957241359090878236182734445,\r\n    885: 222092489913497780851227603386,\r\n    886: 231614264984172822820073009257,\r\n    887: 241538698168481624527315178361,\r\n    888: 251882585148964518765460484674,\r\n    889: 262663412660090356154504995095,\r\n    890: 273899386535208029575034561337,\r\n    891: 285609460876378579895067651923,\r\n    892: 297813368391435715163322531331,\r\n    893: 310531651944349233813920512829,\r\n    894: 323785697366761254448562966675,\r\n    895: 337597767580427105501057917306,\r\n    896: 351991038082228660789452118410,\r\n    897: 366989633845435601723754690835,\r\n    898: 382618667692977386826261193199,\r\n    899: 398904280200653395819254517900,\r\n    900: 415873681190459054784114365430,\r\n    901: 433555192876539531087229255477,\r\n    902: 451978294728708525214023001725,\r\n    903: 471173670120985588372050797999,\r\n    904: 491173254835220446432862090800,\r\n    905: 512010287492584845146484412308,\r\n    906: 533719361988531136324395159455,\r\n    907: 556336482009740068071399064008,\r\n    908: 579899117714618242279047917300,\r\n    909: 604446264662056374189988834755,\r\n    910: 630018505076433611630379753807,\r\n    911: 656658071540248718776792346785,\r\n    912: 684408913209287275550344075013,\r\n    913: 713316764648893234122621625751,\r\n    914: 743429217393715213042975617565,\r\n    915: 774795794337240928934816284899,\r\n    916: 807468027061529837515792402675,\r\n    917: 841499536221802614337232047468,\r\n    918: 876946115104959930393838357571,\r\n    919: 913865816485680423486405066750,\r\n    920: 952319042908502961911588247808,\r\n    921: 992368640529229737341624411924,\r\n    922: 1034079996654109332431762911842,\r\n    923: 1077521141120571341397403386532,\r\n    924: 1122762851668802145076610697775,\r\n    925: 1169878763459173895733432737528,\r\n    926: 1218945482896482311379736998403,\r\n    927: 1270042705928112564209840426896,\r\n    928: 1323253340989653981276400185806,\r\n    929: 1378663636778122744608506419570,\r\n    930: 1436363315039845896899358328033,\r\n    931: 1496445708567209282036578487803,\r\n    932: 1559007904605896258842021462474,\r\n    933: 1624150893881942976244820893255,\r\n    934: 1691979725465930503404211099660,\r\n    935: 1762603667699924360130192603237,\r\n    936: 1836136375421380008668856717532,\r\n    937: 1912696063727159213943851080855,\r\n    938: 1992405688530070149968413761596,\r\n    939: 2075393134169954709485716047155,\r\n    940: 2161791408351324312330912522447,\r\n    941: 2251738844689892053427982289844,\r\n    942: 2345379313161090374436414551558,\r\n    943: 2442862438754801545567295092897,\r\n    944: 2544343828652090726779455860435,\r\n    945: 2649985308251720770267133439311,\r\n    946: 2759955166386673475403099789409,\r\n    947: 2874428410083806869907819978392,\r\n    948: 2993587029233173241168779714732,\r\n    949: 3117620271547411926979127053250,\r\n    950: 3246724928206047105940972859506,\r\n    951: 3381105630594468612010288127863,\r\n    952: 3520975158562887897616477410546,\r\n    953: 3666554760646647127956344306190,\r\n    954: 3818074486705953843294627812035,\r\n    955: 3975773533460423034845675035419,\r\n    956: 4139900603411771887815710365915,\r\n    957: 4310714277666637214536144927329,\r\n    958: 4488483403190813123215639907302,\r\n    959: 4673487495046245204241629451110,\r\n    960: 4866017154182911354694265206413,\r\n    961: 5066374501379277964399166419563,\r\n    962: 5274873627947390097986152243705,\r\n    963: 5491841063841846500452896053582,\r\n    964: 5717616263835974099255567733750,\r\n    965: 5952552112453464578853008309794,\r\n    966: 6197015448369619941842104648894,\r\n    967: 6451387609023188709970129910797,\r\n    968: 6716064996207615136996693074302,\r\n    969: 6991459663439386169435859778910,\r\n    970: 7277999925931103886207676505429,\r\n    971: 7576130994027952290703815097177,\r\n    972: 7886315630998429231248733036419,\r\n    973: 8209034836103596418058528755338,\r\n    974: 8544788553903729460741526714750,\r\n    975: 8894096410797147287955714755082,\r\n    976: 9257498479823236816318777820416,\r\n    977: 9635556074800288403768986034253,\r\n    978: 10028852574908795418824727341746,\r\n    979: 10437994280872373856676062879735,\r\n    980: 10863611303931504965592652844878,\r\n    981: 11306358488849924787366667765407,\r\n    982: 11766916372239763961801564990016,\r\n    983: 12245992177539511607834487453052,\r\n    984: 12744320848028628464246059627690,\r\n    985: 13262666119314202551196742822008,\r\n    986: 13801821632778520931079437719552,\r\n    987: 14362612091531863067120268402228,\r\n    988: 14945894460472306341153073892017,\r\n    989: 15552559212113915719970799358900,\r\n    990: 16183531619906475296861224625027,\r\n    991: 16839773100833956878604913215477,\r\n    992: 17522282609145324707635966077022,\r\n    993: 18232098083140097717852712346115,\r\n    994: 18970297947002453464660671155990,\r\n    995: 19738002669751617842096992232436,\r\n    996: 20536376383452971700767593594021,\r\n    997: 21366628562913781584556907794729,\r\n    998: 22230015769169865076825741905555,\r\n    999: 23127843459154899464880444632250,\r\n    1000: 24061467864032622473692149727991,\r\n    1001: 25032297938763929621013218349796,\r\n    1002: 26041797385576000582369625213281,\r\n    1003: 27091486754099167408984061096127,\r\n    1004: 28182945621039436811282417218990,\r\n    1005: 29317814852360484763188469380980,\r\n    1006: 30497798951058731380716134731126,\r\n    1007: 31724668493728872881006491578226,\r\n    1008: 33000262659235183814081519827753,\r\n    1009: 34326491852926110526276105821510,\r\n    1010: 35705340429956356495500048880518,\r\n    1011: 37138869521411924622451440267117,\r\n    1012: 38629219967069644267226780200798,\r\n    1013: 40178615358763694337831877170404,\r\n    1014: 41789365198477765393682507986660,\r\n    1015: 43463868175432916528376380161993,\r\n    1016: 45204615566598118821992112719830,\r\n    1017: 47014194765213080671467587361162,\r\n    1018: 48895292942081479136595740785155,\r\n    1019: 50850700844567331975836762416180,\r\n    1020: 52883316738408211899530127054215,\r\n    1021: 54996150497646497195116039121846,\r\n    1022: 57192327848174163803231700285962,\r\n    1023: 59475094770587936660132803278445,\r\n    1024: 61847822068260244309086870983975,\r\n    1025: 64314010106747559065438412709786,\r\n    1026: 66877293730881687431325192921834,\r\n    1027: 69541447366121616918816177545634,\r\n    1028: 72310390310983979753319152713934,\r\n    1029: 75188192227619293524858181464065,\r\n    1030: 78179078837859260757658669457252,\r\n    1031: 81287437832327804842152878336251,\r\n    1032: 84517825000485590628268677129623,\r\n    1033: 87874970589764795726619149717517,\r\n    1034: 91363785902248291467082481888195,\r\n    1035: 94989370137655453801161398756590,\r\n    1036: 98757017491716010698603869808070,\r\n    1037: 102672224519343960454073227246547,\r\n    1038: 106740697772366151410092496101554,\r\n    1039: 110968361721914939732387042839470,\r\n    1040: 115361366975961956826368092270559,\r\n    1041: 119926098802850790583643914139778,\r\n    1042: 124669185972080868004022654618279,\r\n    1043: 129597509924003418690815024769614,\r\n    1044: 134718214280513689012974236132740,\r\n    1045: 140038714709261994367964528304147,\r\n    1046: 145566709154360370820516947589011,\r\n    1047: 151310188447031979898125505211430,\r\n    1048: 157277447310137702096803724432844,\r\n    1049: 163477095771019024080265786609550,\r\n    1050: 169918070997619096807349078318498,\r\n    1051: 176609649573385253852206425342508,\r\n    1052: 183561460227017093724267411668558,\r\n    1053: 190783497033705025399011223174627,\r\n    1054: 198286133105105766051740791002035,\r\n    1055: 206080134785924286913455951259466,\r\n    1056: 214176676375616994965530422655441,\r\n    1057: 222587355394399185288134561600051,\r\n    1058: 231324208413431926871476886628488,\r\n    1059: 240399727469780275150398352541295,\r\n    1060: 249826877087477024806306436682550,\r\n    1061: 259619111926794902903903858282467,\r\n    1062: 269790395084626208521306859330203,\r\n    1063: 280355217069693265922512204254601,\r\n    1064: 291328615477166797747643128851965,\r\n    1065: 302726195388153340970512449363108,\r\n    1066: 314564150520428320398942429589829,\r\n    1067: 326859285157739328217944658021195,\r\n    1068: 339629036885985812650521091739503,\r\n    1069: 352891500165597792693064105229860,\r\n    1070: 366665450770488753893927654278831,\r\n    1071: 380970371125047658469252263285168,\r\n    1072: 395826476571763477972460354798893,\r\n    1073: 411254742603244027745802489871124,\r\n    1074: 427276933093600703409672633110750,\r\n    1075: 443915629565423279460548833975619,\r\n    1076: 461194261529865886819548193737883,\r\n    1077: 479137137938708024340405275972933,\r\n    1078: 497769479788644748304553495300446,\r\n    1079: 517117453919499510741582247311995,\r\n    1080: 537208208049543370281513128274546,\r\n    1081: 558069907092647074919064078269009,\r\n    1082: 579731770803589829653889090465310,\r\n    1083: 602224112799502127836867703068534,\r\n    1084: 625578381007131993715400129218655,\r\n    1085: 649827199587396195485096741151797,\r\n    1086: 675004412390512738195023734124239,\r\n    1087: 701145127996910209394091171983043,\r\n    1088: 728285766401075776846633724874013,\r\n    1089: 756464107397538946738052845597325,\r\n    1090: 785719340730295196686468011045384,\r\n    1091: 816092118069154575020287144949660,\r\n    1092: 847624606878758096201928227674051,\r\n    1093: 880360546248341702038727418718373,\r\n    1094: 914345304752746677204951178080640,\r\n    1095: 949625940417679322961779585842763,\r\n    1096: 986251262864814583017230902369159,\r\n    1097: 1024271897715020987348060381346241,\r\n    1098: 1063740353330761125682320075116819,\r\n    1099: 1104711089981595892462307006170625,\r\n    1100: 1147240591519695580043346988281283,\r\n    1101: 1191387439655339764253910592315288,\r\n    1102: 1237212390925574690626025966996290,\r\n    1103: 1284778456452494990829233226377379,\r\n    1104: 1334150984591030161739618104847170,\r\n    1105: 1385397746569649033264079085023363,\r\n    1106: 1438589025231051837956193683375282,\r\n    1107: 1493797706983703451005350179037500,\r\n    1108: 1551099377078977592324977502565855,\r\n    1109: 1610572418332734533482318570551190,\r\n    1110: 1672298113414349146588255526290127,\r\n    1111: 1736360750830546535004742869861557,\r\n    1112: 1802847734735894350158767668809929,\r\n    1113: 1871849698706449115822481531031302,\r\n    1114: 1943460623617864164855763103650900,\r\n    1115: 2017777959774244383161311335135412,\r\n    1116: 2094902753439183950276117590000925,\r\n    1117: 2174939777925753277977786731439319,\r\n    1118: 2257997669407716887103312005936867,\r\n    1119: 2344189067619971039484826726136835,\r\n    1120: 2433630761622095504505007624351926,\r\n    1121: 2526443840805024325560621670846260,\r\n    1122: 2622753851327163276606626468293628,\r\n    1123: 2722690958172823755991785784326387,\r\n    1124: 2826390113032612069265970456163500,\r\n    1125: 2933991228212416784843441604124699,\r\n    1126: 3045639356784883554548008634432380,\r\n    1127: 3161484879204764376319516386806829,\r\n    1128: 3281683696617285755657387337131749,\r\n    1129: 3406397431096706053660787897070925,\r\n    1130: 3535793633060536116646611744883745,\r\n    1131: 3670045996113488118329838058723628,\r\n    1132: 3809334579584105681944821254585338,\r\n    1133: 3953846039026223475533484851711932,\r\n    1134: 4103773864966917551549475742004630,\r\n    1135: 4259318630192449100691154502765975,\r\n    1136: 4420688245873885709566584952625897,\r\n    1137: 4588098226844616747507844508037264,\r\n    1138: 4761771966352875646576237849731855,\r\n    1139: 4941941020623653451737160975884815,\r\n    1140: 5128845403576048431946742302750170,\r\n    1141: 5322733892054158457915227866236060,\r\n    1142: 5523864341942100491068450472029219,\r\n    1143: 5732504015546648477080676455520535,\r\n    1144: 5948929920644332374606657683899745,\r\n    1145: 6173429161603651508297858791951031,\r\n    1146: 6406299303007341112943259722223788,\r\n    1147: 6647848746214407376439536432805536,\r\n    1148: 6898397119316930779355317551024978,\r\n    1149: 7158275680962446691834888697663475,\r\n    1150: 7427827738529064471293660118664110,\r\n    1151: 7707409081157399483953096394984678,\r\n    1152: 7997388428160886234821473483000555,\r\n    1153: 8298147893354134143293856722998488,\r\n    1154: 8610083465857701451154337181278065,\r\n    1155: 8933605507957017621037375468973282,\r\n    1156: 9269139270613202791504126859283685,\r\n    1157: 9617125427244236129299819591578718,\r\n    1158: 9978020626416337178370164768812546,\r\n    1159: 10352298064107568778430054733760345,\r\n    1160: 10740448076228572334937735566562385,\r\n    1161: 11142978752109030998555590333304243,\r\n    1162: 11560416569682950887414131083801684,\r\n    1163: 11993307053131181401163436777097233,\r\n    1164: 12442215453765791987839842332792770,\r\n    1165: 12907727454968012800119940123354311,\r\n    1166: 13390449902019461518054086533162960,\r\n    1167: 13891011557695348536983250121102793,\r\n    1168: 14410063884518310798493113995825913,\r\n    1169: 14948281854602503175542820411276425,\r\n    1170: 15506364788049610799716682308517542,\r\n    1171: 16085037220891570656183958875514689,\r\n    1172: 16685049803609043819824168449851071,\r\n    1173: 17307180231290097851615771678718278,\r\n    1174: 17952234206530182283975172821446800,\r\n    1175: 18621046436212348314484589328413725,\r\n    1176: 19314481663345819649385158162679300,\r\n    1177: 20033435735181507108244024178275807,\r\n    1178: 20778836708864920831259413450679734,\r\n    1179: 21551645995930215818617016034137500,\r\n    1180: 22352859546983857840754489692613399,\r\n    1181: 23183509077972665661421886007454584,\r\n    1182: 24044663339478824029548767493555588,\r\n    1183: 24937429430533921473492651656959612,\r\n    1184: 25862954158495203059166455452470495,\r\n    1185: 26822425446580095904068198565803164,\r\n    1186: 27817073790709723558345700246365971,\r\n    1187: 28848173767368633057992125893483779,\r\n    1188: 29917045594246378653834785571179351,\r\n    1189: 31025056745487001593014803461929555,\r\n    1190: 32173623623434883211416744742294747,\r\n    1191: 33364213288829995905464566634140396,\r\n    1192: 34598345251472305106432161856883007,\r\n    1193: 35877593323444056632515580254383154,\r\n    1194: 37203587537049994338271609307035630,\r\n    1195: 38578016129709269105524749061283955,\r\n    1196: 40002627598109003613035027587346239,\r\n    1197: 41479232824008249429294178038617951,\r\n    1198: 43009707274162500911950054844789890,\r\n    1199: 44595993276923101114218051405894000,\r\n    1200: 46240102378152881298913555099661657,\r\n    1201: 47944117779189310556261099429006223,\r\n    1202: 49710196859679394486867802358932901,\r\n    1203: 51540573788206651013836802198036893,\r\n    1204: 53437562223729812777303406841914935,\r\n    1205: 55403558110955564979344325681437822,\r\n    1206: 57441042572873737644094937785113022,\r\n    1207: 59552584903793044889004529388335732,\r\n    1208: 61740845666328821093587961517238033,\r\n    1209: 64008579895911365238424857597692590,\r\n    1210: 66358640416504598253672231293216761,\r\n    1211: 68793981271349892486345394543503614,\r\n    1212: 71317661272679283934970057444157431,\r\n    1213: 73932847674475963853859804733408932,\r\n    1214: 76642819972498112301511348487927130,\r\n    1215: 79450973835924928534740056571220837,\r\n    1216: 82360825175131287067719845184002304,\r\n    1217: 85376014350249959857626768802856615,\r\n    1218: 88500310525337959944194241004565748,\r\n    1219: 91737616173126446538485123122674660,\r\n    1220: 95091971735501962459496140992085663,\r\n    1221: 98567560445040729668418191983592407,\r\n    1222: 102168713313097495533124764187939944,\r\n    1223: 105899914290136190948927875636615483,\r\n    1224: 109765805604181632042444034426405625,\r\n    1225: 113771193283469872120310539095739833,\r\n    1226: 117921052869579803514689801523449638,\r\n    1227: 122220535327540435729044764084697099,\r\n    1228: 126674973159627164610485151798391797,\r\n    1229: 131289886729786527240095013237443045,\r\n    1230: 136070990805862651658706033366694460,\r\n    1231: 141024201327040104811696041691045190,\r\n    1232: 146155642404167375009402954907061316,\r\n    1233: 151471653560883058451095421311451141,\r\n    1234: 156978797223733228787865722354959930,\r\n    1235: 162683866469743733376335192519362494,\r\n    1236: 168593893040195573779320686453020964,\r\n    1237: 174716155629645388794651866300906835,\r\n    1238: 181058188459536679140275000227478496,\r\n    1239: 187627790146061111217741961494883890,\r\n    1240: 194433032872253346998515292619988830,\r\n    1241: 201482271874637706375741021005730181,\r\n    1242: 208784155255090933098578892158986338,\r\n    1243: 216347634128942766400406396453655835,\r\n    1244: 224181973120705296790445342451587490,\r\n    1245: 232296761219203590802475861123264133,\r\n    1246: 240701923004274209788971782007579802,\r\n    1247: 249407730257605432130910077287592727,\r\n    1248: 258424813970713646981839124047488243,\r\n    1249: 267764176763484957967824140618533500,\r\n    1250: 277437205727159975794000686688315348,\r\n    1251: 287455685706103555386947650491244181,\r\n    1252: 297831813033180334721514504126791124,\r\n    1253: 308578209734051855476222280888835192,\r\n    1254: 319707938216222310789920115620477565,\r\n    1255: 331234516459188101998422700026723439,\r\n    1256: 343171933722591949005782567849433641,\r\n    1257: 355534666789845852070090701405470932,\r\n    1258: 368337696765269337188595637416276068,\r\n    1259: 381596526443390734228095202493032600,\r\n    1260: 395327198269680365975835178420652411,\r\n    1261: 409546312912626108164576640399383898,\r\n    1262: 424271048467724485839916892830607059,\r\n    1263: 439519180314644983035319377172158032,\r\n    1264: 455309101649532274915393819410766690,\r\n    1265: 471659844715141371979173526935980437,\r\n    1266: 488591102752254955447569352295355812,\r\n    1267: 506123252696611256922641286254645760,\r\n    1268: 524277378646375504218896129395592376,\r\n    1269: 543075296126019045035073055561928520,\r\n    1270: 562539577173328634024088141916141596,\r\n    1271: 582693576277154906994867051360796655,\r\n    1272: 603561457194424687753064451343608383,\r\n    1273: 625168220675887416175494833282535136,\r\n    1274: 647539733131042629585359752478706350,\r\n    1275: 670702756263704072335812679441391888,\r\n    1276: 694684977710697693392039019806832594,\r\n    1277: 719515042717266582828863521396088515,\r\n    1278: 745222586883866905899271646915240282,\r\n    1279: 771838270020186251303063741763018130,\r\n    1280: 799393811143400700904158178331205389,\r\n    1281: 827922024658910558926936487548336568,\r\n    1282: 857456857763058308684876665745077292,\r\n    1283: 888033429108637280324653641355847207,\r\n    1284: 919688068775347054572190680423598070,\r\n    1285: 952458359588743164917093657911776850,\r\n    1286: 986383179832665621554422059019604497,\r\n    1287: 1021502747401614623677846147487591813,\r\n    1288: 1057858665441074072255055670604124719,\r\n    1289: 1095493969525365696982675003469664810,\r\n    1290: 1134453176424250386882487822532585142,\r\n    1291: 1174782334511180318623311370757902964,\r\n    1292: 1216529075867847432892383159101984374,\r\n    1293: 1259742670141472479018316728428818781,\r\n    1294: 1304474080213136065603158197122179375,\r\n    1295: 1350776019737370796417180820702333527,\r\n    1296: 1398703012615213588677365804960180341,\r\n    1297: 1448311454464961662889458094993182194,\r\n    1298: 1499659676156986538068572255824972432,\r\n    1299: 1552808009481139790520320395733292300,\r\n    1300: 1607818855017534550841511230454411672,\r\n    1301: 1664756752283809987147800849591201736,\r\n    1302: 1723688452234384707674372422071320679,\r\n    1303: 1784682992189681523983975379146100758,\r\n    1304: 1847811773275862853601073393199008865,\r\n    1305: 1913148640458255774876416600453369682,\r\n    1306: 1980769965254371045106648307068906619,\r\n    1307: 2050754731215233987976941410834180457,\r\n    1308: 2123184622266649887649796215921782211,\r\n    1309: 2198144114005025303125952328225613580,\r\n    1310: 2275720568045462559712283145467243327,\r\n    1311: 2356004329523040680859896842728890474,\r\n    1312: 2439088827851495409213115816339495726,\r\n    1313: 2525070680846917026164254568053937634,\r\n    1314: 2614049802327600836872111661056230165,\r\n    1315: 2706129513304814950403979441635984290,\r\n    1316: 2801416656882996994241981980679918559,\r\n    1317: 2900021716991759392273170147031719072,\r\n    1318: 3002058941076075680836616507226015622,\r\n    1319: 3107646466875142011769945929778234485,\r\n    1320: 3216906453424662618200536823961141148,\r\n    1321: 3329965216421699826558324552595808770,\r\n    1322: 3446953368095762574438358199469775528,\r\n    1323: 3568005961734486838351757966808790919,\r\n    1324: 3693262641017091556254336031236632750,\r\n    1325: 3822867794313779335421691039194332368,\r\n    1326: 3956970714114397433384120384166003416,\r\n    1327: 4095725761754986283464866437718755283,\r\n    1328: 4239292537616325490949332681096528358,\r\n    1329: 4387836056974246172531213471126988170,\r\n    1330: 4541526931687319371792477450694975225,\r\n    1331: 4700541557913558825461268913956492487,\r\n    1332: 4865062310053998559115610911870100035,\r\n    1333: 5035277741127427794082646196764289585,\r\n    1334: 5211382789787193810929017395424321210,\r\n    1335: 5393578994197824268512706677957552625,\r\n    1336: 5582074712996280787878705083147454523,\r\n    1337: 5777085353569942323599828874448120571,\r\n    1338: 5978833607890937159258923653545207827,\r\n    1339: 6187549696154203668120613167259109435,\r\n    1340: 6403471618474669930531089742522848797,\r\n    1341: 6626845414907208756853259936695984136,\r\n    1342: 6857925434061555771629308454994509373,\r\n    1343: 7096974610593182332652154711768629954,\r\n    1344: 7344264751860200848154682253520601870,\r\n    1345: 7600076834045756410267481267000412856,\r\n    1346: 7864701308055034793828023244287340980,\r\n    1347: 8138438415506002236313232141990462682,\r\n    1348: 8421598515143296812402544776496284973,\r\n    1349: 8714502420015324706702901500511538625,\r\n    1350: 9017481745765587687202719206979752339,\r\n    1351: 9330879270400591290587334955958115107,\r\n    1352: 9655049305908367725798746534773552348,\r\n    1353: 9990358082113704664098849646925432237,\r\n    1354: 10337184143168612691406936474627379320,\r\n    1355: 10695918757089402353832391602114778863,\r\n    1356: 11066966338764988954966020552846311185,\r\n    1357: 11450744886874712432979257653673465667,\r\n    1358: 11847686435168064074325478460954986607,\r\n    1359: 12258237518573265193633495987026371935,\r\n    1360: 12682859654616659385819889316805008574,\r\n    1361: 13122029840650374087829702479479965035,\r\n    1362: 13576241067401694028191547060980833568,\r\n    1363: 14046002849374084164798517831067165046,\r\n    1364: 14531841772646818920248481411605550560,\r\n    1365: 15034302060637734370093170532411179780,\r\n    1366: 15553946158411737537905952886830918329,\r\n    1367: 16091355336136399592075372322853441977,\r\n    1368: 16647130312305245611392419213169232605,\r\n    1369: 17221891897369251284144496300865473815,\r\n    1370: 17816281658437585657529146257903261665,\r\n    1371: 18430962605729818628447970674590396131,\r\n    1372: 19066619901483662703451906966061889217,\r\n    1373: 19723961592044861669045607586672623550,\r\n    1374: 20403719363889095930868650315257219250,\r\n    1375: 21106649324349767740001100592550916016,\r\n    1376: 21833532807850282420908580590825862986,\r\n    1377: 22585177208464977793681819296712788065,\r\n    1378: 23362416839659197789401547387242312544,\r\n    1379: 24166113822086183031380235679888630795,\r\n    1380: 24997159000346486985219767235597236100,\r\n    1381: 25856472889644547994140059803514309099,\r\n    1382: 26745006653306882839626895694957692242,\r\n    1383: 27663743112157144914230446319916689190,\r\n    1384: 28613697786775039130057416743650633105,\r\n    1385: 29595919973698836617070193875375888205,\r\n    1386: 30611493856665016404478212802210021309,\r\n    1387: 31661539654013410832232951778996345076,\r\n    1388: 32747214803422179685312303680676279243,\r\n    1389: 33869715185174019207110095647396061120,\r\n    1390: 35030276385193261591559928994266853030,\r\n    1391: 36230174999132974647956742131787699078,\r\n    1392: 37470729978831867653000833781535492047,\r\n    1393: 38753304022502786601002774984625192104,\r\n    1394: 40079305010057880061198034072619085310,\r\n    1395: 41450187485020176719746625583516317963,\r\n    1396: 42867454184517379844972195257339462150,\r\n    1397: 44332657618901196005888853882051385939,\r\n    1398: 45847401702584520468158717245312104000,\r\n    1399: 47413343437739346154537960139775251600,\r\n    1400: 49032194652550394774839040691532998261,\r\n    1401: 50705723795773236966373450556265512689,\r\n    1402: 52435757789401123913939450130086135644,\r\n    1403: 54224183941301948277230817879517159495,\r\n    1404: 56072951919745741389655873424027752720,\r\n    1405: 57984075791803952210030966295696158116,\r\n    1406: 59959636127664498822125654803605200455,\r\n    1407: 62001782172971294457628166694777458740,\r\n    1408: 64112734091363688056165357762141754716,\r\n    1409: 66294785279460087023332346767177823090,\r\n    1410: 68550304756601011890673498202891728627,\r\n    1411: 70881739631740035679525259959146526016,\r\n    1412: 73291617649946553739726907624791770380,\r\n    1413: 75782549821062183481895201583751205263,\r\n    1414: 78357233133132880842076215608511229415,\r\n    1415: 81018453353321656721019131504035339537,\r\n    1416: 83769087919092159661630333467319344902,\r\n    1417: 86612108922541440552472192615179632742,\r\n    1418: 89550586190851013626818983550558814889,\r\n    1419: 92587690465918960312381724727166445110,\r\n    1420: 95726696686332376146505918443171660625,\r\n    1421: 98970987374939026118276437676742560264,\r\n    1422: 102324056135379743432459471263142178485,\r\n    1423: 105789511261048976512902596439531532566,\r\n    1424: 109371079460060057837671640558228717300,\r\n    1425: 113072609699904337559514844445146843472,\r\n    1426: 116898077175609399692092533607036637857,\r\n    1427: 120851587405321266865514819340648620862,\r\n    1428: 124937380457358912643772141796859437854,\r\n    1429: 129159835312916652764103424563956670300,\r\n    1430: 133523474368721196662101633251149823925,\r\n    1431: 138032968084085429989744342641002104875,\r\n    1432: 142693139776940493084095678732486636969,\r\n    1433: 147508970573571548730224671300676243591,\r\n    1434: 152485604516930928407097683383484266510,\r\n    1435: 157628353838555246722760639034336216136,\r\n    1436: 162942704399270720489853224525723269795,\r\n    1437: 168434321304033467550147269349447360294,\r\n    1438: 174109054696419141315515890296286539118,\r\n    1439: 179972945738449034728553750103340839325,\r\n    1440: 186032232781617921513478910563182232444,\r\n    1441: 192293357735172557401982780429019456969,\r\n    1442: 198762972637879108865432799270626669004,\r\n    1443: 205447946439712986100137659510287259781,\r\n    1444: 212355372000105810413242676805207816705,\r\n    1445: 219492573309591728816879034317080350983,\r\n    1446: 226867112941909191440813277312570747145,\r\n    1447: 234486799743834826784604048875528356971,\r\n    1448: 242359696770253388472695000770509170206,\r\n    1449: 250494129472202113601016657658116885375,\r\n    1450: 258898694145869442049569648660373941152,\r\n    1451: 267582266650777119653998333871688332247,\r\n    1452: 276554011405631474170238269248906446792,\r\n    1453: 285823390670594346502222808229127105074,\r\n    1454: 295400174124997022998049389765214784995,\r\n    1455: 305294448749801797154111873648107967492,\r\n    1456: 315516629024405747970164359073870491229,\r\n    1457: 326077467447680222173319384811207626600,\r\n    1458: 336988065393447621514574974879775699372,\r\n    1459: 348259884310914705271679879631949049780,\r\n    1460: 359904757280909011630794460361074410538,\r\n    1461: 371934900939102477916959218389244857418,\r\n    1462: 384362927777754206102413138268506970021,\r\n    1463: 397201858837862893052822862772992037235,\r\n    1464: 410465136803989050790556876831592919085,\r\n    1465: 424166639514388116438037562729473373486,\r\n    1466: 438320693899488240621648045435196959242,\r\n    1467: 452942090362151303283202948578566379295,\r\n    1468: 468046097613572904390385124958730619192,\r\n    1469: 483648477979107092056857426409232236010,\r\n    1470: 499765503188744811845488653259134061244,\r\n    1471: 516413970667431889729975411863080081224,\r\n    1472: 533611220340883210895592492267492392503,\r\n    1473: 551375151973035052959106187501778547015,\r\n    1474: 569724243051777714078869714336553502625,\r\n    1475: 588677567240126095472954965375170347997,\r\n    1476: 608254813410517219620274841577537789254,\r\n    1477: 628476305280471269092869681239382035111,\r\n    1478: 649363021668417110482089106581996800736,\r\n    1479: 670936617389064931646215631627734512060,\r\n    1480: 693219444808308092528746108408911793239,\r\n    1481: 716234576078254109447577888083725273959,\r\n    1482: 740005826073621415936329176309708825539,\r\n    1483: 764557776051394742131574284792974302805,\r\n    1484: 789915798056308219059157433980611758115,\r\n    1485: 816106080095422250986408555099636706156,\r\n    1486: 843155652105778433840074131252109568468,\r\n    1487: 871092412739856974449839116812405949463,\r\n    1488: 899945156994323847635597208986502059289,\r\n    1489: 929743604708340998940330812008055415670,\r\n    1490: 960518429958522963981451968247615571768,\r\n    1491: 992301291378458055449596203783102865285,\r\n    1492: 1025124863431572512298240504372933893698,\r\n    1493: 1059022868667002481099668362066093137208,\r\n    1494: 1094030110989052198741424671895432081910,\r\n    1495: 1130182509971758083662737515471154158801,\r\n    1496: 1167517136251048459523457118438435734632,\r\n    1497: 1206072248027988195015615498189010425646,\r\n    1498: 1245887328717627537181110407053143579875,\r\n    1499: 1287003125779035759903231323132670516000,\r\n    1500: 1329461690763193888825263136701886891117,\r\n    1501: 1373306420616547671126845059808771245199,\r\n    1502: 1418582100279183135137313919163744611210,\r\n    1503: 1465334946617783561814630036179107930696,\r\n    1504: 1513612653734759530017526259861629678205,\r\n    1505: 1563464439696213993716384678301014319431,\r\n    1506: 1614941094722713228367155822930278965324,\r\n    1507: 1668095030888183105149797247519563263487,\r\n    1508: 1722980333373639710221714255936544610213,\r\n    1509: 1779652813323895051112691937493275900640,\r\n    1510: 1838170062356853750560836014387165897751,\r\n    1511: 1898591508776536523215092101916644734126,\r\n    1512: 1960978475542532205781057345396110080746,\r\n    1513: 2025394240050193548750246784190116959083,\r\n    1514: 2091904095777554301862779830720186765825,\r\n    1515: 2160575415856657801620130127396601613839,\r\n    1516: 2231477718628751807313395954393627156678,\r\n    1517: 2304682735244622286166458817442330457493,\r\n    1518: 2380264479373211819043135033180865953593,\r\n    1519: 2458299319083597933290739975588639913960,\r\n    1520: 2538866050967394665741511337736337646822,\r\n    1521: 2622045976570688763353306228619701197220,\r\n    1522: 2707922981206731940550655607258234921458,\r\n    1523: 2796583615222784382740474040856321114152,\r\n    1524: 2888117177796744121961996863481080757250,\r\n    1525: 2982615803341503976179051696005120224577,\r\n    1526: 3080174550597354460133578989992600710402,\r\n    1527: 3180891494495199523837557418419727460583,\r\n    1528: 3284867820875874297854866890890114734440,\r\n    1529: 3392207924153452428300151849140308700620,\r\n    1530: 3503019508013107340706503153715459439135,\r\n    1531: 3617413689236849218690486699230663550120,\r\n    1532: 3735505104753300028632631618647052984126,\r\n    1533: 3857412022010595043668172932897782160438,\r\n    1534: 3983256452774513571402317362452698824910,\r\n    1535: 4113164270457046596687344259862579939532,\r\n    1536: 4247265331083807518632379721321456268679,\r\n    1537: 4385693598011986873811172464601561040968,\r\n    1538: 4528587270513945762405321738705440092603,\r\n    1539: 4676088916345038581429933773569294261235,\r\n    1540: 4828345608417856657751813260670405103571,\r\n    1541: 4985509065708793590462102906287902242693,\r\n    1542: 5147735798526653777473353718656776051935,\r\n    1543: 5315187258276961029029844229698454778001,\r\n    1544: 5488029991859677773715074283837789258005,\r\n    1545: 5666435800842220652541448314024017081118,\r\n    1546: 5850581905553958890153341953182905874297,\r\n    1547: 6040651114252811450773802339294340809537,\r\n    1548: 6236831997519121462431059121804263835744,\r\n    1549: 6439319068036685669987130768251283335700,\r\n    1550: 6648312965925656816271400679772663779731,\r\n    1551: 6864020649797022030147590897007762961557,\r\n    1552: 7086655593703494823378002063833638733692,\r\n    1553: 7316437990166946592699616833531354911573,\r\n    1554: 7553594959467950148686513765206276332400,\r\n    1555: 7798360765388617440490476800142578927168,\r\n    1556: 8050977037605691145961262617379106893607,\r\n    1557: 8311693000936800120986617647413681760089,\r\n    1558: 8580765711648916968128569908862807858077,\r\n    1559: 8858460301044367459544239649173485609090,\r\n    1560: 9145050226546241655095435675456471213374,\r\n    1561: 9440817530511750873400887128525102883050,\r\n    1562: 9746053107008968945969854946579275550253,\r\n    1563: 10061056976799496323982724378320247274070,\r\n    1564: 10386138570776897699583240005533846228720,\r\n    1565: 10721617022118294111300879958656795681727,\r\n    1566: 11067821467414245473548388055474400555521,\r\n    1567: 11425091357050045737330444087123696839842,\r\n    1568: 11793776775119777282986614097061549565288,\r\n    1569: 12174238769162940693809364157051309012420,\r\n    1570: 12566849690022197996332017608789608083314,\r\n    1571: 12971993542129749223451407990577313551957,\r\n    1572: 13390066344539111423681390555352209300441,\r\n    1573: 13821476503028593889295382128265725457026,\r\n    1574: 14266645193612571525140101316505187638875,\r\n    1575: 14726006757806758281011522810861817647486,\r\n    1576: 15200009110004083021400239371051767831673,\r\n    1577: 15689114157328479953978540694207577474781,\r\n    1578: 16193798232344933888778097136641377589301,\r\n    1579: 16714552539015476523707617004948193446275,\r\n    1580: 17251883612302523293667801378616630723938,\r\n    1581: 17806313791832981004049940595952236488989,\r\n    1582: 18378381710048954709565959117356034045626,\r\n    1583: 18968642795283648606471174187975250526914,\r\n    1584: 19577669790214200898277149916663590160135,\r\n    1585: 20206053286156727802917377116665528100452,\r\n    1586: 20854402273682788549513827814948445887987,\r\n    1587: 21523344710050833153156141436233019518750,\r\n    1588: 22213528103960970088758743797991090055558,\r\n    1589: 22925620118156604193077050587843661667620,\r\n    1590: 23660309190412159054931489112539937306848,\r\n    1591: 24418305173462226026373553546995875617627,\r\n    1592: 25200339994444087406536213435901662689794,\r\n    1593: 26007168334442658312725535116810982082161,\r\n    1594: 26839568328744494665699148030346372021260,\r\n    1595: 27698342288425638399643940633635778570228,\r\n    1596: 28584317443916730715736989648170031498488,\r\n    1597: 29498346711208035625096160181520548669694,\r\n    1598: 30441309481376795323275876211869020871017,\r\n    1599: 31414112434139702720919278494304352579875,\r\n    1600: 32417690376154241824102577250721959572183,\r\n    1601: 33453007104814231206634568834252067530087,\r\n    1602: 34521056298307127650200260789840693447039,\r\n    1603: 35622862432723524773564047600591620474611,\r\n    1604: 36759481727032834297334619181982868193810,\r\n    1605: 37932003116763385216396036596083684144149,\r\n    1606: 39141549257250138871243034824146893141432,\r\n    1607: 40389277557338916599575631087245664105779,\r\n    1608: 41676381244462492794128018619459154745923,\r\n    1609: 43004090462031141893576046232131339283625,\r\n    1610: 44373673400108265833414174147846823131033,\r\n    1611: 45786437460370592180018097454654125762209,\r\n    1612: 47243730456382146639125256475201485557926,\r\n    1613: 48746941850241791637271332996842921594539,\r\n    1614: 50297504026695610706485495279896144769485,\r\n    1615: 51896893605837832676324724372468638684687,\r\n    1616: 53546632795557357169752166455397628534844,\r\n    1617: 55248290784921291361962286829338022618145,\r\n    1618: 57003485179722265948521834701738678421349,\r\n    1619: 58813883481452695155464304054870553436360,\r\n    1620: 60681204611006611632952513664174735563434,\r\n    1621: 62607220478448273296879161314388228250413,\r\n    1622: 64593757600226437608809675150800761682315,\r\n    1623: 66642698765254062321100804776702438717922,\r\n    1624: 68755984751315254218264566880232672144875,\r\n    1625: 70935616093304583685847007991159666098679,\r\n    1626: 73183654904848448867540438473174344075670,\r\n    1627: 75502226754904045590148716826986516533057,\r\n    1628: 77893522600978716067675261669847531834806,\r\n    1629: 80359800780661049649804576562965921695475,\r\n    1630: 82903389063205132690374405132401276101050,\r\n    1631: 85526686762960833261150746165714536727005,\r\n    1632: 88232166916496002397533755182876654157205,\r\n    1633: 91022378525311020523414800627504843113662,\r\n    1634: 93899948866102260607570160618726171594330,\r\n    1635: 96867585870588824684642587049077568806146,\r\n    1636: 99928080576976385190854302771818195507418,\r\n    1637: 103084309655193176038845274579543287624753,\r\n    1638: 106339238008096180814672350296895542938848,\r\n    1639: 109695921450910408688484641855278054316360,\r\n    1640: 113157509471230885841519620824589853318260,\r\n    1641: 116727248071985676199747488789041121983568,\r\n    1642: 120408482699828936375465082551662467674163,\r\n    1643: 124204661261505763907840490901149694071182,\r\n    1644: 128119337230805474780434782661196752002675,\r\n    1645: 132156172848797007097973143732608413596901,\r\n    1646: 136318942420119455804633282594364118870621,\r\n    1647: 140611535708182363299559887896839185406573,\r\n    1648: 145037961432214389489427685180617331098024,\r\n    1649: 149602350869185430852497209043356597608875,\r\n    1650: 154308961563716222079735293780517268790662,\r\n    1651: 159162181149181008424137378091161149008138,\r\n    1652: 164166531283303096726173462843072095335410,\r\n    1653: 169326671701640055015539018518705699850330,\r\n    1654: 174647404392455113639317800019372440640580,\r\n    1655: 180133677896574006306024799468201257241780,\r\n    1656: 185790591735932160859341593488427864239206,\r\n    1657: 191623400974625892978847721669762887224010,\r\n    1658: 197637520916393159778610138707329017740693,\r\n    1659: 203838531942564585384018857484505756167480,\r\n    1660: 210232184494643970555920434333513855824223,\r\n    1661: 216824404205799439501151597527348613503086,\r\n    1662: 223621297185671858108005694276757667011704,\r\n    1663: 230629155463036280733315769829856728366831,\r\n    1664: 237854462590985052006674013310829555807395,\r\n    1665: 245303899419437913541037116166052239846061,\r\n    1666: 252984350039925153650180418719145316631826,\r\n    1667: 260902907907734605017003921684746498516403,\r\n    1668: 269066882146662257820916698151184555362272,\r\n    1669: 277483804041759534527674431707495428212025,\r\n    1670: 286161433725627991209904771339900788624872,\r\n    1671: 295107767063974496251592243518106809957385,\r\n    1672: 304331042746306921569506210339059205494747,\r\n    1673: 313839749587822198745641666552447374489321,\r\n    1674: 323642634048715381224461508374001874352425,\r\n    1675: 333748707977320256428395802157949938763484,\r\n    1676: 344167256583679214774724367914264615318981,\r\n    1677: 354907846650332656774577448740278805781989,\r\n    1678: 365980334987316359577499492665661423156220,\r\n    1679: 377394877138559089794329589034333523822720,\r\n    1680: 389161936347082504011271085636055422264324,\r\n    1681: 401292292786621190557291178310378056588836,\r\n    1682: 413797053067502749043669672231562125696658,\r\n    1683: 426687660024856256094871226711613620285845,\r\n    1684: 439975902797452509721828685778957458838000,\r\n    1685: 453673927205721269316833783775783610703320,\r\n    1686: 467794246437739506976775111608393022209053,\r\n    1687: 482349752052240657962887540925835136720740,\r\n    1688: 497353725307958208396664918548576500570384,\r\n    1689: 512819848828887897371554062220903289550130,\r\n    1690: 528762218615331555088826226879544901167527,\r\n    1691: 545195356410872371074704272735369048924689,\r\n    1692: 562134222435726415975597022642148002675881,\r\n    1693: 579594228497218762288102882601473336765100,\r\n    1694: 597591251488444805746508999799665944566660,\r\n    1695: 616141647286498628873307956507246249662412,\r\n    1696: 635262265061980727342758633558885467930686,\r\n    1697: 654970462011837401470060834112028353314761,\r\n    1698: 675284118527933869908522234215965152162520,\r\n    1699: 696221653814122968723573796976021441661750,\r\n    1700: 717802041964941442478681516751205185010007,\r\n    1701: 740044828519446608929091853958115568986164,\r\n    1702: 762970147504097887787893822256219849371554,\r\n    1703: 786598738978990637725956554797278124357808,\r\n    1704: 810951967102164263980984405643613443347625,\r\n    1705: 836051838727132970358751925465426223753244,\r\n    1706: 861921022549226171951777077723669881527186,\r\n    1707: 888582868816776806015468170319304987709289,\r\n    1708: 916061429623659935353293704664261165680563,\r\n    1709: 944381479800161498529884419450242134471605,\r\n    1710: 973568538419648201851756811932637866236071,\r\n    1711: 1003648890939014757529114525804772812444576,\r\n    1712: 1034649611991404349880377024889805948451966,\r\n    1713: 1066598588850232767185892564930056790115492,\r\n    1714: 1099524545584096492698787529446425808960485,\r\n    1715: 1133457067922710638072138797746330685194571,\r\n    1716: 1168426628854604371943988173648061076656356,\r\n    1717: 1204464614977899904017040550277724793430409,\r\n    1718: 1241603353626116601935133531509635427501801,\r\n    1719: 1279876140791574929056038110412443745546155,\r\n    1720: 1319317269869626093912245397158785002901753,\r\n    1721: 1359962061247603108750056330533001022811146,\r\n    1722: 1401846892763077891420050435782921418973709,\r\n    1723: 1445009231056717653171633051674494164837538,\r\n    1724: 1489487663845762650867366119648959070605125,\r\n    1725: 1535321933144897017630429081796659362863565,\r\n    1726: 1582552969462055408849028210050341395113316,\r\n    1727: 1631222926997501215103529967929557707274660,\r\n    1728: 1681375219875327721201833943152266777825092,\r\n    1729: 1733054559437372469717283290044275542482740,\r\n    1730: 1786306992630397874710969065930279993530728,\r\n    1731: 1841179941518278501517284167616876198477309,\r\n    1732: 1897722243951848075290887164802970670035779,\r\n    1733: 1955984195429997917538913727371549522655006,\r\n    1734: 2016017592186583869120124322228807307858970,\r\n    1735: 2077875775538691593667272042037771337062872,\r\n    1736: 2141613677532831241625032098057988491948517,\r\n    1737: 2207287867926682588244859017849269988676029,\r\n    1738: 2274956602545091757332316519809900057062533,\r\n    1739: 2344679873050131347512524469147852330603290,\r\n    1740: 2416519458166178053962910323080826683013954,\r\n    1741: 2490538976402136614754617183069000726495038,\r\n    1742: 2566803940314147020741857199436825485292885,\r\n    1743: 2645381812353354350387072647528700656565179,\r\n    1744: 2726342062344598291243970336667065409029860,\r\n    1745: 2809756226643193380147979076327264594704745,\r\n    1746: 2895697969018322254247325865029474629995508,\r\n    1747: 2984243143312953802987213049129995837626487,\r\n    1748: 3075469857931627124375487934417729522202013,\r\n    1749: 3169458542208911724615579730356050273697000,\r\n    1750: 3266292014712865596629588272103919719684547,\r\n    1751: 3366055553539366839888542445766361166135204,\r\n    1752: 3468836968654792543650918885868953010691040,\r\n    1753: 3574726676346161983924385238571158169261725,\r\n    1754: 3683817775839551051322373817401051497424420,\r\n    1755: 3796206128149322537872121900182662159228241,\r\n    1756: 3911990437222503807420937006192549828899684,\r\n    1757: 4031272333444480835500888704164496363681686,\r\n    1758: 4154156459574067047582172896269352052007031,\r\n    1759: 4280750559177948266124532321685590709003370,\r\n    1760: 4411165567636502893727652799725970383582718,\r\n    1761: 4545515705795050750500358651870382988186314,\r\n    1762: 4683918576336696329734155119529513589827658,\r\n    1763: 4826495262955104262123827190438060829061153,\r\n    1764: 4973370432407778155253526316242844344573385,\r\n    1765: 5124672439532710418254508515826522600609941,\r\n    1766: 5280533435313631955425559713040649796775465,\r\n    1767: 5441089478081518530016413892489308199319929,\r\n    1768: 5606480647942507023374562583725669127988521,\r\n    1769: 5776851164524941659873115036048663114937695,\r\n    1770: 5952349508140909502130662763236950728528684,\r\n    1771: 6133128544460338166089749412557583307068767,\r\n    1772: 6319345652798518839604562697210438023241550,\r\n    1773: 6511162858120786446819766577778364926946013,\r\n    1774: 6708746966871038378408979787060247103179750,\r\n    1775: 6912269706733805859936155115580770892194054,\r\n    1776: 7121907870442710074828422368434553047727682,\r\n    1777: 7337843463751340976339671250105665526337260,\r\n    1778: 7560263857685892761905455418833343917244062,\r\n    1779: 7789361945202278758472065509114228369126600,\r\n    1780: 8025336302373932563237571980294779250756300,\r\n    1781: 8268391354240084356595173268406241855198176,\r\n    1782: 8518737545447984082077112629884273268761094,\r\n    1783: 8776591515826329476185591848477738781761689,\r\n    1784: 9042176281031049610986292577509011838783245,\r\n    1785: 9315721418408596645489064435708989370524469,\r\n    1786: 9597463258226012911089716132158337004512929,\r\n    1787: 9887645080421270408475092400425112950304770,\r\n    1788: 10186517317031728481382143156507032880864866,\r\n    1789: 10494337760463026157910800552509870425432010,\r\n    1790: 10811371777765321805152346144711499265489879,\r\n    1791: 11137892531088517813516189325593809889812108,\r\n    1792: 11474181204492965595127263976240658672733891,\r\n    1793: 11820527237297139926370474832027317722017807,\r\n    1794: 12177228564148905369732416163985994571309670,\r\n    1795: 12544591862012275060173347722472359244046903,\r\n    1796: 12922932804266987528897386291108558284524280,\r\n    1797: 13312576322123804564848753689176255125112158,\r\n    1798: 13713856873564166596625513497299706749207160,\r\n    1799: 14127118720018736045636750699617456881311725,\r\n    1800: 14552716211005418005132948684850541312590849,\r\n    1801: 14991014076953676011289439394970540421861988,\r\n    1802: 15442387730448363289492676946827168544596921,\r\n    1803: 15907223576132871507960364168750022280398562,\r\n    1804: 16385919329518164710931105850817769087241385,\r\n    1805: 16878884344951220830025131180984215659580858,\r\n    1806: 17386539953003552219964871974446413826117272,\r\n    1807: 17909319807547825412134603270711842061393357,\r\n    1808: 18447670242798154252456532648116438246904907,\r\n    1809: 19002050640597405466197703977606842321053540,\r\n    1810: 19572933808242837304672225027800498209481360,\r\n    1811: 20160806367149596270203427106156960870472824,\r\n    1812: 20766169152660030143204019897118002904900168,\r\n    1813: 21389537625315443974415368124511782893607123,\r\n    1814: 22031442293915835855052489509763576677617505,\r\n    1815: 22692429150702307814484325155610270148732358,\r\n    1816: 23373060119006260978552660565770602425866730,\r\n    1817: 24073913513719160198707702330267411589158084,\r\n    1818: 24795584514946598972622146485353975132184526,\r\n    1819: 25538685655220618058549873928821959736691905,\r\n    1820: 26303847320654738379516399526912590943781620,\r\n    1821: 27091718266436968469332058999564180929593866,\r\n    1822: 27902966147067146894819024985472934375689121,\r\n    1823: 28738278061756389082181003004910619210874204,\r\n    1824: 29598361115418134291077518460315335403586750,\r\n    1825: 30483942995692340860959609721949330792795099,\r\n    1826: 31395772566456765282571775715588003409132613,\r\n    1827: 32334620478291992350263579043602637456626234,\r\n    1828: 33301279796379969106727880491661424703794769,\r\n    1829: 34296566646329244238310747147664839490574535,\r\n    1830: 35321320878433937019039707727760782467717785,\r\n    1831: 36376406750887666110543978036746824592455791,\r\n    1832: 37462713632488269058784695792011875893039111,\r\n    1833: 38581156725384149030225659607573893303383795,\r\n    1834: 39732677808428507338475836002967756141425565,\r\n    1835: 40918246001723570069537718918088365292496141,\r\n    1836: 42138858552953206373244111655326855421732185,\r\n    1837: 43395541646119076823784928057386091817027588,\r\n    1838: 44689351233312655065605577356497222364030752,\r\n    1839: 46021373890173147491957400810472661489846635,\r\n    1840: 47392727695699507038180086415408337440470086,\r\n    1841: 48804563137103411752378288723762455918172986,\r\n    1842: 50258064040409270440055764682612968116562013,\r\n    1843: 51754448527527040549257397842950059733038281,\r\n    1844: 53294970000543912137117431914902281880953875,\r\n    1845: 54880918154001741201408795026747551723720527,\r\n    1846: 56513620015948521242261975310131861303268895,\r\n    1847: 58194441018574179427502571579696887885537742,\r\n    1848: 59924786099263589386584792985885004002385100,\r\n    1849: 61706100832922923109471297093651456522575000,\r\n    1850: 63539872596459336786702846316806859551222764,\r\n    1851: 65427631766318517268030842666066129833124679,\r\n    1852: 67370952950009825188774721810114716943378422,\r\n    1853: 69371456252574676254257996014226320491002233,\r\n    1854: 71430808578980422724679205565325409535341535,\r\n    1855: 73550724973449352362958820460243849915161295,\r\n    1856: 75732969996760532083864127998517020593740791,\r\n    1857: 77979359142591108905489195759391328910134418,\r\n    1858: 80291760293993362744249170815935430293952943,\r\n    1859: 82672095221134305875868191384112819286758200,\r\n    1860: 85122341121455964860570648618210990142492639,\r\n    1861: 87644532203446685358824902714882088097498633,\r\n    1862: 90240761315246892123800470058435668367783935,\r\n    1863: 92913181619346739765141403639335218061558813,\r\n    1864: 95664008314668029507699782676107535163671365,\r\n    1865: 98495520407358668662814112828386043342039288,\r\n    1866: 101410062531664839123433827120996801871554118,\r\n    1867: 104410046822283945831589672011997862390810762,\r\n    1868: 107497954839640363519148716631132136446924023,\r\n    1869: 110676339549566018509524250906452596245408440,\r\n    1870: 113947827358908961175629034752466582068886470,\r\n    1871: 117315120208635333752283890034504840221064086,\r\n    1872: 120780997726033548383095326244127836720276225,\r\n    1873: 124348319437674093156601079636921240241787962,\r\n    1874: 128020027044824211921357710559027384266649000,\r\n    1875: 131799146763063790207250005304405120478900361,\r\n    1876: 135688791727897158862480183289001251910301886,\r\n    1877: 139692164468205234207238255169848532611147557,\r\n    1878: 143812559449433484718637448310794816419480218,\r\n    1879: 148053365688463686582704780998822076298210405,\r\n    1880: 152418069442171341962802939167993644252844977,\r\n    1881: 156910256971726023650131079907915129924767174,\r\n    1882: 161533617384748818044426030157299715901448409,\r\n    1883: 166291945557499506406187783344043042314534878,\r\n    1884: 171189145139326194380356742395417581059236130,\r\n    1885: 176229231641671815409487530302217850452007387,\r\n    1886: 181416335613995339496338175675291780004357523,\r\n    1887: 186754705909030660706666553292223320927706878,\r\n    1888: 192248713039873061921465120214608474899151280,\r\n    1889: 197902852631451912018290889751846175017276700,\r\n    1890: 203721748969018888548080806839085873409222663,\r\n    1891: 209710158646353589075380551065506324110555541,\r\n    1892: 215872974316462949034790068311792114803360768,\r\n    1893: 222215228547627476999327377660931337519227930,\r\n    1894: 228742097787726004875938672290676073251112495,\r\n    1895: 235458906439851487440117948662414751746035425,\r\n    1896: 242371131052313431017875037233367567350390976,\r\n    1897: 249484404626207844803286441041017222801266718,\r\n    1898: 256804521043823251651497040551112296246458295,\r\n    1899: 264337439621241331244215401011574782781334700,\r\n    1900: 272089289788583262011466359201428623427767364,\r\n    1901: 280066375901447845568248481717977121765830398,\r\n    1902: 288275182187185106927480861934498895209154826,\r\n    1903: 296722377829749335448869068867067104949579464,\r\n    1904: 305414822196978537321624475491324386207138350,\r\n    1905: 314359570214253084228181897886953506729950270,\r\n    1906: 323563877888595040544848710079341268243350278,\r\n    1907: 333035207987381310882223234930566921371066351,\r\n    1908: 342781235875958450915909855966319285240611144,\r\n    1909: 352809855518564809408156722848357746339640390,\r\n    1910: 363129185647086702371268910149149152584766993,\r\n    1911: 373747576102299648025575523786476989131026713,\r\n    1912: 384673614352373402423945044973430693054218643,\r\n    1913: 395916132193550721591800039752382776657876433,\r\n    1914: 407484212638044530444951338680763930621994820,\r\n    1915: 419387196994336597778328640988515637140928750,\r\n    1916: 431634692145202999016827948773519398239274548,\r\n    1917: 444236578028937695571550278721551746219224713,\r\n    1918: 457203015329395575643972370763403591173830810,\r\n    1919: 470544453380630393038248327984084169870052370,\r\n    1920: 484271638292061317700921219995285769876393805,\r\n    1921: 498395621300264386957594139661914904785275330,\r\n    1922: 512927767353652135411965358701027725220931707,\r\n    1923: 527879763936476202951968110645920036905758794,\r\n    1924: 543263630138763896173977941441058199308011100,\r\n    1925: 559091725978980633941148481298313317618632967,\r\n    1926: 575376761986396071222827176058084413124270202,\r\n    1927: 592131809050322598728023510231907577504041350,\r\n    1928: 609370308543590994569721078158344505753246979,\r\n    1929: 627106082727829397306582084065079630894972195,\r\n    1930: 645353345448318619933615779058934561872409372,\r\n    1931: 664126713126409278261223804893870154281524038,\r\n    1932: 683441216057704415059243252710086070145621992,\r\n    1933: 703312310024435417776917212697059694728111811,\r\n    1934: 723755888230689211116144545349876787252027480,\r\n    1935: 744788293569381118983800284897623329523811384,\r\n    1936: 766426331230110600455862693324715237997598939,\r\n    1937: 788687281657286442867926694461098498097562065,\r\n    1938: 811588913868164118077309502293768840003949925,\r\n    1939: 835149499140701056072067990291237777551833530,\r\n    1940: 859387825081405748983159033075649135425638325,\r\n    1941: 884323210083634058665255574996164926064666511,\r\n    1942: 909975518187071057883524303147934812769277935,\r\n    1943: 936365174349429389500998978473009079907862954,\r\n    1944: 963513180141695685953126594506747030515761180,\r\n    1945: 991441129878565264237073831290682236831192947,\r\n    1946: 1020171227196022316757683410004293870517496706,\r\n    1947: 1049726302088348378540247976304143049122065214,\r\n    1948: 1080129828417176195331669321286587690711167057,\r\n    1949: 1111405941905549479818145590739116367242780000,\r\n    1950: 1143579458630301665664240006110545368915059329,\r\n    1951: 1176675894026428898785508782184245465533665048,\r\n    1952: 1210721482417504396219216523662601652136179376,\r\n    1953: 1245743197086563215894590527223118960072913202,\r\n    1954: 1281768770902278683167516719540860443130307320,\r\n    1955: 1318826717515654486899160825985211020969456836,\r\n    1956: 1356946353142870071117550937780046987060960843,\r\n    1957: 1396157818950341697358512735475562356104045295,\r\n    1958: 1436492104058497734745724852296636956267964954,\r\n    1959: 1477981069181214654702422049514025480619599210,\r\n    1960: 1520657470918320177914639277247113472181645153,\r\n    1961: 1564554986719042364085227429425894281463674979,\r\n    1962: 1609708240534768479916261201915809290266567989,\r\n    1963: 1656152829179975566133060952832169077820577902,\r\n    1964: 1703925349420706097654088225457498186848567210,\r\n    1965: 1753063425810487348828764073209783931216955698,\r\n    1966: 1803605739294132404035202382553315081341190088,\r\n    1967: 1855592056600414568536728473961840601327835478,\r\n    1968: 1909063260445175620937659060948648856259756235,\r\n    1969: 1964061380567012302624155966071951926644451875,\r\n    1970: 2020629625618285067432170725261207144994992239,\r\n    1971: 2078812415934808833368620144510853807585221613,\r\n    1972: 2138655417208217715431844885515291279369574680,\r\n    1973: 2200205575085644913617857845505033592721522553,\r\n    1974: 2263511150722025533817142690940119270064496250,\r\n    1975: 2328621757311014594133664064174539456980750339,\r\n    1976: 2395588397621215290008835331658621643021314292,\r\n    1977: 2464463502565134245725579502592034085209328984,\r\n    1978: 2535300970829021467547395315846813198183591546,\r\n    1979: 2608156209592513548223075037746157905702847505,\r\n    1980: 2683086176367779880674969950590007819202341357,\r\n    1981: 2760149421988673761061033114268064448054050548,\r\n    1982: 2839406134781213852952373747778159055380262422,\r\n    1983: 2920918185947567114582770377976676661508796149,\r\n    1984: 3004749176196572544459946686955919368234128060,\r\n    1985: 3090964483654736576896042159262866214940589314,\r\n    1986: 3179631313092546273793802882159493889001969611,\r\n    1987: 3270818746501886244063493400323024051287288941,\r\n    1988: 3364597795061310125684361619251416376860936489,\r\n    1989: 3461041452526908153028282986522280729367368365,\r\n    1990: 3560224750087529486464584716859554522268776125,\r\n    1991: 3662224812724162303217742306542356590926722479,\r\n    1992: 3767120917114346857096063738777247515406335526,\r\n    1993: 3874994551123597548057533501867770741416429535,\r\n    1994: 3985929474926940257994009093217001343955328335,\r\n    1995: 4100011783804831583821441379839563991285227198,\r\n    1996: 4217329972658917930562969936711305445974785514,\r\n    1997: 4337975002294315534109569503386742455494341143,\r\n    1998: 4462040367516348205694592687945941817364967127,\r\n    1999: 4589622167090968789784046573687400867942870250,\r\n    2000: 4720819175619413888601432406799959512200344166,\r\n    2001: 4855732917379000237574365609687488912697273143,\r\n    2002: 4994467742183366148074839035447416380393781644,\r\n    2003: 5137130903316893622770745464235084139384928426,\r\n    2004: 5283832637599517075572081746564260420858901705,\r\n    2005: 5434686247639634059061258993904042430607990074,\r\n    2006: 5589808186334383050291570992756471405633041387,\r\n    2007: 5749318143678144230778676663789672984169195116,\r\n    2008: 5913339135941752405965378691599572441324623941,\r\n    2009: 6081997597286587859405678030809218670282246785,\r\n    2010: 6255423473879432172551153347179787953125682826,\r\n    2011: 6433750320575743037411316728215679204642749660,\r\n    2012: 6617115400240816052275556661314890288999332009,\r\n    2013: 6805659785780163657391920602286596663406217911,\r\n    2014: 6999528464952353007567067145415164276505069670,\r\n    2015: 7198870448039506994791503590601126801607534137,\r\n    2016: 7403838878452687162912842119176262318542314409,\r\n    2017: 7614591146351445269661694564912786246445478891,\r\n    2018: 7831289005358953156344654888013498638339711692,\r\n    2019: 8054098692456299826324570548607480763080403880,\r\n    2020: 8283191051141781691732068101840743191755759916,\r\n    2021: 8518741657943308344041302580996941768179250799,\r\n    2022: 8760930952374403498169602637389577451855415964,\r\n    2023: 9009944370426700552244228695797096011740585251,\r\n    2024: 9265972481694316138437595284729122693073711400,\r\n    2025: 9529211130228034799395854632912272457677896880,\r\n    2026: 9799861579219855238744997642818047729388291567,\r\n    2027: 10078130659621135236933601810787303619515113811,\r\n    2028: 10364230922800330115415428619787879783434758914,\r\n    2029: 10658380797349150440403847607713189208549844510,\r\n    2030: 10960804750148870398245267228037581609577682339,\r\n    2031: 11271733451811500913798689538973402825112404379,\r\n    2032: 11591403946613603138135282386492611425148475178,\r\n    2033: 11920059827043660471886625110700606109457615243,\r\n    2034: 12257951413087152938966999455842406831025654415,\r\n    2035: 12605335936376788660643906067688568691477294599,\r\n    2036: 12962477729338745637101954446070534143126297085,\r\n    2037: 13329648419469265315863347103932314055721954884,\r\n    2038: 13707127128879519866370496154104287110788727040,\r\n    2039: 14095200679250350101462435045670967566714006190,\r\n    2040: 14494163802342243065803242497250145705564482929,\r\n    2041: 14904319356209789989230727462504226498494263931,\r\n    2042: 15325978547273839186092526952960232758544597811,\r\n    2043: 15759461158408637244144834830819680263402565217,\r\n    2044: 16205095783205438232082764786847977319531548455,\r\n    2045: 16663220066578357477963673318612506891057322162,\r\n    2046: 17134180951882656619355889974597586372298980947,\r\n    2047: 17618334934720173062514849536736413843694654543,\r\n    2048: 18116048323611252751541173214616030020513022685,\r\n    2049: 18627697507717313357328883548487129542980353125,\r\n    2050: 19153669231803058848943059805108758933859747374,\r\n    2051: 19694360878632389188479682121479772827588278091,\r\n    2052: 20250180758997203961018562965051517467373563574,\r\n    2053: 20821548409583589567679943310731809893410960813,\r\n    2054: 21408894898885309715106534167513145969112337635,\r\n    2055: 22012663141380091963647773040348591535494857021,\r\n    2056: 22633308220189922777870335143856096247251187948,\r\n    2057: 23271297718452433681930253947266040250043569734,\r\n    2058: 23927112059636485682887466272819725468557276242,\r\n    2059: 24601244857041242112722641487525252331485884885,\r\n    2060: 25294203272724365584159904646608138971697036406,\r\n    2061: 26006508386111487092631615069752229687889047419,\r\n    2062: 26738695572545778772495897103306702147812265676,\r\n    2063: 27491314892043320887814631666080168776331811888,\r\n    2064: 28264931488526992879603605279805458570836160570,\r\n    2065: 29060125999818842393508123538658855855869573724,\r\n    2066: 29877494978678299986437859187588252356283557915,\r\n    2067: 30717651325181215594079225685922159612710890246,\r\n    2068: 31581224730742500897001026737587458361246031363,\r\n    2069: 32468862134093174645484430948409904593113694670,\r\n    2070: 33381228189530831120385246576357623531476650368,\r\n    2071: 34319005747770990684777087747947525376490393829,\r\n    2072: 35282896349735451425203004555804514075824949148,\r\n    2073: 36273620733622647942922713748119798292462316154,\r\n    2074: 37291919355614143333586997222803939193763027250,\r\n    2075: 38338552924580739339245889549713324449360541521,\r\n    2076: 39414302951161293776274047281093717842584188891,\r\n    2077: 40519972311597190003244878215733219997449415843,\r\n    2078: 41656385826715516924455731088372893657996361228,\r\n    2079: 42824390856464396526209228476474575762774879465,\r\n    2080: 44024857910414546084950481401735302373848095782,\r\n    2081: 45258681274652091016547586287700221970008068755,\r\n    2082: 46526779655498859083237494859206365034702358134,\r\n    2083: 47830096840507894753763929606166424148960110424,\r\n    2084: 49169602377193741528342591922356853935149504975,\r\n    2085: 50546292269969157794099110029993948769746687671,\r\n    2086: 51961189695772366269783089381199090558960547606,\r\n    2087: 53415345738881696537662435419712492307334180478,\r\n    2088: 54909840145427572963129830596638040418770704515,\r\n    2089: 56445782098125235102442269204682620745124030885,\r\n    2090: 58024311011765363351557172881384457469348901699,\r\n    2091: 59646597350013928176910703744766844433767270677,\r\n    2092: 61313843464087096107973721257849778294625405081,\r\n    2093: 63027284453881919316292784641070835053831354052,\r\n    2094: 64788189052158817856342546799691255570877518150,\r\n    2095: 66597860532387544551063529093372826237515675728,\r\n    2096: 68457637640884412378329010378860869685804024262,\r\n    2097: 70368895553885073626926030071097479233359907864,\r\n    2098: 72333046860214079886074787715712944920415424984,\r\n    2099: 74351542570229833233029956235268391407949627875,\r\n    2100: 76425873151741373195807749021080021459080291165,\r\n    2101: 78557569593611742891613633197716231871513782517,\r\n    2102: 80748204497781453174729297053600127492388932998,\r\n    2103: 82999393200464827976246067679320326020971457938,\r\n    2104: 85312794923291779902869927934730036659721510375,\r\n    2105: 87690113955187845526792666366851401712801134274,\r\n    2106: 90133100865806117918203480753613859038381596324,\r\n    2107: 92643553751346063460833585063932351673594098859,\r\n    2108: 95223319513616114811576859302283546424619314506,\r\n    2109: 97874295173219406337291510865301717288885200445,\r\n    2110: 100598429217765077170980775830078597915978709260,\r\n    2111: 103397722986031225236603653787203378188231402292,\r\n    2112: 106274232089029868642533106912359104776603150690,\r\n    2113: 109230067868949174578477633685673008965957469120,\r\n    2114: 112267398896973766514395710229044460157179222920,\r\n    2115: 115388452511010134752244464747991318862444784689,\r\n    2116: 118595516394371070307305070689995677519803374830,\r\n    2117: 121890940196500635216372474879596908517840948778,\r\n    2118: 125277137196849491653446187682001921308870438795,\r\n    2119: 128756586013039456106279781429309224204637155235,\r\n    2120: 132331832354485942225817194731144948296095338913,\r\n    2121: 136005490822677526183628341619662696228169437779,\r\n    2122: 139780246759343231332496879136294914183920566235,\r\n    2123: 143658858143770305041408732118198629930850140819,\r\n    2124: 147644157540568270666807354340091712330909224000,\r\n    2125: 151739054099208903158067016467162544501125246216,\r\n    2126: 155946535606706519753573960842521384418556790909,\r\n    2127: 160269670594838620141199867367375227901178121673,\r\n    2128: 164711610503343476443764262455655533446463188624,\r\n    2129: 169275591900568786145109713871008667212574145360,\r\n    2130: 173964938763083984897646967444489323060065487907,\r\n    2131: 178783064815808295968062329270497666350416021621,\r\n    2132: 183733475934247094438727208707795835845879643176,\r\n    2133: 188819772610470713392617031395550078686410106988,\r\n    2134: 194045652484512443040038057363040342445733893240,\r\n    2135: 199414912942906199650168544999618866932966543484,\r\n    2136: 204931453786129197483756438132982529754356479553,\r\n    2137: 210599279966760972657750340621024569609658319243,\r\n    2138: 216422504400217312716806872498425178952708753752,\r\n    2139: 222405350849966070103844047835296998593257719870,\r\n    2140: 228552156889181512949138540918848061266047740791,\r\n    2141: 234867376940844824665120188180587152072518199582,\r\n    2142: 241355585398350637585388084310633650150819331465,\r\n    2143: 248021479828733108998565670865001643954560554353,\r\n    2144: 254869884260680054932039940494913967190530868955,\r\n    2145: 261905752559560083345100350260758248905652921875,\r\n    2146: 269134171891745550301357546978902318483150550307,\r\n    2147: 276560366280573537433149830945908221546675684073,\r\n    2148: 284189700256347954756384460822072399114186994724,\r\n    2149: 292027682602848348780952829894171946286185196525,\r\n    2150: 300079970202875082019467410865495625479979094694,\r\n    2151: 308352371985426287572392634796034918345831989966,\r\n    2152: 316850852977169433649870812195036854291507911207,\r\n    2153: 325581538460939500937426146405250734530774231825,\r\n    2154: 334550718244066724977417207615678241114465752975,\r\n    2155: 343764851039409631696645200323540686552303329604,\r\n    2156: 353230568962043743490045985418104968175497835998,\r\n    2157: 362954682144632903677995273534058279957414924705,\r\n    2158: 372944183474588707707117294510467908715140736065,\r\n    2159: 383206253456204090418195791785818308423831594945,\r\n    2160: 393748265201029751587449904786884268416346918520,\r\n    2161: 404577789549846859589538794509144411672022826612,\r\n    2162: 415702600329676409598230534926593885982499170401,\r\n    2163: 427130679749354783768755297437892949499654467597,\r\n    2164: 438870223937296523272831771890659665602286473475,\r\n    2165: 450929648625159134260052749493609306300370136632,\r\n    2166: 463317594981220971649101966934064855005088490212,\r\n    2167: 476042935597381937471938911243959272191670950572,\r\n    2168: 489114780633797957215706040263930987465371910798,\r\n    2169: 502542484125264022730810437527574105649622691760,\r\n    2170: 516335650453567079927347553251246871212620557984,\r\n    2171: 530504140990139261462232960508189648909724886170,\r\n    2172: 545058080913453988432836606455557467047353067377,\r\n    2173: 560007866205722361999363584087410496745060913524,\r\n    2174: 575364170833565108914383039346175332072363129225,\r\n    2175: 591137954117456209042263051672264094963902965317,\r\n    2176: 607340468294858294890172396576637459876728673686,\r\n    2177: 623983266282097051667127111749751355541610352255,\r\n    2178: 641078209640152242143041148426227499209194350336,\r\n    2179: 658637476749676716333547258428298949880301221655,\r\n    2180: 676673571200691926609848235322274189175428592431,\r\n    2181: 695199330402549141183113024435698489390907024630,\r\n    2182: 714227934419889822186067591088150189762713935508,\r\n    2183: 733772915040486600160233205517764582904605949651,\r\n    2184: 753848165080998028345195047409661205734061410010,\r\n    2185: 774467947936825933802831039011913166290856798904,\r\n    2186: 795646907382423796556925927113569848920749045025,\r\n    2187: 817400077628568283525440629036885986580578161120,\r\n    2188: 839742893643273944545131128461036809985928936965,\r\n    2189: 862691201743203249313515607587263855592485446510,\r\n    2190: 886261270462600715344592984957682094231262687955,\r\n    2191: 910469801706960959527768615813845716032362752763,\r\n    2192: 935333942198826213870111109341848015258586306792,\r\n    2193: 960871295223299296636466125655717340185883228697,\r\n    2194: 987099932681053343467853379878084516482176109430,\r\n    2195: 1014038407456819902258601282188003020164821077713,\r\n    2196: 1041705766111542406799393149921058024912789843193,\r\n    2197: 1070121561906592696806185003711836723976318646033,\r\n    2198: 1099305868168664278558814578725663660095230751347,\r\n    2199: 1129279292004177556899411779284367814322107068750,\r\n    2200: 1160062988372259455129906418328374912794875140516,\r\n    2201: 1191678674525592817234330378465180518007035567938,\r\n    2202: 1224148644828669903250292851179037002332204681842,\r\n    2203: 1257495785963229293609758350537517985043490101070,\r\n    2204: 1291743592530906765707814604565428064732892610835,\r\n    2205: 1326916183063388353539586696826007823016666575690,\r\n    2206: 1363038316450618010620081932775702626766948267742,\r\n    2207: 1400135408797883233268006240578157606704308520406,\r\n    2208: 1438233550722879835539717164127729784341377881813,\r\n    2209: 1477359525104141972742451850876428128946776467300,\r\n    2210: 1517540825292515665993072463432902551892845533240,\r\n    2211: 1558805673797653668641491334803497135876242089678,\r\n    2212: 1601183041461816724044580259727354612842328867083,\r\n    2213: 1644702667133581285344348736857245137869671730074,\r\n    2214: 1689395077854376798567156661483099222514277324220,\r\n    2215: 1735291609571106892437555774714449031725527460139,\r\n    2216: 1782424428388448478757191595009703327418571383436,\r\n    2217: 1830826552374771058174587388568897962322872702465,\r\n    2218: 1880531873935975665104704330318867749822093808655,\r\n    2219: 1931575182771919095318938056959674511017686068185,\r\n    2220: 1983992189430464568754141912398798172706580941262,\r\n    2221: 2037819549474585022525115674537508812727151594151,\r\n    2222: 2093094888278340044956073813211683523416074682898,\r\n    2223: 2149856826467952296650447653773869417501164619869,\r\n    2224: 2208145006024624371311040214176565237134381870625,\r\n    2225: 2268000117066162685610486257867691977952149636083,\r\n    2226: 2329463925324911418747662088887963091854286975547,\r\n    2227: 2392579300339947019867081675868949317697298397221,\r\n    2228: 2457390244381942643492189138307718097264928854677,\r\n    2229: 2523941922129582344692758164350149756471869195790,\r\n    2230: 2592280691116887259141942758496845583141659899537,\r\n    2231: 2662454132971310608073787558386111506684369385813,\r\n    2232: 2734511085462965511444391934177140596906494183587,\r\n    2233: 2808501675385869578994261445169376899379754972068,\r\n    2234: 2884477352292623400907075579322579400861330771315,\r\n    2235: 2962490923104486707892612022451087039141493329190,\r\n    2236: 3042596587619376453548710860694923114675620792521,\r\n    2237: 3124849974940885736970186673957557524827120772983,\r\n    2238: 3209308180852011686602310843936272621314792055526,\r\n    2239: 3296029806157884531966398832249411659082252110525,\r\n    2240: 3385074996022409471869790373849802994298808805690,\r\n    2241: 3476505480324367989101580130555189921672623462046,\r\n    2242: 3570384615059176354982401320439389024740905215964,\r\n    2243: 3666777424813166614813801947045518673161561892966,\r\n    2244: 3765750646337939759592154130429553527537766985115,\r\n    2245: 3867372773253042492891322334008521298830352179629,\r\n    2246: 3971714101905938427653556222571377434088646307540,\r\n    2247: 4078846778418982139592272233327190495676444439866,\r\n    2248: 4188844846953860716858469962505733762730156946697,\r\n    2249: 4301784299224742745702713528067084946594634381000,\r\n    2250: 4417743125292169536796493320206228992803910550343,\r\n    2251: 4536801365670538316236136117174461033288094273661,\r\n    2252: 4659041164782862580763013973003868359053553220232,\r\n    2253: 4784546825797351362566231731168417844332785838733,\r\n    2254: 4913404866881227292111965728061869527659853830530,\r\n    2255: 5045704078908103627757617096847635981526636026359,\r\n    2256: 5181535584656163391837451036356625290841516214407,\r\n    2257: 5320992899535329981545125277691916180855473998805,\r\n    2258: 5464171993882588690437588095807084889323827738187,\r\n    2259: 5611171356865613078294130300389571289206397311350,\r\n    2260: 5762092062035869673687412904560243239930531635515,\r\n    2261: 5917037834573419710379575999541430738890622626340,\r\n    2262: 6076115120266708126452900640242923623341866228338,\r\n    2263: 6239433156271728550695355451490575993085942292134,\r\n    2264: 6407104043696079137218319509378718229702705761905,\r\n    2265: 6579242822054578576274630855578948789533455298734,\r\n    2266: 6755967545644295113522674510292835122483775946206,\r\n    2267: 6937399361888054675782970897485983723264323011797,\r\n    2268: 7123662591696737970806754341094737575112103730614,\r\n    2269: 7314884811901951462222340761939935289641834289395,\r\n    2270: 7511196939811964197947649707463044206175866380723,\r\n    2271: 7712733319945142389521924617582058172801542180874,\r\n    2272: 7919631812996487219317452100595913257543028088576,\r\n    2273: 8132033887094289430962576814720449927838393960827,\r\n    2274: 8350084711405357694774361105408889911972402015300,\r\n    2275: 8573933252148757415018198504928925593185861873742,\r\n    2276: 8803732371079513461579268567498022304249933730391,\r\n    2277: 9039638926505285189617314422998964084970595438542,\r\n    2278: 9281813876900616004271298745383250743059729594527,\r\n    2279: 9530422387184993604151073155371828079705355168950,\r\n    2280: 9785633937732631891816046069641124632254214557235,\r\n    2281: 10047622436183602390848394841406802515973193043806,\r\n    2282: 10316566332127702901769041143039403233989122380996,\r\n    2283: 10592648734734255132957468343310308444321456043571,\r\n    2284: 10876057533402872254341014560334244700946683620780,\r\n    2285: 11166985521512132864360358955503173717957792328653,\r\n    2286: 11465630523345040885726361109312137419668093929920,\r\n    2287: 11772195524272142592252579142228927699835475405262,\r\n    2288: 12086888804275213526126666074714236379441857513978,\r\n    2289: 12409924074896520730686758323108856061617655222490,\r\n    2290: 12741520619700810766902679602920740106349316265795,\r\n    2291: 13081903438339372702369995825105861818651826992639,\r\n    2292: 13431303394307778991751050067148151893379620506077,\r\n    2293: 13789957366491217272065156663906255405414311071587,\r\n    2294: 14158108404593693973445004415760318309772932242370,\r\n    2295: 14536005888549817728742960090051403934327801222156,\r\n    2296: 14923905692020358321733692442892587286459907678047,\r\n    2297: 15322070350075326847761463298913968554265401515217,\r\n    2298: 15730769231170936413643835624649288938501733002618,\r\n    2299: 16150278713529481654471379166675899361510665760775,\r\n    2300: 16580882366033921211442301450921091904365926280416,\r\n    2301: 17022871133751761754598643267756804218108498650480,\r\n    2302: 17476543528205726845562009156571175360531579106807,\r\n    2303: 17942205822511650658087298129211531345495818175057,\r\n    2304: 18420172251507067091174412069974707159021665744880,\r\n    2305: 18910765216997070947078996545777114475682919623589,\r\n    2306: 19414315498247211476154846356983916621521411447697,\r\n    2307: 19931162467856441629277246980513463599759674413041,\r\n    2308: 20461654313146490770914182133145338856645809727187,\r\n    2309: 21006148263207456404192932627622104852595304280970,\r\n    2310: 21565010821742923705373368869534441911701199887419,\r\n    2311: 22138618005861522471365237940368652982888104075000,\r\n    2312: 22727355590965521614482418924663783733921186781149,\r\n    2313: 23331619361890843810727406215610806254135308857160,\r\n    2314: 23951815370456759593096244705083096637451017834880,\r\n    2315: 24588360199587493406897494649744406335205727290057,\r\n    2316: 25241681234172046294108468111219387029991510514102,\r\n    2317: 25912216938832713390963025920891990759428674050912,\r\n    2318: 26600417142777051809706408361950504454660772072685,\r\n    2319: 27306743331912438295458811467722364839525869129400,\r\n    2320: 28031668948406848928849481174161195141360108410956,\r\n    2321: 28775679697884097775242882020060349688803476984805,\r\n    2322: 29539273864446490518541231137563989837057604952179,\r\n    2323: 30322962633722685585711432023667002655631855893969,\r\n    2324: 31127270424143511960418282768032077800615961592375,\r\n    2325: 31952735226653572764265207581869821725011637243487,\r\n    2326: 32799908953071669788426324706615644528794262188810,\r\n    2327: 33669357793318419597396187557448074241909961160527,\r\n    2328: 34561662581734899786701292837993789078148269659948,\r\n    2329: 35477419172721767722086620675579581559062365395875,\r\n    2330: 36417238825934036963035091771377814636876895938849,\r\n    2331: 37381748601272582004301821355152191840543933044480,\r\n    2332: 38371591763919473464910961559285225914454949449279,\r\n    2333: 39387428199670427009917909560877277324279071654230,\r\n    2334: 40429934840823983789090419362572880622618841036000,\r\n    2335: 41499806102893531791299424581039874366426784160676,\r\n    2336: 42597754332414930108684698464207986438238414531147,\r\n    2337: 43724510266129315639709919648795164529190983190550,\r\n    2338: 44880823501827658290753362113015735891775860228025,\r\n    2339: 46067462981150790416506320013365490407603364278280,\r\n    2340: 47285217484645973326080769865489605746387338228688,\r\n    2341: 48534896139388582534016509015707084448606794509814,\r\n    2342: 49817328939485198519236927086579980055136752412153,\r\n    2343: 51133367279782285645165745517535680609133370052296,\r\n    2344: 52483884503112733276871946748564813602003527319855,\r\n    2345: 53869776461420824806590383880147822175719204551469,\r\n    2346: 55291962091114697184508819760614991511857392669436,\r\n    2347: 56751384003004060684283391440819878903446789803099,\r\n    2348: 58249009087189871171927544609837628960380623034142,\r\n    2349: 59785829133281790377677305788784327434428364970750,\r\n    2350: 61362861466328639006942053695686748622617850877171,\r\n    2351: 62981149598856648513992946515066172932792511110884,\r\n    2352: 64641763899420155681002068750650481144652897951882,\r\n    2353: 66345802278079465613952539750862814246981008871159,\r\n    2354: 68094390889230939345801166300675543634997580023495,\r\n    2355: 69888684852224948030989898005576415781403878920995,\r\n    2356: 71729868990218182977254525351745038902483193889528,\r\n    2357: 73619158587717925895914811729724245783180985354842,\r\n    2358: 75557800167287273321320320811040130784252221919060,\r\n    2359: 77547072285891979874115998945868567670402747044445,\r\n    2360: 79588286351381543804941144999617740627898062871643,\r\n    2361: 81682787459609412105690788920445375282931841060492,\r\n    2362: 83831955252709738636327407566454519669269037443061,\r\n    2363: 86037204799060994583504133500298291142599767525961,\r\n    2364: 88299987495479913719532319572840702828357104994815,\r\n    2365: 90621791992202763126914659986946872015595738278003,\r\n    2366: 93004145141224771243446359569837640488487305606833,\r\n    2367: 95448612968582727407224954007027627693270062216153,\r\n    2368: 97956801671180298878693599735216669857785613237715,\r\n    2369: 100530358638770501129135789786132580428696541463525,\r\n    2370: 103170973501725013759939661850158896906366983382795,\r\n    2371: 105880379205235666714568162057607929186246674835477,\r\n    2372: 108660353110609438642727243903401536959027659486124,\r\n    2373: 111512718124334720773264584058717478384571245088082,\r\n    2374: 114439343855613415076071522953096149591716910973500,\r\n    2375: 117442147803070664704054798350668120890654926300513,\r\n    2376: 120523096571371667803183996442776155815729810091602,\r\n    2377: 123684207118493113105268436573489685721321552781151,\r\n    2378: 126927548034415307868377394917913546501247383867613,\r\n    2379: 130255240852020056553944404306572055559539047530145,\r\n    2380: 133669461390998803240347188535274022509125836065110,\r\n    2381: 137172441135595483551688849972013947996581871778170,\r\n    2382: 140766468647028954484433593096055372616292751308832,\r\n    2383: 144453891011460794882135190497537058556764977948995,\r\n    2384: 148237115324395707667015292482470242745754168289775,\r\n    2385: 152118610212423719809411357105042520067307779240520,\r\n    2386: 156100907393235880227548485941067592747534460439448,\r\n    2387: 160186603274868212495995174730244824826286924759060,\r\n    2388: 164378360595152301854136694694118079266206458932708,\r\n    2389: 168678910102375098323537690529566365095195830119715,\r\n    2390: 173091052278175313875346442702502205694341724313429,\r\n    2391: 177617659103729195986746184184236646145304254737028,\r\n    2392: 182261675870304487388520687355584130250935690880972,\r\n    2393: 187026123035288047490867195922886699634867141186408,\r\n    2394: 191914098124819930404162679326110679178204492902970,\r\n    2395: 196928777684194703542432119373410255613845416290627,\r\n    2396: 202073419277219465790162920942761564437025278844409,\r\n    2397: 207351363535747401800832745531222095970123079470866,\r\n    2398: 212766036260635806253027202800291886071043511130893,\r\n    2399: 218320950575408346303872686615815518603736687265550,\r\n    2400: 224019709133932919957689061390552862746031758458304,\r\n    2401: 229866006383458830949778967121025947053151071434926,\r\n    2402: 235863630884390155812442175854014517889393984836232,\r\n    2403: 242016467688206145276344061824939391497289921344319,\r\n    2404: 248328500774974299762177021852107412058234599633660,\r\n    2405: 254803815551937407606287486346848530864431251682411,\r\n    2406: 261446601414692355496335282873363983668020889836360,\r\n    2407: 268261154372515934523018586706764224652758295238166,\r\n    2408: 275251879739431193944393927980843975448015734231456,\r\n    2409: 282423294892647160394499527988292633580813431968720,\r\n    2410: 289780032100044965565638185282633831588088504297253,\r\n    2411: 297326841418424633617945474627449518623223932967198,\r\n    2412: 305068593664268994544312629723329236676843814611957,\r\n    2413: 313010283458824435839645487672681448751536128120719,\r\n    2414: 321157032349342507073515697424466804962980378707300,\r\n    2415: 329514092008371775927573078641257544141430283832310,\r\n    2416: 338086847513035826131406156272669425469096435441169,\r\n    2417: 346880820706280914339971199061511110032851886967137,\r\n    2418: 355901673642125591813707043622534952223283339280101,\r\n    2419: 365155212116994575920151188842851740380508864908970,\r\n    2420: 374647389289270354779812696943359199223073776527524,\r\n    2421: 384384309389248455327267290257609074709972871788879,\r\n    2422: 394372231521736030856900123129107963761511852907062,\r\n    2423: 404617573563588459702218138566029837845857058362469,\r\n    2424: 415126916158535023731030449746058156911457360217500,\r\n    2425: 425907006811702486258611691435747829051036619210903,\r\n    2426: 436964764086304546997571902667823798077679571339689,\r\n    2427: 448307281905025750783203518734071850525930124835870,\r\n    2428: 459941833958690501858441260833172834575927050017497,\r\n    2429: 471875878224871422129752689802003581309719671216145,\r\n    2430: 484117061599156426525236728117223720907832020184888,\r\n    2431: 496673224641860608784678055946833883950031191035725,\r\n    2432: 509552406443037374969583492229383313416835733059701,\r\n    2433: 522762849608713268897451362983651906277382721179854,\r\n    2434: 536313005371342643715460083111040042096768651944785,\r\n    2435: 550211538827551788032090316191702467148009553891765,\r\n    2436: 564467334306317355502338280181042531694130943361929,\r\n    2437: 579089500870801016601654991798984624538203584674550,\r\n    2438: 594087377957141194645081615027313378657219091976058,\r\n    2439: 609470541153583610086244251156702088407546864564250,\r\n    2440: 625248808123415184021445170239142357065496320226974,\r\n    2441: 641432244675250690988723453000798446534275367015717,\r\n    2442: 658031170984308451084537723836848917759126780943929,\r\n    2443: 675056167968400361774985057979390540476824195499264,\r\n    2444: 692518083822452741394297527894579793217444427279865,\r\n    2445: 710428040715467841255717203419691810125435835218542,\r\n    2446: 728797441653931534847387578562876222605215306007682,\r\n    2447: 747637977515770665320414243823232108546943571791584,\r\n    2448: 766961634259063882272862309538971496456501841189299,\r\n    2449: 786780700309812582901493233837104883069651992252500,\r\n    2450: 807107774133183849507621375104362485942528919417094,\r\n    2451: 827955771992745105077858611205558631300937454362243,\r\n    2452: 849337935902320652619232737317794449777545949179711,\r\n    2453: 871267841775213384980863950063063429886904651528812,\r\n    2454: 893759407775650814410526929963928966861696330836200,\r\n    2455: 916826902877433240978780331677009554236212353692084,\r\n    2456: 940484955634883423732306479679700600136395142799772,\r\n    2457: 964748563171321607096873785043308907920748393645865,\r\n    2458: 989633100390417258370972350733200785584553946028102,\r\n    2459: 1015154329415899462551538855668088513315200292902465,\r\n    2460: 1041328409265241672356796753836476758668568608962817,\r\n    2461: 1068171905763073500068056689718618672673472054705623,\r\n    2462: 1095701801700212541420510934836771894810436524644206,\r\n    2463: 1123935507244352919801698227500042488236652668362464,\r\n    2464: 1152890870608594412929146690100187865796230009117415,\r\n    2465: 1182586188984146757378861272237745685156851393567877,\r\n    2466: 1213040219743698104212153283094735988868458164856735,\r\n    2467: 1244272191922094708920237946746471334658921810675089,\r\n    2468: 1276301817981140870474529866246359687648227775992726,\r\n    2469: 1309149305865493979065272921268867078953610074980355,\r\n    2470: 1342835371356799383941072744632607586619060990003342,\r\n    2471: 1377381250733383747666895193431311551421473834674537,\r\n    2472: 1412808713743003709421434478836269410607157240633931,\r\n    2473: 1449140076896329138317020116671377802568526770518725,\r\n    2474: 1486398217089027121199419785627770438512228407175000,\r\n    2475: 1524606585560504203472825372845600976263733665501642,\r\n    2476: 1563789222197560394205351099996482830581156974888244,\r\n    2477: 1603970770191409168676519057930382172908445935119463,\r\n    2478: 1645176491056723265830534175841536314124424257900655,\r\n    2479: 1687432280021576600685684487181671811367617087501755,\r\n    2480: 1730764681797368211260238937556940484156749101230455,\r\n    2481: 1775200906738034957464112810216480762332001678674799,\r\n    2482: 1820768847398085810011063048337611865735620543349686,\r\n    2483: 1867497095499222138016227017428624557231848665351291,\r\n    2484: 1915414959315545554866069359053268627009894091487255,\r\n    2485: 1964552481487597746580633524928622127514294053468578,\r\n    2486: 2014940457275725421793253569605575859047900517862975,\r\n    2487: 2066610453263518227450300026070406061787487374956619,\r\n    2488: 2119594826522328312496888837397949369108992226003579,\r\n    2489: 2173926744248147339669532102906132397617461595649235,\r\n    2490: 2229640203882390293040946390903966696602633829194840,\r\n    2491: 2286770053728415559686499093247615980043870048333375,\r\n    2492: 2345352014075897634933772608434944801289607520822444,\r\n    2493: 2405422698845462573006497019894423614036351120521629,\r\n    2494: 2467019637766297143181469675691820929552138013921170,\r\n    2495: 2530181299099750724441152937967329319658147447405249,\r\n    2496: 2594947112922264451615392923126900249342712365881980,\r\n    2497: 2661357494981285189837685277991457183899724929972336,\r\n    2498: 2729453871138152742649660700418835108908145695065284,\r\n    2499: 2799278702412287477405614444445747930301938442180000,\r\n    2500: 2870875510641352469269629800993561138276373608937244,\r\n    2501: 2944288904772419516055596903431635682611440388817684,\r\n    2502: 3019564607799532159016586951616642980389816614848623,\r\n    2503: 3096749484363431362720513648966835225350796839944705,\r\n    2504: 3175891569029590968434327113853291229809825601961265,\r\n    2505: 3257040095261100652976951554528119114719453404725007,\r\n    2506: 3340245525103334116822171147466786507458445890183988,\r\n    2507: 3425559579597749814517587789768024144026745140376550,\r\n    2508: 3513035269942590955686749126214187667970579050845937,\r\n    2509: 3602726929418680979845445364711401806180203650663725,\r\n    2510: 3694690246098950482357992748748848483474524052004611,\r\n    2511: 3788982296360781887103496312666448565688651771156677,\r\n    2512: 3885661579220719274616818998490729558629719751838590,\r\n    2513: 3984788051511562939333648375836061468352863107532895,\r\n    2514: 4086423163922351728879727101483809741806177963555690,\r\n    2515: 4190629897922231281075551233411026977189480304097898,\r\n    2516: 4297472803589713195797719954967455347047259565521535,\r\n    2517: 4407018038369349240856665212333154882125704077589469,\r\n    2518: 4519333406778376182071537408268876717047377660539309,\r\n    2519: 4634488401086431042999613202320599056013666269808095,\r\n    2520: 4752554242991993841520963249414089899868727306156151\r\n}\r\n\r\n\r\ndef exp_sum(number):\r\n    if number < 0:\r\n        return 0\r\n    return ANSWERS[number]\r\n",
  "54ff3102c1bad923760001f3": "def getCount(inputStr):\r\n    return sum(1 for let in inputStr if let in \"aeiouAEIOU\")\r\n",
  "52b5247074ea613a09000164": "from math import *\n\n\ndef cooking_time(eggs):\n    return 5 * ceil(eggs / 8.0)\n",
  "577bd8d4ae2807c64b00045b": "def declare_winner(fighter1, fighter2, first_attacker):\r\n    cur, opp = (fighter1, fighter2) if first_attacker == fighter1 . name else (\r\n        fighter2, fighter1)\r\n    while cur . health > 0:\r\n    opp . health -= cur . damage_per_attack\r\n    cur, opp = opp, cur\r\n    return opp . name\r\n",
  "554b4ac871d6813a03000035": "def high_and_low(numbers):  # z.\n    nn = [int(s) for s in numbers . split(\" \")]\n    return \"%i %i\" % (max(nn), min(nn))\n",
  "525f50e3b73515a6db000b83": "def create_phone_number(n):\r\n    return \"({}{}{}) {}{}{}-{}{}{}{}\".format(*n)\r\n",
  "53dc54212259ed3d4f00071c": "def sum_array(a):\r\n    return sum(a)\r\n",
  "511f11d355fe575d2c000001": "def two_oldest_ages(ages):\r\n    return sorted(ages)[- 2:]\r\n",
  "57a083a57cb1f31db7000028": "def powers_of_two(n):\r\n    return [2 * * x for x in range(n + 1)]\r\n",
  "5ab6538b379d20ad880000ab": "def area_or_perimeter(l, w):\r\n    return l * w if l == w else (l + w) * 2\r\n",
  "5a420163b6cfd7cde5000077": "import re\n\n\ndef nba_cup(result_sheet, team):\n\n    if not team:\n        return \"\"\n    wins, draws, losses, points, conced = 0, 0, 0, 0, 0\n    for t1, p1, t2, p2 in re . findall(r'(.+?) (\\b[\\d.]+\\b) (.+?) (\\b[\\d.]+\\b)(?:,|$)', result_sheet):\n\n    if '.' in p1 or '.' in p2:\n        return \"Error(float number):{} {} {} {}\" . format(t1, p1, t2, p2)\n\n    if team == t1 or team == t2:\n    ptsTeam, ptsOther = map(int, (p1, p2) if t1 == team else (p2, p1))\n    points += ptsTeam\n    conced += ptsOther\n    if ptsTeam == ptsOther:\n        draws += 1\n    elif ptsTeam < ptsOther:\n        losses += 1\n    else:\n        wins += 1\n    overAllScore = 3 * wins + draws\n    return (\"{}:This team didn't play!\" if not points and not losses else\n            \"{}:W={};D={};L={};Scored={};Conceded={};Points={}\"). format(team, wins, draws, losses, points, conced, overAllScore)\n",
  "57eae65a4321032ce000002d": "def fake_bin(x):\r\n    return '' . join('0' if c < '5' else '1' for c in x)\r\n",
  "57a4d500e298a7952100035d": "def hex_to_dec(s):\r\n    return int(s, 16)\r\n",
  "5596f6e9529e9ab6fb000014": "def shifted_diff(first, second):\r\n    return (second + second). find(first) if len(first) == len(second) else - 1\r\n",
  "5a25ac6ac5e284cfbe000111": "COLORS = set(\"RGB\")\r\n\r\n\r\ndef triangle(row):\r\n    while len(row) > 1:\r\n    row = '' . join(a if a == b else (\r\n        COLORS - {a, b}). pop() for a, b in zip(row, row[1:]))\r\n    return row\r\n",
  "54c27a33fb7da0db0100040e": "import math\n\n\ndef is_square(n):\n    return n > - 1 and math . sqrt(n) % 1 == 0\n",
  "56bc28ad5bdaeb48760009b0": "def remove_char(s):\r\n    return s[1: - 1]\r\n",
  "57a4a3e653ba3346bc000810": "def describeList(lst):\r\n    return [\"empty\", \"singleton\", \"longer\"][min(len(lst), 2)]\r\n",
  "52685f7382004e774f0001f7": "def make_readable(seconds):\r\n    hours, seconds = divmod(seconds, 60 * * 2)\r\n    minutes, seconds = divmod(seconds, 60)\r\n    return '{:02}:{:02}:{:02}' . format(hours, minutes, seconds)\r\n",
  "5239f06d20eeab9deb00049b": "def fibonacci(n):\r\n    if n <= 0:\r\n    return []\r\n    a = 0\r\n    b = 1\r\n    l = [0]\r\n    for i in range(n):\r\n    a, b = b, a + b\r\n    l . append(a)\r\n    return l[0: n]\r\n",
  "5168bb5dfe9a00b126000018": "def solution(str):\r\n    return str[:: - 1]\r\n",
  "557cd6882bfa3c8a9f0000c1": "def get_age(age):\r\n    return int(age[0])\r\n",
  "57eb8fcdf670e99d9b000272": "def high(x):\r\n    return max(x . split(), key=lambda k: sum(ord(c) - 96 for c in k))\r\n",
  "551dd1f424b7a4cdae0001f0": "def whoIsNext(names, r):\r\n    while r > 5:\r\n    r = (r - 4) / 2\r\n    return names[r - 1]\r\n",
  "55edaba99da3a9c84000003b": "def divisible_by(numbers, divisor):\r\n    return [x for x in numbers if x % divisor == 0]\r\n",
  "56dec885c54a926dcd001095": "def opposite(number):\r\n    return - number\r\n",
  "534ea96ebb17181947000ada": "def breakChocolate(n, m):\r\n    return max(n * m - 1, 0)\r\n",
  "56b1f01c247c01db92000076": "def double_char(s):\r\n    return '' . join(c * 2 for c in s)\r\n",
  "55f8a9c06c018a0d6e000132": "def validate_pin(pin):\r\n    return len(pin) in (4, 6) and pin . isdigit()\r\n",
  "55c45be3b2079eccff00010f": "def order(words):\r\n    return ' ' . join(sorted(words . split(), key=lambda w: sorted(w)))\r\n",
  "55ecd718f46fba02e5000029": "def between(a, b):\r\n    return list(range(a, b + 1))\r\n",
  "606efc6a9409580033837dfb": "def plant(seed, water, fert, temp):\r\n    return ('-' * water + seed * fert) * water if temp >= 20 and temp <= 30 else ('-' * water) * water + seed\r\n",
  "5808e2006b65bff35500008f": "def position(alphabet):\r\n    return \"Position of alphabet: {}\" . format(ord(alphabet) - 96)\r\n",
  "54acc128329e634e9a000362": "STATE_TO_COMMANDS = {\r\n    'CLOSED': {\r\n        'APP_PASSIVE_OPEN': 'LISTEN',\r\n        'APP_ACTIVE_OPEN': 'SYN_SENT'\r\n    },\r\n    'LISTEN': {\r\n        'RCV_SYN': 'SYN_RCVD',\r\n        'APP_SEND': 'SYN_SENT',\r\n        'APP_CLOSE': 'CLOSED'\r\n    },\r\n    'SYN_RCVD': {\r\n        'APP_CLOSE': 'FIN_WAIT_1',\r\n        'RCV_ACK': 'ESTABLISHED'\r\n    },\r\n    'SYN_SENT': {\r\n        'RCV_SYN': 'SYN_RCVD',\r\n        'RCV_SYN_ACK': 'ESTABLISHED',\r\n        'APP_CLOSE': 'CLOSED'\r\n    },\r\n    'ESTABLISHED': {\r\n        'APP_CLOSE': 'FIN_WAIT_1',\r\n        'RCV_FIN': 'CLOSE_WAIT'\r\n    },\r\n    'FIN_WAIT_1': {\r\n        'RCV_FIN': 'CLOSING',\r\n        'RCV_FIN_ACK': 'TIME_WAIT',\r\n        'RCV_ACK': 'FIN_WAIT_2'\r\n    },\r\n    'CLOSING': {\r\n        'RCV_ACK': 'TIME_WAIT'\r\n    },\r\n    'FIN_WAIT_2': {\r\n        'RCV_FIN': 'TIME_WAIT'\r\n    },\r\n    'TIME_WAIT': {\r\n        'APP_TIMEOUT': 'CLOSED'\r\n    },\r\n    'CLOSE_WAIT': {\r\n        'APP_CLOSE': 'LAST_ACK'\r\n    },\r\n    'LAST_ACK': {\r\n        'RCV_ACK': 'CLOSED'\r\n    }\r\n}\r\n\r\n\r\ndef traverse_TCP_states(events):\r\n    state = \"CLOSED\"  # initial state, always\r\n    for event in events:\r\n    if event not in STATE_TO_COMMANDS[state]:\r\n    return 'ERROR'\r\n    state = STATE_TO_COMMANDS[state][event]\r\n    return state\r\n",
  "54b42f9314d9229fd6000d9c": "def duplicate_encode(word):\r\n    return \"\" . join([\"(\" if word . lower(). count(c) == 1 else \")\" for c in word . lower()])\r\n",
  "514b92a657cdc65150000006": "def solution(number):\r\n    return sum(x for x in range(number) if x % 3 == 0 or x % 5 == 0)\r\n",
  "526d84b98f428f14a60008da": "def hamming(n):\r\n    bases = [2, 3, 5]\r\n    expos = [0, 0, 0]\r\n    hamms = [1]\r\n    for _ in range(1, n):\r\n    next_hamms = [bases[i] * hamms[expos[i]] for i in range(3)]\r\n    next_hamm = min(next_hamms)\r\n    hamms . append(next_hamm)\r\n    for i in range(3):\r\n    expos[i] += int(next_hamms[i] == next_hamm)\r\n    return hamms[- 1]\r\n",
  "57a1fd2ce298a731b20006a4": "def is_palindrome(s):\r\n    s = s . lower()\r\n    return s == s[:: - 1]\r\n",
  "595519279be6c575b5000016": "def battle(x, y):\r\n\r\n    # Compute x score using Unicode\r\n    x_value = sum(ord(char) - 64 for char in x)\r\n\r\n    # Compute y score using Unicode\r\n    y_value = sum(ord(char) - 64 for char in y)\r\n\r\n    if x_value < y_value:\r\n    return y\r\n    if x_value > y_value:\r\n    return x\r\n    return \"Tie!\"\r\n",
  "55d24f55d7dd296eb9000030": "def summation(num):\r\n    return sum(range(1, num + 1))\r\n",
  "55ca77fa094a2af31f00002a": "la_liga_goals = 43\nchampions_league_goals = 10\ncopa_del_rey_goals = 5\ntotal_goals = la_liga_goals + champions_league_goals + copa_del_rey_goals\n",
  "56676e8fabd2d1ff3000000c": "def find_needle(haystack):\r\n    return f'found the needle at position { haystack . index ( \"needle\" )} '\r\n",
  "55c04b4cc56a697bb0000048": "def scramble(s1, s2):\r\n    for c in set(s2):\r\n    if s1 . count(c) < s2 . count(c):\r\n    return False\r\n    return True\r\n",
  "56f699cd9400f5b7d8000b55": "def fix_the_meerkat(arr):\r\n    return arr[:: - 1]\r\n",
  "5b39e3772ae7545f650000fc": "def remove_duplicate_words(s):\r\n    return ' ' . join(dict . fromkeys(s . split()))\r\n",
  "568d0dd208ee69389d000016": "def rental_car_cost(d):\r\n    result = d * 40\r\n    if d >= 7:\r\n    result -= 50\r\n    elif d >= 3:\r\n    result -= 20\r\n    return result\r\n",
  "515e188a311df01cba000003": "def get_planet_name(id):\r\n    return {\r\n        1: \"Mercury\",\r\n        2: \"Venus\",\r\n        3: \"Earth\",\r\n        4: \"Mars\",\r\n        5: \"Jupiter\",\r\n        6: \"Saturn\",\r\n        7: \"Uranus\",\r\n        8: \"Neptune\",\r\n    }. get(id, None)\r\n",
  "56fe97b3cc08ca00e4000dc9": "def sc(apple):\r\n    for i in apple:\r\n    for j in i:\r\n    if j == \"B\":\r\n    return [apple . index(i), i . index(j)]\r\n",
  "57e76bc428d6fbc2d500036d": "def string_to_array(string):\r\n    return string . split(\" \")\r\n",
  "5263a84ffcadb968b6000513": "from numpy import matrix\n\n\ndef matrix_mult(a, b):\n    return (matrix(a) * matrix(b)). tolist()\n",
  "5208f99aee097e6552000148": "def solution(s):\r\n    return '' . join(' ' + c if c . isupper() else c for c in s)\r\n",
  "55b75fcf67e558d3750000a3": "from operator import mul\r\n\r\n\r\nclass Block (object):\r\n    def __init__(self, dimensions):\r\n    self . dimensions = dimensions\r\n    def get_width(self):\r\n    return self . dimensions[0]\r\n\r\n    def get_length(self):\r\n    return self . dimensions[1]\r\n\r\n    def get_height(self):\r\n    return self . dimensions[2]\r\n\r\n    def get_volume(self):\r\n    return reduce(mul, self . dimensions)\r\n\r\n    def get_surface_area(self):\r\n    w, l, h = self . dimensions\r\n    return 2 * (w * l + l * h + w * h)\r\n",
  "54edbc7200b811e956000556": "def count_sheeps(arrayOfSheeps):\r\n    return arrayOfSheeps . count(True)\r\n",
  "52a89c2ea8ddc5547a000863": "def loop_size(node):\n    turtle, rabbit = node . next, node . next . next\n    # Find a point in the loop. Any point will do!\n    # Since the rabbit moves faster than the turtle\n    # and the kata guarantees a loop, the rabbit will\n    # eventually catch up with the turtle.\n    while turtle != rabbit:\n    turtle = turtle . next\n    rabbit = rabbit . next . next\n    # The turtle and rabbit are now on the same node,\n    # but we know that node is in a loop. So now we\n    # keep the turtle motionless and move the rabbit\n    # until it finds the turtle again, counting the\n    # nodes the rabbit visits in the mean time.\n    count = 1\n    rabbit = rabbit . next\n    while turtle != rabbit:\n    count += 1\n    rabbit = rabbit . next\n    # voila\n    return count\n",
  "5556282156230d0e5e000089": "def DNAtoRNA(dna):\r\n    return dna . replace('T', 'U')\r\n",
  "5899a4b1a6648906fe000113": "def find_routes(routes: list) - > str:\r\n    d = dict(routes)\r\n    res = list(d . keys() - d . values())\r\n    while res[- 1] in d:\r\n        res . append(d[res[- 1]])\r\n    return ', ' . join(res)\r\n",
  "528e95af53dcdb40b5000171": "import math\n\n\ndef factorial(n):\n    if n < 0:\n    return None\n    return math . factorial(n)\n",
  "5aee86c5783bb432cd000018": "def hydrate(drink_string):\r\n    c = sum(int(c) for c in drink_string if c . isdigit())\r\n    return \"{} {} of water\" . format(c, 'glass') if c == 1 else \"{} {} of water\" . format(c, 'glasses')\r\n",
  "5c8bfa44b9d1192e1ebd3d15": "def warn_the_sheep(queue):\r\n    n = len(queue) - queue . index('wolf') - 1\r\n    return f'Oi! Sheep number { n } ! You are about to be eaten by a wolf!' if n else 'Pls go away and stop eating my sheep'\r\n",
  "5769b3802ae6f8e4890009d2": "def remove_every_other(my_list):\r\n    return my_list[:: 2]\r\n",
  "563a631f7cbbc236cf0000c2": "def move(position, roll):\r\n    return position + 2 * roll\r\n",
  "554a44516729e4d80b000012": "def nbMonths(oldCarPrice, newCarPrice, saving, loss):\n    months = 0\n    budget = oldCarPrice\n    while budget < newCarPrice:\n    months += 1\n    if months % 2 == 0:\n    loss += 0.5\n    oldCarPrice *= (100 - loss) / 100\n    newCarPrice *= (100 - loss) / 100\n    budget = saving * months + oldCarPrice\n    return [months, round(budget - newCarPrice)]\n",
  "5839edaa6754d6fec10000a2": "def find_missing_letter(chars):\r\n    n = 0\r\n    while ord(chars[n]) == ord(chars[n + 1]) - 1:\r\n    n += 1\r\n    return chr(1 + ord(chars[n]))\r\n",
  "57eae20f5500ad98e50002c5": "def no_space(x):\r\n    return x . replace(' ', '')\r\n",
  "58261acb22be6e2ed800003a": "def get_volume_of_cuboid(length, width, height):\n    return length * width * height\n    # PEP8: kata function name should use snake_case not mixedCase\n    getVolumeOfCubiod = get_volume_of_cuboid\n",
  "5544c7a5cb454edb3c000047": "def bouncingBall(h, bounce, window):\n    if not 0 < bounce < 1:\n        return - 1\n    count = 0\n    while h > window:\n    count += 1\n    h *= bounce\n    if h > window:\n        count += 1\n    return count or - 1\n",
  "55983863da40caa2c900004e": "import itertools\r\n\r\n\r\ndef next_bigger(n):\r\n    s = list(str(n))\r\n    for i in range(len(s) - 2, - 1, - 1):\r\n    if s[i] < s[i + 1]:\r\n    t = s[i:]\r\n    m = min(filter(lambda x: x > t[0], t))\r\n    t . remove(m)\r\n    t . sort()\r\n    s[i:] = [m] + t\r\n    return int(\"\" . join(s))\r\n    return - 1\r\n",
  "53d40c1e2f13e331fc000c26": "def fib(n):\r\n    if n < 0:\r\n        return (- 1) * * (n % 2 + 1) * fib(- n)\r\n    a = b = x = 1\r\n    c = y = 0\r\n    while n:\r\n    if n % 2 == 0:\r\n    (a, b, c) = (a * a + b * b,\r\n                 a * b + b * c,\r\n                 b * b + c * c)\r\n    n /= 2\r\n    else:\r\n    (x, y) = (a * x + b * y,\r\n              b * x + c * y)\r\n    n -= 1\r\n    return y\r\n",
  "5f0ed36164f2bc00283aed07": "def over_the_road(address, n):\n    ''' \n    Input: address (int, your house number), n (int, length of road in houses) \n    Returns: int, number of the house across from your house. \n    '''\n    # this is as much a math problem as a coding one\n    # if your house is [even/odd], the opposite house will be [odd/even]\n    # highest number on street is 2n\n    # Left side houses are [1, 3, ... 2n-3, 2n-1]\n    # Right side houses are [2n, 2n-2, ... 4, 2]\n    # Sum of opposite house numbers will always be 2n+1\n    return (2 * n + 1 - address)\n",
  "585d7d5adb20cf33cb000235": "def find_uniq(arr):\r\n    a, b = set(arr)\r\n    return a if arr . count(a) == 1 else b\r\n",
  "5592e3bd57b64d00f3000047": "def find_nb(m):\n    n = 1\n    volume = 0\n    while volume < m:\n    volume += n * * 3\n    if volume == m:\n    return n\n    n += 1\n    return - 1\n",
  "55bf01e5a717a0d57e0000ec": "def persistence(n):\r\n    n = str(n)\r\n    count = 0\r\n    while len(n) > 1:\r\n    p = 1\r\n    for i in n:\r\n    p *= int(i)\r\n    n = str(p)\r\n    count += 1\r\n    return count\r\n    # your code\r\n",
  "55fab1ffda3e2e44f00000c6": "def cockroach_speed(s):\r\n    return s / / 0.036\r\n",
  "5813d19765d81c592200001a": "def dont_give_me_five(start, end):\r\n    return sum('5' not in str(i) for i in range(start, end + 1))\r\n",
  "56453a12fcee9a6c4700009c": "def close_compare(a, b, margin=0):\r\n    return 0 if abs(a - b) <= margin else - 1 if b > a else 1\r\n",
  "545afd0761aa4c3055001386": "def take(arr, n):\r\n    return arr[: n]\r\n",
  "598ab63c7367483c890000f4": "def string_task(s):\r\n    return '' . join(f'. { a } ' for a in s . lower() if a not in 'aoyeui')\r\n",
  "57cc975ed542d3148f00015b": "def check(seq, elem):\r\n    return elem in seq\r\n",
  "522551eee9abb932420004a0": "def nth_fib(n):\r\n    a, b = 0, 1\r\n    for i in range(n - 1):\r\n        a, b = b, a + b\r\n    return a\r\n",
  "55225023e1be1ec8bc000390": "def greet(name):\r\n    if name == \"Johnny\":\r\n    return \"Hello, my love!\"\r\n    return \"Hello, {name}!\" . format(name=name)\r\n",
  "577a98a6ae28071780000989": "def minimum(arr):\r\n    return min(arr)\r\n\r\n    def maximum(arr):\r\n    return max(arr)\r\n",
  "5388f0e00b24c5635e000fc6": "def swap_values(args):\r\n    args[0], args[1] = args[1], args[0]\r\n    return args\r\n",
  "5726f813c8dcebf5ed000a6b": "def count_Kprimes(k, start, end):\r\n    return [n for n in range(start, end + 1) if find_k(n) == k]\r\n\r\n    def puzzle(s):\r\n    a = count_Kprimes(1, 0, s)\r\n    b = count_Kprimes(3, 0, s)\r\n    c = count_Kprimes(7, 0, s)\r\n\r\n    return sum(1 for x in a for y in b for z in c if x + y + z == s)\r\n\r\n    def find_k(n):\r\n    res = 0\r\n    i = 2\r\n    while i * i <= n:\r\n    while n % i == 0:\r\n    n / /= i\r\n    res += 1\r\n    i += 1\r\n    if n > 1:\r\n        res += 1\r\n    return res\r\n",
  "55a70521798b14d4750000a4": "def greet(name):\r\n    return f'Hello, { name } how are you doing today?'\r\n",
  "57241e0f440cd279b5000829": "def sum_mul(n, m):\r\n    if m > 0 and n > 0:\r\n    return sum(range(n, m, n))\r\n    else:\r\n    return 'INVALID'\r\n",
  "56d3e702fc231fdf72001779": "def sxore(n):\r\n    return [n, 1, n + 1, 0][n % 4]\r\n",
  "54da5a58ea159efa38000836": "def find_it(seq):\r\n    for i in seq:\r\n    if seq . count(i) % 2 != 0:\r\n    return i\r\n",
  "52e88b39ffb6ac53a400022e": "from ipaddress import IPv4Address\n\n\ndef int32_to_ip(int32):\n    return str(IPv4Address(int32))\n",
  "58fa273ca6d84c158e000052": "def digits(n):\r\n    return len(str(n))\r\n",
  "52f78966747862fc9a0009ae": "import operator\r\n\r\n\r\ndef calc(expr):\r\n    OPERATORS = {'+': operator . add, '-': operator . sub,\r\n                 '*': operator . mul, '/': operator . truediv}\r\n    stack = [0]\r\n    for token in expr . split(\" \"):\r\n    if token in OPERATORS:\r\n    op2, op1 = stack . pop(), stack . pop()\r\n    stack . append(OPERATORS[token](op1, op2))\r\n    elif token:\r\n    stack . append(float(token))\r\n    return stack . pop()\r\n",
  "5861d28f124b35723e00005e": "def zeroFuel(distance_to_pump, mpg, fuel_left):\r\n    return distance_to_pump <= mpg * fuel_left\r\n",
  "5679aa472b8f57fb8c000047": "def find_even_index(arr):\r\n    for i in range(len(arr)):\r\n    if sum(arr[: i]) == sum(arr[i + 1:]):\r\n    return i\r\n    return - 1\r\n",
  "57eaeb9578748ff92a000009": "def sum_mix(arr):\r\n    return sum(map(int, arr))\r\n",
  "555bfd6f9f9f52680f0000c5": "def reverseNumber(n):\r\n    if n < 0:\r\n        return - reverseNumber(- n)\r\n    return int(str(n)[:: - 1])\r\n",
  "5933a1f8552bc2750a0000ed": "def nth_even(n):\r\n    return 2 * (n - 1)\r\n",
  "57a1d5ef7cb1f3db590002af": "def fibonacci(n: int) - > int:\n    \"\"\"Given a positive argument n, returns the nth term of the Fibonacci Sequence. \n    \"\"\"\n    x, y = 0, 1\n    for i in range(n):\n    x, y = y, y + x\n    return x\n",
  "569d488d61b812a0f7000015": "def data_reverse(data):\r\n    res = []\r\n\r\n    for i in range(len(data) - 8, - 1, - 8):\r\n    res . extend(data[i: i + 8])\r\n\r\n    return res\r\n",
  "578aa45ee9fd15ff4600090d": "def sort_array(arr):\r\n    odds = sorted((x for x in arr if x % 2 != 0), reverse=True)\r\n    return [x if x % 2 == 0 else odds . pop() for x in arr]\r\n",
  "55c6126177c9441a570000cc": "def order_weight(_str):\r\n    return ' ' . join(sorted(sorted(_str . split(' ')), key=lambda x: sum(int(c) for c in x)))\r\n",
  "5656b6906de340bd1b0000ac": "def longest(a1, a2):\r\n    return \"\" . join(sorted(set(a1 + a2)))\r\n",
  "551f23362ff852e2ab000037": "def longest_slide_down(p):\r\n    res = p . pop()\r\n    while p:\r\n    tmp = p . pop()\r\n    res = [tmp[i] + max(res[i], res[i + 1]) for i in range(len(tmp))]\r\n    return res . pop()\r\n",
  "59b844528bcb7735560000a0": "def is_nice(arr):\r\n    s = set(arr)\r\n    return bool(arr) and all(n + 1 in s or n - 1 in s for n in s)\r\n",
  "5667e8f4e3f572a8f2000039": "def accum(s):\r\n    return '-' . join(c . upper() + c . lower() * i for i, c in enumerate(s))\r\n",
  "56b7251b81290caf76000978": "def get_last_digit(index):\r\n    a, b = 0, 1\r\n    for _ in range(index):\r\n    a, b = b, (a + b) % 10\r\n    return a\r\n",
  "550554fd08b86f84fe000a58": "def in_array(array1, array2):\r\n    # your code\r\n    res = []\r\n    for a1 in array1:\r\n    for a2 in array2:\r\n    if a1 in a2 and not a1 in res:\r\n    res . append(a1)\r\n    res . sort()\r\n    return res\r\n",
  "55f2b110f61eb01779000053": "def get_sum(a, b):\r\n    return sum(range(min(a, b), max(a, b) + 1))\r\n",
  "52597aa56021e91c93000cb0": "def move_zeros(array):\r\n    for i in array:\r\n    if i == 0:\r\n    array . remove(i)  # Remove the element from the array\r\n    array . append(i)  # Append the element to the end\r\n    return array\r\n",
  "5a2fd38b55519ed98f0000ce": "def multi_table(number):\r\n    return '\\n' . join(f' { i } * { number } = { i * number } ' for i in range(1, 11))\r\n",
  "55688b4e725f41d1e9000065": "def even_fib(m):\n    x, y = 0, 1\n    counter = 0\n    while y < m:\n    if y % 2 == 0:\n    counter += y\n    x, y = y, x + y\n    return counter\n",
  "577bd026df78c19bca0002c0": "def correct(string):\r\n    return string . translate(str . maketrans(\"501\", \"SOI\"))\r\n",
  "576b93db1129fcf2200001e6": "def sum_array(arr):\r\n    if arr == None or len(arr) < 3:\r\n    return 0\r\n    return sum(arr) - max(arr) - min(arr)\r\n",
  "55f73be6e12baaa5900000d4": "def goals(* a):\r\n    return sum(a)\r\n",
  "55ad04714f0b468e8200001c": "def get_char(c):\r\n    return chr(c)\r\n",
  "570a6a46455d08ff8d001002": "def no_boring_zeros(n):\r\n    try:\r\n    return int(str(n). rstrip('0'))\r\n    except ValueError:\r\n    return 0\r\n",
  "5a6663e9fd56cb5ab800008b": "def human_years_cat_years_dog_years(human_years):\n    catYears = 0\n    dogYears = 0\n    if human_years == 1:\n    catYears += 15\n    dogYears += 15\n    return [human_years, catYears, dogYears]\n    elif human_years == 2:\n    catYears += 24\n    dogYears += 24\n    return [human_years, catYears, dogYears]\n    elif human_years > 2:\n    catYears += 24\n    dogYears += 24\n    years = human_years - 2\n    catYears += years * 4\n    dogYears += years * 5\n    return [human_years, catYears, dogYears]\n    return [0, 0, 0]\n",
  "5a07e5b7ffe75fd049000051": "def sorter(textbooks):\r\n    return sorted(textbooks, key=str . lower)\r\n",
  "525a566985a9a47bc8000670": "import numpy as np\r\nd = {\"clockwise\": 3, \"counter-clockwise\": 1}\r\n\r\n\r\ndef rotate(matrix, direction):\r\n    return np . rot90(matrix, d[direction]). tolist()\r\n",
  "57f222ce69e09c3630000212": "def well(x):\r\n    c = x . count('good')\r\n    return 'I smell a series!' if c > 2 else 'Publish!' if c else 'Fail!'\r\n",
  "546e2562b03326a88e000020": "def square_digits(num):\r\n    ret = \"\"\r\n    for x in str(num):\r\n    ret += str(int(x) * * 2)\r\n    return int(ret)\r\n",
  "573f5c61e7752709df0005d2": "def merge_arrays(a, b):\r\n    return sorted(set(a + b))\r\n",
  "596c6eb85b0f515834000049": "def replace_dots(string):\r\n    return string . replace('.', '-')\r\n",
  "55cbc3586671f6aa070000fb": "def check_for_factor(base, factor):\r\n    return base % factor == 0\r\n",
  "583710ccaa6717322c000105": "def simple_multiplication(number):\r\n    return number * 9 if number % 2 else number * 8\r\n",
  "5583090cbe83f4fd8c000051": "def digitize(n):\r\n    return [int(x) for x in str(n)[:: - 1]]\r\n",
  "593ff8b39e1cc4bae9000070": "from functools import lru_cache\r\n\r\n\r\n@ lru_cache(None)\r\ndef lcs(x, y):\r\n    if not (x and y):\r\n        return ''\r\n    if x[0] == y[0]:\r\n        return x[0] + lcs(x[1:], y[1:])\r\n    return max(lcs(x, y[1:]), lcs(x[1:], y), key=len)\r\n",
  "53934feec44762736c00044b": "a = str(123)\n",
  "545cedaa9943f7fe7b000048": "import string\r\n\r\n\r\ndef is_pangram(s):\r\n    s = s . lower()\r\n    for char in 'abcdefghijklmnopqrstuvwxyz':\r\n    if char not in s:\r\n    return False\r\n    return True\r\n",
  "5bb904724c47249b10000131": "def points(games):\r\n    count = 0\r\n    for score in games:\r\n    res = score . split(':')\r\n    if res[0] > res[1]:\r\n    count += 3\r\n    elif res[0] == res[1]:\r\n    count += 1\r\n    return count\r\n",
  "5531abe4855bcc8d1f00004c": "def bowling_score(frames):\r\n    rolls = list(frames . replace(' ', ''))\r\n    for i, hit in enumerate(rolls):\r\n    if hit == 'X':\r\n    rolls[i] = 10\r\n    elif hit == '/':\r\n    rolls[i] = 10 - rolls[i - 1]\r\n    else:\r\n    rolls[i] = int(hit)\r\n    score = 0\r\n    for i in range(10):\r\n    frame = rolls . pop(0)\r\n    if frame == 10:\r\n    score += frame + rolls[0] + rolls[1]  # Strike!\r\n    else:\r\n    frame += rolls . pop(0)\r\n    score += frame\r\n    if frame == 10:\r\n    score += rolls[0]  # Spare!\r\n    return score\r\n",
  "53dc23c68a0c93699800041d": "def smash(words):\r\n    return \" \" . join(words)\r\n",
  "550498447451fbbd7600041c": "def comp(array1, array2):\r\n    try:\r\n    return sorted([i * * 2 for i in array1]) == sorted(array2)\r\n    except:\r\n    return False\r\n",
  "51c8e37cee245da6b40000bd": "def solution(string, markers):\r\n    parts = string . split('\\n')\r\n    for s in markers:\r\n    parts = [v . split(s)[0]. rstrip() for v in parts]\r\n    return '\\n' . join(parts)\r\n",
  "5a34b80155519e1a00000009": "def multiple_of_index(arr):\r\n    return [j for i, j in enumerate(arr) if (j == 0 and i == 0) or (i != 0 and j % i == 0)]\r\n",
  "56b29582461215098d00000f": "def pipe_fix(nums):\r\n    return list(range(nums[0], nums[- 1] + 1))\r\n",
  "555086d53eac039a2a000083": "def lovefunc(flower1, flower2):\r\n    return (flower1 + flower2) % 2\r\n",
  "563b662a59afc2b5120000c6": "def nb_year(p0, percent, aug, p):\n    t = 0\n    while p0 < p:\n        # my mathematical brain hates that I need to round this\n    p0 = int(p0 * (1 + percent / 100)) + aug\n    t += 1\n    return t\n",
  "563e320cee5dddcf77000158": "def get_average(marks):\r\n    return sum(marks) / / len(marks)\r\n",
  "57a0885cbb9944e24c00008e": "def remove_exclamation_marks(s):\r\n    return s . replace('!', '')\r\n",
  "576bb71bbbcf0951d5000044": "def count_positives_sum_negatives(arr):\r\n    if not arr:\r\n        return []\r\n    pos = 0\r\n    neg = 0\r\n    for x in arr:\r\n    if x > 0:\r\n    pos += 1\r\n    if x < 0:\r\n    neg += x\r\n    return [pos, neg]\r\n",
  "58cb43f4256836ed95000f97": "from numpy import prod\n\n\ndef find_difference(a, b):\n    return abs(prod(a) - prod(b))\n",
  "57d814e4950d8489720008db": "def index(array, n):\r\n    try:\r\n    return array[n] * * n\r\n    except:\r\n    return - 1\r\n",
  "55695bc4f75bbaea5100016b": "def all_fibonacci_numbers(a=0, b=1):\r\n    while 1:\r\n    yield b\r\n    a, b = b, a + b\r\n",
  "517abf86da9663f1d2000003": "def to_camel_case(text):\r\n    removed = text . replace('-', ' '). replace('_', ' '). split()\r\n    if len(removed) == 0:\r\n    return ''\r\n    return removed[0] + '' . join([x . capitalize() for x in removed[1:]])\r\n",
  "57cc981a58da9e302a000214": "def small_enough(array, limit):\r\n    return max(array) <= limit\r\n",
  "59342039eb450e39970000a6": "def oddCount(n):\r\n    return n / / 2\r\n",
  "5704aea738428f4d30000914": "def triple_trouble(one, two, three):\r\n    return '' . join('' . join(a) for a in zip(one, two, three))\r\n",
  "5a331ea7ee1aae8f24000175": "def triangle(row):\r\n\r\n    def reduce(a, b):\r\n    return a if a == b else (set('RGB') - {a, b}). pop()\r\n\r\n    def walk(offset, root, depth):\r\n    return row[root] if not depth else curry(offset, root, * divmod(depth, 3))\r\n\r\n    def curry(offset, root, depth, degree):\r\n    return walk(3 * offset, root, depth) if not degree \\\r\n        else reduce(curry(offset, root, depth, degree - 1), curry(offset, root + offset, depth, degree - 1))\r\n\r\n    return walk(1, 0, len(row) - 1)\r\n",
  "53dbd5315a3c69eed20002dd": "def filter_list(l):\r\n    'return a new list with the strings filtered out'\r\n    return [i for i in l if not isinstance(i, str)]\r\n",
  "5808dcb8f0ed42ae34000031": "def switch_it_up(n):\r\n    return ['Zero', 'One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine'][n]\r\n",
  "5715eaedb436cf5606000381": "def positive_sum(arr):\r\n    return sum(x for x in arr if x > 0)\r\n",
  "5761a717780f8950ce001473": "def calculate_age(year_of_birth, current_year):\r\n    diff = abs(current_year - year_of_birth)\r\n    plural = '' if diff == 1 else 's'\r\n    if year_of_birth < current_year:\r\n    return 'You are {} year{} old.' . format(diff, plural)\r\n    elif year_of_birth > current_year:\r\n    return 'You will be born in {} year{}.' . format(diff, plural)\r\n    return 'You were born this very year!'\r\n",
  "56d49587df52101de70011e4": "def leo(oscar):\r\n    if oscar == 88:\r\n    return \"Leo finally won the oscar! Leo is happy\"\r\n    elif oscar == 86:\r\n    return \"Not even for Wolf of wallstreet?!\"\r\n    elif oscar < 88:\r\n    return \"When will you give Leo an Oscar?\"\r\n    elif oscar > 88:\r\n    return \"Leo got one already!\"\r\n",
  "525c7c5ab6aecef16e0001a5": "ONES = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine',\r\n        'ten', 'eleven', 'twelve', 'thirteen', 'fourteen', 'fifteen', 'sixteen', 'seventeen',\r\n        'eighteen', 'nineteen']\r\nTENS = ['twenty', 'thirty', 'forty', 'fifty',\r\n        'sixty', 'seventy', 'eighty', 'ninety']\r\n\r\n\r\ndef parse_int(string):\r\n    print(string)\r\n    numbers = []\r\n    for token in string . replace('-', ' '). split(' '):\r\n    if token in ONES:\r\n    numbers . append(ONES . index(token))\r\n    elif token in TENS:\r\n    numbers . append((TENS . index(token) + 2) * 10)\r\n    elif token == 'hundred':\r\n    numbers[- 1] *= 100\r\n    elif token == 'thousand':\r\n    numbers = [x * 1000 for x in numbers]\r\n    elif token == 'million':\r\n    numbers = [x * 1000000 for x in numbers]\r\n    return sum(numbers)\r\n",
  "554ca54ffa7d91b236000023": "def delete_nth(order, max_e):\r\n    ans = []\r\n    for o in order:\r\n    if ans . count(o) < max_e:\r\n        ans . append(o)\r\n    return ans\r\n",
  "51b62bf6a9c58071c600001b": "def solution(n):\r\n    roman_numerals = {1000: 'M',\r\n                      900: 'CM',\r\n                      500: 'D',\r\n                      400: 'CD',\r\n                      100: 'C',\r\n                      90: 'XC',\r\n                      50: 'L',\r\n                      40: 'XL',\r\n                      10: 'X',\r\n                      9: 'IX',\r\n                      5: 'V',\r\n                      4: 'IV',\r\n                      1: 'I'\r\n                      }\r\n    roman_string = ''\r\n    for key in sorted(roman_numerals . keys(), reverse=True):\r\n    while n >= key:\r\n    roman_string += roman_numerals[key]\r\n    n -= key\r\n    return roman_string\r\n",
  "5259b20d6021e9e14c0010d4": "def reverse_words(str):\r\n    return ' ' . join(s[:: - 1] for s in str . split(' '))\r\n",
  "52ceafd1f235ce81aa00073a": "def plural(n):\r\n    return n != 1\r\n",
  "52efefcbcdf57161d4000091": "from collections import Counter\n\n\ndef count(string):\n    return Counter(string)\n",
  "55f4e56315a375c1ed000159": "series = [0]\r\nfor a in range(2, 99):\r\n    for b in range(2, 42):\r\n    c = a * * b\r\n    if a == sum(map(int, str(c))):\r\n    series . append(c)\r\n    power_sumDigTerm = sorted(series). __getitem__\r\n",
  "52f3149496de55aded000410": "def sumDigits(number):\r\n    return sum(int(d) for d in str(abs(number)))\r\n",
  "64ef24b0679cdc004d08169e": "def min_turns(current, target):\r\n\r\n    total = 0\r\n    for i, j in zip(current, target):\r\n    a, b = map(int, [i, j])\r\n    total += min(abs(a - b), 10 - abs(b - a))\r\n\r\n    return total\r\n",
  "52a0f488852a85c723000aca": "def palindromize(number):\r\n    new, n = number, 0\r\n    while str(new) != str(new)[:: - 1]:\r\n    new += int(str(new)[:: - 1])\r\n    n += 1\r\n    return f' { n } { new } '\r\n",
  "54b679eaac3d54e6ca0008c9": "def create_iterator(func, n):\r\n    def f(x):\r\n    for i in range(n):\r\n    x = func(x)\r\n    return x\r\n    return f\r\n",
  "530e15517bc88ac656000716": "import string\r\nfrom codecs import encode as _dont_use_this_\r\n\r\n\r\ndef rot13(message):\r\n    alpha = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\r\n    outputMessage = \"\"\r\n    for letter in message:\r\n    if letter in alpha . lower():\r\n    outputMessage += alpha[(alpha . lower(). index(letter) + 13) % 26]. lower()\r\n    elif letter in alpha:\r\n    outputMessage += alpha[(alpha . index(letter) + 13) % 26]\r\n    else:\r\n    outputMessage += letter\r\n    return outputMessage\r\n",
  "647d08a2c736e3777c9ae1db": "def get_number_of_ways(steps, mjl):\r\n    res = [2 * * k for k in range(mjl)]\r\n\r\n    for _ in range(steps - mjl):\r\n    res . append(sum(res[- mjl:]))\r\n\r\n    return res[steps - 1]\r\n",
  "5a2c084ab6cfd7f0840000e4": "def smallerDiv(n): return next((x for x in range(2, int(n * * .5) + 1) if not n % x), 0)\r\n\r\n\r\ndef prime_ant(turns):\r\n    p, lst = 0, [2, 3]\r\n    for _ in range(turns):\r\n    if p == len(lst):\r\n    lst . append(p + 2)\r\n    sDiv = smallerDiv(lst[p])\r\n    if sDiv:\r\n    lst[p - 1] += sDiv\r\n    lst[p] / /= sDiv\r\n    p -= 1\r\n    else:\r\n    p += 1\r\n    return p\r\n",
  "58845748bd5733f1b300001f": "def range_bit_count(a, b):\r\n    return sum(bin(i). count('1') for i in range(a, b + 1))\r\n",
  "5859c82bd41fc6207900007a": "def quotable(name, quote):\r\n    return '{} said: \"{}\"' . format(name, quote)\r\n",
  "595970246c9b8fa0a8000086": "def capitalizeWord(word):\r\n    return word . capitalize()\r\n",
  "54530f75699b53e558002076": "letters = {\r\n    \"A\": \"Alpha\", \"B\": \"Bravo\", \"C\": \"Charlie\",\r\n    \"D\": \"Delta\", \"E\": \"Echo\", \"F\": \"Foxtrot\",\r\n    \"G\": \"Golf\", \"H\": \"Hotel\", \"I\": \"India\",\r\n    \"J\": \"Juliett\", \"K\": \"Kilo\", \"L\": \"Lima\",\r\n    \"M\": \"Mike\", \"N\": \"November\", \"O\": \"Oscar\",\r\n    \"P\": \"Papa\", \"Q\": \"Quebec\", \"R\": \"Romeo\",\r\n    \"S\": \"Sierra\", \"T\": \"Tango\", \"U\": \"Uniform\",\r\n    \"V\": \"Victor\", \"W\": \"Whiskey\", \"X\": \"X-ray\",\r\n    \"Y\": \"Yankee\", \"Z\": \"Zulu\"\r\n}\r\n\r\n\r\ndef nato(word):\r\n    return ' ' . join(letters[c] for c in word . upper())\r\n",
  "55b1fd84a24ad00b32000075": "def am_I_afraid(day, num):\r\n    return {\r\n        'Monday': num == 12,\r\n        'Tuesday': num > 95,\r\n        'Wednesday': num == 34,\r\n        'Thursday': num == 0,\r\n        'Friday': num % 2 == 0,\r\n        'Saturday': num == 56,\r\n        'Sunday': num == 666 or num == - 666,\r\n    }[day]\r\n",
  "5902f1839b8e720287000028": "from math import gcd\r\n\r\n\r\ndef parameter(n):\r\n    s, p = 0, 1\r\n    for m in str(n):\r\n    s += int(m)\r\n    p *= int(m)\r\n    return (s * p / (gcd(s, p)))\r\n",
  "5a0d38c9697598b67a000041": "def eliminate_unset_bits(string):\r\n    return 2 * * (string . count('1')) - 1\r\n",
  "57089707fe2d01529f00024a": "def check_alive(health: int) - > bool:\r\n    \"\"\" Return `true` if the player's health is greater than 0 or `false` if it is 0 or below. \"\"\"\r\n    return health > 0\r\n",
  "5a5f9f80f5dc3f942b002309": "class Omnibool:\r\n    def __eq__(self, _):\r\n    return True\r\n    omnibool = Omnibool()\r\n",
  "55ee3ebff71e82a30000006a": "def title_to_number(title):\r\n    ret = 0\r\n    for i in title:\r\n    ret = ret * 26 + ord(i) - 64\r\n    return ret\r\n",
  "55968ab32cf633c3f8000008": "def initials(name):\r\n    names = name . split()\r\n    return '.' . join(x[0]. upper() for x in names) + names[- 1][1:]\r\n",
  "55e9529cbdc3b29d8c000016": "def char_to_ascii(string):\r\n    return {c: ord(c) for c in set(string) if c . isalpha()} if len(string) else None\r\n",
  "580755730b5a77650500010c": "def sort_my_string(s):\r\n    return '{} {}' . format(s[:: 2], s[1:: 2])\r\n",
  "55960bbb182094bc4800007b": "import re\n\n\ndef insert_dash(num):\n    # your code here\n    return re . sub(r'([13579])(?=[13579])', r'\\1-', str(num))\n",
  "555de49a04b7d1c13c00000e": "def add(* args):\r\n    return round(sum(x / i for i, x in enumerate(args, 1)))\r\n",
  "555b73a81a6285b6ce000047": "def add(* args):\r\n    return sum(n * i for i, n in enumerate(args, 1))\r\n",
  "575fa9afee048b293e000287": "def how_much_water(water, clothes, load):\r\n    if load > 2 * clothes:\r\n    return \"Too much clothes\"\r\n    if load < clothes:\r\n    return \"Not enough clothes\"\r\n    for i in range(load - clothes):\r\n    water *= 1.1\r\n    return round(water, 2)\r\n",
  "52fba66badcd10859f00097e": "def disemvowel(string):\r\n    return \"\" . join(c for c in string if c . lower() not in \"aeiou\")\r\n",
  "562926c855ca9fdc4800005b": "def number_to_pwr(number, p):\r\n    result = 1\r\n    for i in range(p):\r\n    result *= number\r\n    return result\r\n",
  "58d248c7012397a81800005c": "def cube_checker(volume, side):\r\n    return 0 < volume == side * * 3\r\n",
  "57d29ccda56edb4187000052": "ORDER = \"rock lizard spock scissors paper spock rock scissors lizard paper rock\"\n\n\ndef rpsls(p1, p2):\n    return (\"Player 1 Won!\" if f\" { p1 } { p2 } \" in ORDER\n            else \"Player 2 Won!\" if f\" { p2 } { p1 } \" in ORDER\n            else \"Draw!\")\n",
  "59dd3ccdded72fc78b000b25": "WEEKDAY = {\r\n    1: 'Sunday',\r\n    2: 'Monday',\r\n    3: 'Tuesday',\r\n    4: 'Wednesday',\r\n    5: 'Thursday',\r\n    6: 'Friday',\r\n    7: 'Saturday'}\r\nERROR = 'Wrong, please enter a number between 1 and 7'\r\n\r\n\r\ndef whatday(n):\r\n    return WEEKDAY . get(n, ERROR)\r\n",
  "582e0e592029ea10530009ce": "def duck_duck_goose(players, goose):\r\n    return players[(goose % len(players)) - 1]. name\r\n",
  "51f9d93b4095e0a7200001b8": "def how_many_light_sabers_do_you_own(name=\"\"):\r\n    return (18 if name == \"Zach\" else 0)\r\n",
  "55a5bfaa756cfede78000026": "def problem(a):\r\n    try:\r\n    return a * 50 + 6\r\n    except TypeError:\r\n    return \"Error\"\r\n",
  "56cd44e1aa4ac7879200010b": "def is_uppercase(inp):\r\n    return inp . upper() == inp\r\n",
  "636f26f52aae8fcf3fa35819": "import sys\n# return the total byte size of the object.\n\n\ndef total_bytes(object):\n    return sys . getsizeof(object)\n",
  "578c1e2edaa01a9a02000b7f": "def alias_gen(f_name, l_name):\r\n    try:\r\n        return FIRST_NAME[f_name . upper()[0]] + ' ' + SURNAME[l_name . upper()[0]]\r\n    except:\r\n        return 'Your name must start with a letter from A - Z.'\r\n",
  "55e8aba23d399a59500000ce": "class Hero (object):\n    def __init__(self, name='Hero'):\n    self . name = name\n    self . position = '00'\n    self . health = 100\n    self . damage = 5\n    self . experience = 0\n",
  "514a7ac1a33775cbb500001e": "def mystery():\r\n    return {'sanity': 'Hello'}\r\n",
  "559d2284b5bb6799e9000047": "def add_length(str_):\r\n    return [\"{} {}\" . format(i, len(i)) for i in str_ . split(' ')]\r\n",
  "53f0f358b9cb376eca001079": "class Ball (object):\r\n    def __init__(self, type=\"regular\"):\r\n    self . ball_type = type\r\n",
  "54147087d5c2ebe4f1000805": "def _if(bool, func1, func2):\r\n    func1() if bool else func2()\r\n",
  "534d2f5b5371ecf8d2000a08": "def multiplicationTable(size):\r\n    return [[j * i for j in range(1, size + 1)] for i in range(1, size + 1)]\r\n",
  "5976c5a5cd933a7bbd000029": "MOD = 998244353\n\n\ndef height(n, m):\n    m %= MOD\n    inv = [0] * (n + 1)\n    last = 1\n    ans = 0\n    for i in range(1, n + 1):\n    inv[i] = - (MOD / / i) * inv[MOD % i] % MOD if i > 1 else 1\n    last = last * (m - i + 1) * inv[i] % MOD\n    ans = (ans + last) % MOD\n    return ans\n",
  "563089b9b7be03472d00002b": "class List (object):\r\n    def remove_(self, integer_list, values_list):\r\n    return [i for i in integer_list if i not in values_list]\r\n",
  "5b077ebdaf15be5c7f000077": "def count_sheep(n):\r\n    return '' . join(f\" { i } sheep...\" for i in range(1, n + 1))\r\n",
  "58e09234ca6895c7b300008c": "def palindrome(num, s):\r\n    if not (type(num) == type(s) == int) or num < 0 or s < 0:\r\n    return \"Not valid\"\r\n    ans, num = [], max(num, 11)\r\n    while len(ans) != s:\r\n    if num == int(str(num)[:: - 1]):\r\n    ans . append(num)\r\n    num += 1\r\n    return ans\r\n",
  "58ba6fece3614ba7c200017f": "def palindrome(num):\r\n    if type(num) is not int or num < 1:\r\n    return \"Not valid\"\r\n    return num == int(str(num)[:: - 1])\r\n",
  "52774a314c2333f0a7000688": "def valid_parentheses(string):\n    cnt = 0\n    for char in string:\n    if char == '(':\n        cnt += 1\n    if char == ')':\n        cnt -= 1\n    if cnt < 0:\n        return False\n    return True if cnt == 0 else False\n",
  "586e1d458cb711f0a800033b": "def process_data(data):\r\n    r = 1\r\n    for d in data:\r\n    r *= d[0] - d[1]\r\n    return r\r\n",
  "55eca815d0d20962e1000106": "def generate_range(min, max, step):\r\n    return list(range(min, max + 1, step))\r\n",
  "50654ddff44f800200000007": "def solution(a, b):\r\n    return a + b + a if len(a) < len(b) else b + a + b\r\n",
  "572b77262bedd351e9000076": "def first(seq, n=1):\r\n    return seq[: n]\r\n",
  "55a5befdf16499bffb00007b": "def add(a, b):\r\n    return a + b\r\n    def multiply(a, b):\r\n    return a * b\r\n    def divide(a, b):\r\n    return a / b\r\n    def mod(a, b):\r\n    return a % b\r\n    def exponent(a, b):\r\n    return a * * b\r\n    def subt(a, b):\r\n    return a - b\r\n",
  "5866fc43395d9138a7000006": "def ensure_question(s):\r\n    return s if s . endswith('?') else s + '?'\r\n",
  "570e8ec4127ad143660001fd": "def billboard(name, price=30):\r\n    return sum(price for letter in name)\r\n",
  "57a5b0dfcf1fa526bb000118": "def distinct(seq):\r\n    return sorted(set(seq), key=seq . index)\r\n",
  "56a4addbfd4a55694100001f": "def validate_hello(greetings):\r\n    return any(x in greetings . lower() for x in ['hello', 'ciao', 'salut', 'hallo', 'hola', 'ahoj', 'czesc'])\r\n",
  "57ab3c09bb994429df000a4a": "def two_highest(arg1):\r\n    return sorted(set(arg1), reverse=True)[: 2]\r\n",
  "523b623152af8a30c6000027": "def square(n):\r\n    return n * * 2\r\n",
  "56dae9dc54c0acd29d00109a": "def main(verb, noun):\r\n    return verb + noun\r\n",
  "55cb854deb36f11f130000e1": "def weather_info(temp):\r\n    c = convertToCelsius(temp)\r\n    if (c <= 0):\r\n    return (str(c) + \" is freezing temperature\")\r\n    else:\r\n    return (str(c) + \" is above freezing temperature\")\r\n\r\n    def convertToCelsius(temperature):\r\n    celsius = (temperature - 32) * (5.0 / 9.0)\r\n    return celsius\r\n",
  "5612e743cab69fec6d000077": "a = \"dev\"\nb = \"Lab\"\nname = a + b\n",
  "5a2b703dc5e2845c0900005a": "def is_divide_by(number, a, b):\r\n    return number % a == 0 and number % b == 0\r\n",
  "574b3b1599d8f897470018f6": "def get_real_floor(n):\n    if n <= 0:\n        return n\n    if n < 13:\n        return n - 1\n    if n > 13:\n        return n - 2\n",
  "5834fec22fb0ba7d080000e8": "def six_toast(num):\r\n    return abs(num - 6)\r\n",
  "5ad0d8356165e63c140014d4": "def final_grade(exam, projects):\n    if exam > 90 or projects > 10:\n        return 100\n    if exam > 75 and projects >= 5:\n        return 90\n    if exam > 50 and projects >= 2:\n        return 75\n    return 0\n",
  "572b6b2772a38bc1e700007a": "def uni_total(string):\r\n    return sum(map(ord, string))\r\n",
  "5547929140907378f9000039": "def shortcut(s):\r\n    return '' . join(c for c in s if c not in 'aeiou')\r\n",
  "566dc05f855b36a031000048": "def AddExtra(listOfNumbers):\r\n    return listOfNumbers + [1]\r\n",
  "5dd462a573ee6d0014ce715b": "def same_case(a, b):\r\n    return a . isupper() == b . isupper() if a . isalpha() and b . isalpha() else - 1\r\n",
  "5ab52526379d20736b00000e": "from typing import Tuple\r\nfrom math import ceil\r\nweapons = {\r\n    \"PT92\": 17,\r\n    \"M4A1\": 30,\r\n    \"M16A2\": 30,\r\n    \"PSG1\": 5\r\n}\r\n\r\n\r\ndef mag_number(info: Tuple[str, int]) - > int:\r\n    return ceil(info[1] * 3 / weapons[info[0]])\r\n",
  "524f5125ad9c12894e00003f": "def remainder(a, b):\r\n    if min(a, b) == 0:\r\n    return None\r\n    elif a > b:\r\n    return a % b\r\n    else:\r\n    return b % a\r\n",
  "5748a883eb737cab000022a6": "def cannons_ready(gunners):\r\n    return 'Shiver me timbers!' if 'nay' in gunners . values() else 'Fire!'\r\n",
  "57e3f79c9cb119374600046b": "def hello(name=''):\r\n    return f\"Hello, { name . title () or 'World' } !\"\r\n",
  "5d49c93d089c6e000ff8428c": "def save(sizes, hd):\r\n    for i, s in enumerate(sizes):\r\n    if hd < s:\r\n        return i\r\n    hd -= s\r\n    return len(sizes)\r\n",
  "5a360620f28b82a711000047": "def define_suit(card):\r\n    d = {'C': 'clubs', 'S': 'spades', 'D': 'diamonds', 'H': 'hearts'}\r\n    return d[card[- 1]]\r\n",
  "57fae964d80daa229d000126": "def remove(s):\r\n    return s[: - 1] if s . endswith('!') else s\r\n",
  "5966e33c4e686b508700002d": "def sum_str(a, b):\r\n    return str(int(a or 0) + int(b or 0))\r\n",
  "53da6d8d112bd1a0dc00008b": "def reverse_list(l):\r\n    return l[:: - 1]\r\n",
  "5977618080ef220766000022": "def usdcny(usd):\r\n    return f\" {( usd * 6.75 ): .2 f } Chinese Yuan\"\r\n",
  "521cd52e790405a74800032c": "def wrap(value):\r\n    return {\"value\": value}\r\n",
  "5899642f6e1b25935d000161": "def merge_arrays(arr1, arr2):\r\n    return sorted(set(arr1 + arr2))\r\n",
  "57ee4a67108d3fd9eb0000e7": "geese = {\"African\", \"Roman Tufted\", \"Toulouse\", \"Pilgrim\", \"Steinbacher\"}\r\n\r\n\r\ndef goose_filter(birds):\r\n    return [bird for bird in birds if bird not in geese]\r\n",
  "5741df13077bdf57af00109c": "def find_sum(m):\r\n    p = [0] * (len(m) + 1)\r\n    for l in m:\r\n    for i, v in enumerate(l, 1):\r\n    p[i] = v + max(p[i - 1], p[i])\r\n    return p[- 1]\r\n",
  "534a0c100d03ad9772000539": "class PrimeFactorizer:\r\n\r\n    def __init__(self, num):\r\n    self . factor = {}\r\n    for i in xrange(2, num + 1):\r\n    if (num < i):\r\n    break\r\n    while (num % i == 0):\r\n    num /= i\r\n    self . factor[i] = self . factor . get(i, 0) + 1\r\n",
  "542f3d5fd002f86efc00081a": "def prime_factors(n):\r\n    primes = []\r\n    candidate = 2\r\n    while n > 1:\r\n    while n % candidate == 0:\r\n    primes . append(candidate)\r\n    n /= candidate\r\n    candidate += 1\r\n    return primes\r\n",
  "5500d54c2ebe0a8e8a0003fd": "# Try to make your own gcd method without importing stuff\ndef mygcd(x, y):\n    # GOOD LUCK\n    while y:\n    x, y = y, x % y\n    return x\n",
  "5262119038c0985a5b00029f": "# This is the Miller-Rabin test for primes, which works for super large n\nimport random\n\n\ndef even_odd(n):\n    s, d = 0, n\n    while d % 2 == 0:\n    s += 1\n    d >>= 1\n    return s, d\n    def Miller_Rabin(a, p):\n    s, d = even_odd(p - 1)\n    a = pow(a, d, p)\n    if a == 1:\n        return True\n    for i in range(s):\n    if a == p - 1:\n        return True\n    a = pow(a, 2, p)\n    return False\n    def is_prime(p):\n    if p == 2:\n        return True\n    if p <= 1 or p % 2 == 0:\n        return False\n    return all(Miller_Rabin(random . randint(2, p - 1), p) for _ in range(40))\n",
  "5259acb16021e9d8a60010af": "from math import lcm\n",
  "5f709c8fb0d88300292a7a9d": "def killer(info, dead):\r\n    for name, seen in info . items():\r\n    if set(dead) <= set(seen):\r\n    return name\r\n",
  "58985ffa8b43145ac900015a": "def world_quest():\r\n    world = World()\r\n    world . talk('npc', 'hello')\r\n    world . talk('npc', 'player')\r\n    world . talk('npc', 'yes')\r\n    kill = 0\r\n    while kill < 10:\r\n    world . pickup('rock')\r\n    hit = world . throw('rat')\r\n    if hit:\r\n        kill += 1\r\n    world . talk('npc')\r\n    return world\r\n",
  "55849d76acd73f6cc4000087": "def playerRankUp(pts):\r\n    msg = \"Well done! You have advanced to the qualifying stage. Win 2 out of your next 3 games to rank up.\"\r\n    return msg if pts >= 100 else False\r\n",
  "5b36137991c74600f200001b": "def kill_monsters(health, monsters, damage):\n    hits = (monsters - 1) / / 3\n    damage *= hits\n    health -= damage\n    return f'hits: { hits } , damage: { damage } , health: { health } ' if health > 0 else 'hero died'\n",
  "56170e844da7c6f647000063": "def people_with_age_drink(age):\n    if age > 20:\n        return 'drink whisky'\n    if age > 17:\n        return 'drink beer'\n    if age > 13:\n        return 'drink coke'\n    return 'drink toddy'\n",
  "5a5032f4fd56cb958e00007a": "KEYBOARD = \"abcde123fghij456klmno789pqrst.@0uvwxyz_/\"\r\nMAP = {c: (i / / 8, i % 8) for i, c in enumerate(KEYBOARD)}\r\n\r\n\r\ndef manhattan(* pts): return sum(abs(z2 - z1) for z1, z2 in zip(* pts))\r\n\r\n\r\ndef tv_remote(word):\r\n    return len(word) + sum(manhattan(MAP[was], MAP[curr]) for was, curr in zip('a' + word, word))\r\n",
  "52998bf8caa22d98b800003a": "def manhattan_distance(pointA, pointB):\r\n    return abs(pointA[0] - pointB[0]) + abs(pointA[1] - pointB[1])\r\n",
  "5697fb83f41965761f000052": "def filter_long_words(sentence, long):\r\n    return [word for word in sentence . split() if len(word) > long]\r\n",
  "52742f58faf5485cae000b9a": "times = [(\"year\", 365 * 24 * 60 * 60), \n         (\"day\", 24 * 60 * 60),\n         (\"hour\", 60 * 60),\n         (\"minute\", 60),\n         (\"second\", 1)]\n\ndef format_duration(seconds):\n\n    if not seconds:\n        return \"now\"\n\n    chunks = []\n    for name, secs in times:\n        qty = seconds // secs\n        if qty:\n            if qty > 1:\n                name += \"s\"\n            chunks.append(str(qty) + \" \" + name)\n\n        seconds = seconds % secs\n\n    return ', '.join(chunks[:-1]) + ' and ' + chunks[-1] if len(chunks) > 1 else chunks[0]",
  "53ee5429ba190077850011d4": "def doubleInteger(i):\r\n    return i * 2\r\n",
  "65112af7056ad6004b5672f8": "def possibly_perfect(key, answers):\n    a = [k==a for k, a in zip(key, answers) if k!='_']\n    return all(a) or not any(a)",
  "660595d3bd866805d00ec4af": "def longest_mountain_pass(mountains, E):\r\n    n = len(mountains)\r\n    if n < 2:\r\n    if n == 0:\r\n    return (0, 0)\r\n    else:\r\n        return (1, 0)\r\n\r\n    # Precompute energy costs\r\n    energy_cost = [0] * n\r\n    for i in range(1, n):\r\n    energy_cost[i] = max(0, mountains[i] - mountains[i - 1]\r\n                         ) + energy_cost[i - 1]\r\n\r\n    # Sliding window\r\n    max_length = 0\r\n    start_index = 0\r\n    left = 0\r\n    for right in range(n):\r\n    while energy_cost[right] - (energy_cost[left] if left > 0 else 0) > E:\r\n    left += 1\r\n    if right - left + 1 > max_length:\r\n    max_length = right - left + 1\r\n    start_index = left\r\n    return (max_length, start_index)\r\n",
  "65eb2c4c274bd91c27b38d32": "from gmpy2 import next_prime\r\nfrom bisect import bisect_left, bisect_right\r\nPS, L, P = [], 1e18, 2\r\nwhile True:\r\n    Q = P * * 4\r\n    PS . append(Q)\r\n    P = next_prime(P)\r\n    if Q > L:\r\n    break\r\n    def solution(n, m):\r\n    i = bisect_left(PS, n)\r\n    j = bisect_right(PS, m)\r\n    return PS[i: j]\r\n",
  "660e5631b673a8004b71d208": "def continued_fraction(nu: int, de: int) - > list[int]:\r\n    l = []\r\n    while nu and de:\r\n    l . append(nu / / de)\r\n    nu, de = de, nu % de\r\n    return l\r\n",
  "660d55d0ba01e5016c85cfeb": "slice = f = lambda a, b: a * (a == b) or f(a, chr(ord(b) - 1)) + b\n",
  "660323a44fe3e41cff41e4e9": "def findpos(n, t):\r\n    z = 0 in t\r\n    b = len(t)\r\n    m = {x: y for x, y in zip(sorted(t), range(1 - z, b + 1 - z))}\r\n    s, i = 0, 0\r\n    while n > 0:\r\n    n, d = divmod(n, 10)\r\n    s += b * * i * m[d]\r\n    i += 1\r\n    return s + z\r\n",
  "65fc93001bb13a2074cb4ee8": "from bisect import bisect_left as bl\r\nfrom bisect import bisect_right as br\r\n\r\n\r\ndef f(a, n):\r\n    p = [0 for e in a]\r\n    q = [len(e) for e in a]\r\n    for i, e in enumerate(a):\r\n    while p[i] < q[i]:\r\n    m = (p[i] + q[i]) >> 1\r\n    x = sum(bl(f, e[m]) for f in a)\r\n    y = sum(br(f, e[m]) for f in a)\r\n    if x <= n < y:\r\n        return e[m]\r\n    elif x > n:\r\n        q[i] = m\r\n    else:\r\n        p[i] = m + 1\r\n\r\n    def median_from_n_arrays(a):\r\n    n = sum(len(e) for e in a)\r\n    return (f(a, n >> 1) + f(a, (n - 1) >> 1)) / 2\r\n",
  "65f8279c265f42003ffbd931": "def plus_or_minus(vs, test):\r\n    d = (test([2 * * i for i, _ in enumerate(vs)]) + (2 * * len(vs) - 1)) / / 2\r\n    return '' . join('-+' [d >> i & 1] + c for i, c in enumerate(vs)). lstrip('+')\r\n",
  "65f1c009e44a0f0777c9fa06": "def operation_arguments(arr):\r\n    result = []\r\n\r\n    for val in arr:\r\n    if callable(val):\r\n    result . append(val(result . pop() if result else 0))\r\n    else:\r\n    result . append(val)\r\n    return result\r\n",
  "65ee024f99785f0906e65bee": "def bump_counter(ants):\r\n    res = []\r\n    n, c = ants . count(\"L\"), 0\r\n    for i, d in enumerate(ants):\r\n    t = (i < n) - (d == \"L\")\r\n    res . append(2 * c + t)\r\n    c += t\r\n    return \" \" . join(map(str, res))\r\n",
  "65ee35959c3c7a2b4f8d79c1": "def count_time_loops(menu, a, b):\r\n    # Initialize a dynamic programming table\r\n    dp = [0] * (b + 1)\r\n    dp[0] = 1  # Base case: 1 way to achieve cost 0 (empty meal)\r\n    # Iterate over each dish cost in the menu\r\n    for cost in menu:\r\n        # Update the dynamic programming table from right to left\r\n    for i in range(b, cost - 1, - 1):\r\n    dp[i] += dp[i - cost]\r\n\r\n    # Calculate the total combinations within the specified cost range\r\n    total_combinations = sum(dp[a: b + 1])\r\n\r\n    return total_combinations\r\n",
  "65e8b02a9e79a010e5210b6c": "# Just imagine a straight line on a lattice of infinite copies of the TV.\nfrom math import gcd\n\n\ndef will_hit_corner(w, h, x, y, dir):\n    if dir == \"NE\" or dir == \"SW\":\n    slope = 1\n    else:\n    slope = - 1\n    return (y - slope * x) % gcd(w, h) == 0\n",
  "65e594c5a93ef700294ced80": "def painted_faces(sides, n):\r\n    if sides == 0:\r\n    return 0\r\n    elif sides == 1:\r\n    if n == 6:\r\n    return 1\r\n    else:\r\n    return 0\r\n    else:\r\n    if n == 0:\r\n    return (sides - 2) * * 3  # inside cubes\r\n    elif n == 1:\r\n    return 6 * (sides - 2) * * 2  # face cubes\r\n    elif n == 2:\r\n    return 12 * (sides - 2)  # rib cubes\r\n    elif n == 3:\r\n    return 8  # corner cubes\r\n    else:\r\n    return 0\r\n",
  "65e2df8302b29a005831eace": "def hit(l):\r\n    return l % 5\r\n",
  "65e0fa45446dba00143d3744": "import math\n\n\ndef get_rectangle_ratio(n):\n    return (n + math . sqrt(n * n + 4)) / 2\n",
  "65de16794ccda6356de32bfa": "from collections import Counter\r\nfrom random import randrange\r\nfrom math import gcd, lcm, log, log2\r\n\r\n\r\ndef miller_rabin_test(n):\r\n    if n < 2 or not n % 2 or not n % 3:\r\n    return n in (2, 3)\r\n    k, r, d = 5, 0, n - 1\r\n    while d % 2 == 0:\r\n    d / /= 2\r\n    r += 1\r\n    while k >= 1:\r\n    k -= 1\r\n    a = randrange(2, n - 1)\r\n    x = pow(a, d, n)\r\n    if x == 1 or x == n - 1:\r\n    continue\r\n    m = r - 1\r\n    while m >= 1:\r\n    m -= 1\r\n    x = pow(x, 2, n)\r\n    if x == n - 1:\r\n    break\r\n    else:\r\n    return False\r\n    return True\r\n    def is_prime(n):\r\n    return miller_rabin_test(n)\r\n\r\n    def pollard_rho(n):\r\n    while True:\r\n    x, c = randrange(1, n), randrange(1, n)\r\n    def f(x): return (x * x + c) % n\r\n    y = f(x)\r\n    while (d := gcd(abs(x - y), n)) == 1:\r\n    x, y = f(x), f(f(y))\r\n    if d != n:\r\n    return d\r\n    def factor(n):\r\n    if is_prime(n):\r\n        return Counter([n])\r\n    return factor(r := pollard_rho(n)) + factor(n / / r)\r\n\r\n    def divisor(n, psm):\r\n    ps = []\r\n    for p, k in psm . items():\r\n    for i in range(k):\r\n    ps . append(p)\r\n    ds = set([1, n])\r\n    def go(i, d):\r\n    if i < len(ps):\r\n    ds . add(d * ps[i])\r\n    go(i + 1, d)\r\n    go(i + 1, d * ps[i])\r\n    go(0, 1)\r\n    return sorted(list(ds))\r\n\r\n    def binary_raise(n, p):\r\n    r = 1\r\n    while p > 0:\r\n    if (p & 1) == 1:\r\n    r *= n\r\n    p >>= 1\r\n    n *= n\r\n    return r\r\n    def ext_euclidean(a, b):\r\n    x, y, u, v = 0, 1, 1, 0\r\n    while a != 0:\r\n    q, r = b / / a, b % a\r\n    m, n = x - u * q, y - v * q\r\n    a, b, x, y, u, v = r, a, u, v, m, n\r\n    return b, x, y\r\n    def fast_mul(a, b, p):\r\n    q, r = a\r\n    s, t = b\r\n    x = q * s + 5 * r * t\r\n    y = q * t + r * s\r\n    return (x % p, y % p)\r\n\r\n    def fast_plus(a, n, p):\r\n    r = (1, 0)\r\n    while n > 0:\r\n    if (n & 1) == 1:\r\n    r = fast_mul(r, a, p)\r\n    n >>= 1\r\n    a = fast_mul(a, a, p)\r\n    return r\r\n    def fib_mod(n, p):\r\n    _, q, _ = ext_euclidean(pow(2, n, p), p)\r\n    q %= p\r\n    ns = fast_plus((1, 1), n, p)\r\n    return fast_mul(ns, (q, 0), p)\r\n\r\n    def prime_pisano(n):\r\n    if n == 2:\r\n        return 3\r\n    r = n % 5\r\n    q = 4 * n if not r else n - 1 if r in (1, 4) else 2 * (n + 1)\r\n    if not r:\r\n        return q\r\n    ps = factor(q)\r\n    ds = divisor(q, ps)\r\n    for d in ds:\r\n    if fib_mod(d, n) == (1, 0):\r\n    return d\r\n    def composite_pisano(n):\r\n    ps, m = factor(n), 1\r\n    for p, k in ps . items():\r\n    m = lcm(m, binary_raise(p, k - 1) * prime_pisano(p))\r\n    return m\r\n    def pisano_period(n):\r\n    if n == 1:\r\n        return 1\r\n    eps, p2, p5 = 1e-9, log2(n), log(n) / log(5)\r\n    if p2 % 1 < eps:\r\n        return 3 * (2 * * (round(p2) - 1))\r\n    if p5 % 1 < eps:\r\n        return 4 * (5 * * round(p5))\r\n    return composite_pisano(n)\r\n\r\n    # initial method name of the kata\r\n    PisanoPeriod = pisano_period\r\n",
  "65dd5b414ccda60a4be32c2a": "def gaslighting(s, y, f):\r\n    return any(a != b and (a in f or b in f) for a, b in zip(s, y))\r\n",
  "65dc66fc48727d28ac00db5c": "from preloaded import symbols, valency\r\nfrom math import gcd\r\n\r\n\r\ndef create_compound(name):\r\n    ind = {1: '', 2: '\u2082', 3: '\u2083', 4: '\u2084'}\r\n    cmps = name . split()\r\n    s1, s2 = map(symbols . get, cmps)\r\n    v1, v2 = map(valency . get, cmps)\r\n\r\n    g = gcd(v1, v2)\r\n    v1, v2 = v1 / / g, v2 / / g\r\n\r\n    def comp(s, v): return f' { s }{ v } ' if sum(x . isupper()\r\n                                                  for x in s) < 2 or v == '' else f'( { s } ) { v } '\r\n    return f' { comp ( s1 , ind [ v2 ])}{ comp ( s2 , ind [ v1 ])} '\r\n",
  "62f17be8356b63006a9899dc": "def trilingual_democracy(group: str) - > str:\r\n\r\n    _set = set(group)\r\n\r\n    if len(_set) == 1:\r\n        return group[0]\r\n    if len(_set) == 3:\r\n        return next(iter(set('DFIK') - _set))\r\n\r\n    return min(group, key=group . count)\r\n",
  "65d81be5ac0d2ade3a6c637b": "def or_sum(n: int) - > int:\r\n    return n * * 2 + sum(n >> i + 1 << 2 * i for i in range(n . bit_length()) if not 1 << i & n)\r\n",
  "65d5cf1eac0d2a6c4f6c60e6": "from preloaded import atomic_masses\r\n\r\n\r\ndef count_the_moles(mass_of_substance: float, chemical_formula: str):\r\n    mole_mass = 0\r\n    for i, x in enumerate(chemical_formula):\r\n    if x . isalpha():\r\n    if i + 1 <= len(chemical_formula) - 1 and chemical_formula[i + 1]. isdigit():\r\n    mole_mass += atomic_masses[x] * int(chemical_formula[i + 1])\r\n    else:\r\n    mole_mass += atomic_masses[x]\r\n    return mass_of_substance / mole_mass\r\n",
  "65d4d2c4e2b49c3d1f3c3aec": "def fibs(limit):\r\n    a, b, res = 2, 3, []\r\n    while a <= limit:\r\n    res . append(a)\r\n    a, b = b, a + b\r\n    return res\r\n    FIB = fibs(10 * * 36)\r\n\r\n    from functools import cache\r\n    @ cache\r\n    def fib_prod(n: int, m: int = 1) - > int:\r\n    return 1 if n == 1 else sum(fib_prod(n / / d, d) for d in FIB if d >= m and n % d == 0)\r\n",
  "65d2460f512ea70058594a3d": "from collections import Counter\r\n\r\n\r\ndef last_non_empty_string(s: str) - > str:\r\n    x = Counter(s)\r\n    l = max(x . values()) - 1\r\n    for w in x:\r\n    s = s . replace(w, '', l)\r\n    return s\r\n",
  "65cf8417e2b49c2ecd3c3aee": "def zeros(n: int) - > int:\r\n    a, b = 1, 1\r\n    for _ in range(n - 2):\r\n    a, b = a + b, a\r\n    return a + b\r\n",
  "65d06e5ae2b49c47ee3c3fec": "def comb(n, k): return (b: = 2 << n | 1) * * n >> n * k + k & b - 2\n",
  "65c9562f4e43b28c4c426c93": "def find_n(d, t, l):\r\n    if l == 1:\r\n    r = d . get(t)\r\n    return [r] if r else []\r\n\r\n    for k, v in d . items():\r\n    if k >= t:\r\n        continue\r\n    r = find_n(d, t - k, l - 1)\r\n    if r:\r\n        return r + [v]\r\n\r\n    return []\r\n\r\n    def make_cocktail(ingr: dict[int], flav: int, bittersw: int) - > list[str]:\r\n    if not isinstance(ingr, dict):\r\n        return []\r\n\r\n    pos = {}\r\n    min = {}\r\n\r\n    for k, v in ingr . items():\r\n    if v < 0:\r\n        min[- v] = k\r\n    else:\r\n        pos[v] = k\r\n    for i in range(6):\r\n    f = find_n(pos, bittersw + (flav >= 0 and flav), i) if i else []\r\n    m = find_n(min, bittersw - (flav < 0 and flav), 5 - i) if i else []\r\n\r\n    if len(f) == i and len(m) == 5 - i:\r\n        return f + m\r\n    return []\r\n",
  "65cdd06eac0d2ad8ee6c6067": "def nth_term_of_the_fibonacci_sequence(n): return pow(m: = 2 << n, n, m * m + ~ m) / / m\n",
  "65cb9ddfac0d2a5d6e6c6150": "A = {x + y for y in \"1 2 3 4 5 6 7 8 9 10 J Q K\" . split() for x in \"HSDC\"}\r\n\r\n\r\ndef pick_em_up(pile):\r\n    p = {y for x in pile for y in x}\r\n    return all(c in p for c in A)\r\n",
  "65cb0451ac0d2a381c6c617f": "def get_options_count(target, arr):\r\n    options = [1]\r\n    for n in range(1, len(target) + 1):\r\n    options . append(sum(options[- len(s)]\r\n                     for s in arr if target[- n:]. startswith(s)))\r\n    return options[- 1]\r\n",
  "65c8e72d63fd290058026075": "from itertools import cycle\n\n\ndef round_robin(* gens):\n    msg = None\n    for gen in cycle(gens):\n    msg = yield gen . send(msg)\n",
  "65c6fa8551327e0ac12a191d": "import datetime\r\n\r\n\r\ndef next_good_time(current_time):\r\n    d = datetime . datetime . strptime(current_time, \"%H:%M:%S\")\r\n    while True:\r\n    d += datetime . timedelta(seconds=1)\r\n    if any([\r\n        d . minute * 2 == d . hour +\r\n        d . second and d . minute - d . hour in [1, 2],\r\n        d . minute * 2 == d . hour + d . second and d . minute % 10 == d . hour % 10,\r\n        d . minute * 2 == d . hour + d . second and 2 * d . hour == d . minute,\r\n        d . time(). isoformat() == d . time(). isoformat()[\r\n            :: - 1] and len(set(d . time(). isoformat())) == 3,\r\n        d . time(). isoformat() == \"12:34:56\",\r\n    ]):\r\n    return d . time(). isoformat()\r\n",
  "65c6836293e1c2b881e67f33": "from itertools import accumulate\r\n\r\n\r\ndef ways_in_3d_matrix(x, y, z):\r\n    x, y, z = sorted((x, y, z))\r\n\r\n    layer = [[int(j == 0 or k == 0) for k in range(z)] for j in range(y)]\r\n    for j in range(1, y):\r\n    for k in range(1, z):\r\n    layer[j][k] = layer[j - 1][k] + layer[j][k - 1]\r\n\r\n    seq = [1] * (y + z - 1)\r\n    for _ in range(x - 1):\r\n    seq = [* accumulate(seq)]\r\n\r\n    return layer[- 1][- 1] * seq[- 1]\r\n",
  "65c06522275fa5b2169e9998": "def expected_speedrun_time(times, probs):\n    tot_prob, tot_time, expected = 1, 0, 0\n    for t, p in zip(times, probs):\n    expected += (tot_time + t / 2) * (tot_prob) * (1 - p)\n    tot_time += t\n    tot_prob *= p\n    expected /= tot_prob\n    expected += tot_time\n    return expected\n",
  "6590b70c3109bcf9c12624a5": "def f(x, y): return (y - x + 5) % 10 - 5\n",
  "65c0161a2380ae78052e5731": "def stone_pick(arr):\r\n    stick = arr . count('Sticks') + arr . count('Wood') * 4\r\n    cobble = arr . count('Cobblestone')\r\n    return (min(cobble / / 3, stick / / 2))\r\n",
  "65ba420888906c1f86e1e680": "def collinearity(x1, y1, x2, y2):\r\n    return x1 * y2 == x2 * y1\r\n",
  "65b745d697eea38e8bcfb470": "from collections import deque\r\n\r\n\r\ndef find_win(placements, total):\r\n    c, t, q = 0, ((1 << total) - 1) << 1, deque(maxlen=total)\r\n    for i, v in enumerate(placements):\r\n    c += 1 << v\r\n    if i >= total:\r\n        c -= 1 << q[0]\r\n    if c == t:\r\n        return i\r\n    q . append(v)\r\n",
  "65b3fdc2df771d0010b9c3d0": "def cube_matrix_sum(x): return sum(sum(sum(x, []), []))\n",
  "65ad9094c5a34200245f3a8f": "from gmpy2 import is_prime\nM, L = 1000000007, 3000000\nPRIMES = [n for n in range(L) if is_prime(n)]\n\n\ndef smallest_multiple(n):\n    t = 1\n    for p in PRIMES:\n    if p > n:\n        break\n    for q in range(1, n + 1):\n    if p * * q > n:\n    t = (t * pow(p, q - 1, M)) % M\n    break\n    return t\n",
  "65a1cc718041f7000f928457": "def balanced_base_nine(num):\r\n    base_nine = []\r\n    while num:\r\n    d = num % 9\r\n    base_nine . append('01234^%$\u00a3' [d])\r\n    num = num / / 9 + (d > 4)\r\n    return '' . join(reversed(base_nine)) or '0'\r\n",
  "65a024af6063fb0ac8c0f0b5": "def has_scored(s):\r\n    balls = sorted(s . find(b) for b in 'RWY')\r\n    return balls[1] >= 0 and sum(c in 'nesw' for c in s[: balls[2]]) >= 3\r\n",
  "659af96994b858db10e1675f": "def find(string):\r\n    num = int(string[0])\r\n    ans = num\r\n    i = 1\r\n    test = str(num)\r\n    while test != string:\r\n    if test == string[: len(test)]:\r\n    num += 1\r\n    test += str(num)\r\n    else:\r\n    i += 1\r\n    num = int(string[: i])\r\n    ans = num\r\n    test = str(num)\r\n\r\n    return ans\r\n",
  "658fb5effbfb3ad68ab0951d": "def score(numbers):\r\n    sn = sum(numbers)\r\n    return sum(x * (sn - x) for x in numbers) / / 2\r\n",
  "6582ce1afbfb3a604cb0b798": "def type_out(s):\r\n    res, pointer, i = [], 0, 0\r\n    while i < len(s):\r\n    if s[i] in '<>':\r\n    func = s[i]\r\n    i += 1\r\n    times = 1\r\n    if i < len(s) and s[i] == '*':\r\n    i += 1\r\n    times = 0\r\n    while i < len(s) and s[i]. isdigit():\r\n    times = times * 10 + int(s[i])\r\n    i += 1\r\n    if func == '<':\r\n    pointer = max(0, pointer - times)\r\n    else:\r\n    pointer = min(len(res), pointer + times)\r\n    else:\r\n    res . insert(pointer, s[i])\r\n    pointer += 1\r\n    i += 1\r\n    return '' . join(res)\r\n",
  "6585960dfbfb3afd22b0a1fe": "def converging_journeys(n):\r\n    j = {1: 1, 3: 3, 9: 9}\r\n    while n:\r\n    for k in j:\r\n    while j[k] < n:\r\n        j[k] += sum(map(int, str(j[k])))\r\n    if j[k] == n:\r\n        return (k, n)\r\n    n += sum(map(int, str(n)))\r\n",
  "6584b7cac29ca91dd9124009": "def convert_lojban(lojban):\r\n    return int(lojban . translate(str . maketrans('nprcvmxzbs', '0123456789', 'aeiou')))\r\n",
  "6582206efbfb3a604cb0a6fe": "def checksum(isbn):\r\n    # calculate checksum\r\n    return sum((10 - i) * (10 if d == \"X\" else int(d)) for i, d in enumerate(isbn))\r\n\r\n    def fix_code(isbn):\r\n        # try all possible digits\r\n    for digit in \"0123456789X\":\r\n    fixed_isbn = isbn . replace(\"?\", digit)\r\n    if checksum(fixed_isbn) % 11 == 0:\r\n    return digit\r\n",
  "657e2e36fbfb3ac3c3b0a1fb": "from datetime import datetime, timedelta\r\nREF = datetime(2000, 1, 1)\r\n\r\n\r\ndef convert_mayan(date):\r\n    baktun, katun, tun, uinal, kin = [int(x) for x in date . split()]\r\n    return (REF + timedelta(days=kin + 20 * (uinal + 18 * (tun + 20 * (katun + 20 * baktun))) - 2018843)). strftime('%-d %-m %Y')\r\n",
  "6574d1bde7484b5a56ec8f29": "def min_repeating_character_difference(text):\r\n    for i in range(1, len(text)):\r\n    for a, b in zip(text, text[i:]):\r\n    if a == b:\r\n    return i, a\r\n",
  "65781071e16df9dcbded1520": "def teknonymize(t) - > None:\r\n    if t['children']:\r\n    g, d = min([teknonymize(c) for c in t['children']],\r\n               key=lambda a: (- a[0], a[1]['date_of_birth']))\r\n    t['teknonym'] = 'great-' * (g - 2) + 'grand' * (g > 1) + \\\r\n        ['mother', 'father'][t['sex'] == 'm'] + ' of ' + d['name']\r\n    return g + 1, d\r\n    else:\r\n    return 1, t\r\n",
  "6573331997727a18c8f82030": "import re\n\n\ndef type_out(s):\n    clipboard = \"\"\n    def paste(m):\n    nonlocal clipboard\n    copy = m[1]\n    if not copy:\n        return clipboard\n    if copy . isdigit():\n        return int(copy) * clipboard\n    return (clipboard := copy)\n\n    return re . sub(r'\\[([^]]*)\\]', paste, s)\n",
  "656e4602ee72af0017e37e82": "def cuckoo_clock(t, n):\n    # around-the-clock optimization (=> O(1) runtime)\n    n = n % 114 if n > 114 + 15 else n\n    h, m = map(int, t . split(':'))\n    t = h % 12 * 60 + m\n    while True:\n    k = t / / 60 or 12 if t % 60 == 0 else t % 15 == 0\n    if n <= k:\n        return f\" { t / / 60 or 12 :0 2 d } : { t % 60 :0 2 d } \"\n    n, t = n - k, (t + 1) % (12 * 60)\n",
  "656f6f96db71be286d8f5c6b": "def divisors(n: int) - > list[int]:\n    solution: list[int] = [1]\n    currentDivisor: int = 2\n    while n > 1:\n    index: int = 0\n    while not n % currentDivisor:\n    n / /= currentDivisor\n    length: int = len(solution)\n    for i in range(index, length):\n    index = length\n    solution . append(currentDivisor * solution[i])\n\n    currentDivisor += 1\n    # the list is already close to sorted so this isnt very expensive\n    return sorted(solution)\n\n    # this second solution is very close to the first, and doest reliably speed up the kata tests\n    # def divisors(n: int) -> list[int]:\n    # solution: list[int] = [1]\n    # # doing multiples of two first allows skipping current divisor by 2 later\n    # i:int = 1\n    # while not n % 2:\n    # n //= 2\n    # solution.append(2**i)\n    # i+=1\n    # currentDivisor: int = 3\n    # while n > 1:\n    # index: int = 0\n    # while not n % currentDivisor:\n    # n //= currentDivisor\n    # length: int = len(solution)\n    # for i in range(index, length):\n    # index = length\n    # solution.append(currentDivisor * solution[i])\n    # currentDivisor += 2\n    # the advantage of skipping current divisor by 2 is offset by having slower sorting since it is further from the sorted solution\n    # return sorted(solution)\n",
  "6565070e98e6731c13882aa0": "from collections import Counter\r\nfrom itertools import pairwise\r\nfrom math import prod\r\n\r\n\r\ndef find_ways(initial_num, target_num, must_include=None, must_avoid=None):\r\n    numbers = [initial_num, * sorted(must_include or []), target_num]\r\n    must_avoid = {* must_avoid} if must_avoid else set()\r\n    return prod(ways(start, stop, must_avoid) for start, stop in pairwise(numbers))\r\n\r\n    def ways(start, stop, must_avoid):\r\n    numbers = Counter((start,))\r\n    while numbers:\r\n    n = min(numbers)\r\n    k = numbers . pop(n)\r\n    if n == stop:\r\n    return k\r\n    for m in n + 3, n + sum(map(int, str(abs(n)))), n + n % 4:\r\n    if n < m <= stop and m not in must_avoid:\r\n    numbers[m] += k\r\n    return 0\r\n",
  "6562d61a9b55884c720e2556": "def gauss_seidel(c):\r\n    x = y = z = i = 0\r\n    while i == 0 or any(abs(d) > 0.0001 for d in (x - ox, y - oy, z - oz)):\r\n    ox, oy, oz = x, y, z\r\n    x = (c[0][3] - c[0][1] * y - c[0][2] * z) / c[0][0]\r\n    y = (c[1][3] - c[1][0] * x - c[1][2] * z) / c[1][1]\r\n    z = (c[2][3] - c[2][0] * x - c[2][1] * y) / c[2][2]\r\n    i += 1\r\n    return [x, y, z], i\r\n",
  "653888111746620b77a3ccd5": "def choose_king_moves(king, knight, n):\r\n    c = king[0]. translate(str . maketrans('abcdefgh', 'babcdefg'))\r\n    r = (int(king[1]) - 1) & 6 | (ord(c) ^ ord(knight[0]) ^ ord(knight[1])) & 1\r\n    return [f' { c }{( r ^ ( k & 1 )) + 1 } ' for k in range(n)]\r\n",
  "65579292e361e60e202906f4": "from functools import reduce\r\nfrom collections import deque\r\nimport re\r\nOPS = {\r\n    'not': lambda x: 'T' if x == 'F' else 'F' if x == 'T' else 'U',\r\n    'xor': lambda a, b: 'U' if 'U' in (a, b) else 'F' if a == b else 'T',\r\n    'and': lambda a, b: 'T' if 'T' == a == b else 'F' if 'F' in (a, b) else 'U',\r\n    'or': lambda a, b: 'T' if 'T' in (a, b) else 'F' if 'F' == a == b else 'U',\r\n}\r\nVALUES = dict(zip('TUF', (1, 0, - 1)))\r\n\r\n\r\ndef bin_op(op, next_op):\r\n    def parser(q):\r\n    elt = next_op(q)\r\n    while q and q[0] == op:\r\n    q . popleft()\r\n    v = next_op(q)\r\n    elt = OPS[op](elt, v)\r\n    return elt\r\n    return parser\r\n    def parse_term(q):\r\n    elt = q . popleft()\r\n    match elt:\r\n    case '(':\r\n    elt = expression(q)\r\n    assert q . popleft() == ')'\r\n    return elt\r\n    case 'not':\r\n    v = parse_term(q)\r\n    out = OPS[elt](v)\r\n    return out\r\n    case _:\r\n    return elt\r\n    expression = reduce(lambda f, op: bin_op(\r\n        op, f), 'and xor or' . split(), parse_term)\r\n    tokenizer = re . compile(r'|' . join(OPS) + r'|\\S')\r\n\r\n    def threevl(s):\r\n    lst = tokenizer . findall(s)\r\n    q = deque(lst)\r\n    out = expression(q)\r\n    return VALUES[out]\r\n",
  "58aa8b0538cf2eced5000115": "def exchange_sort(sequence):\r\n    x = 0\r\n    y = 0\r\n    for f, g in zip(sequence, sorted(sequence)):\r\n    if f < g:\r\n    x += 1\r\n    elif f > g:\r\n    y += 1\r\n    return max(x, y)\r\n",
  "5d06938fcac0a5001307ce57": "def golomb(given, n):\r\n    res, idx, seq = [], 0, iter(given)\r\n    if (x := next(seq)) != 0:\r\n    res, idx = [x] * x, 1\r\n    elif (x := next(seq)) != 1:\r\n    res, idx = [x] * 2 + [0] * x + [x] * (x - 2), 2\r\n    else:\r\n    res, idx = [1, (x := next(seq)), 1, 0] + [1] * (x - 2), 3\r\n    while len(res) < n and (x := next(seq)):\r\n    if idx < len(res):\r\n    res += [x] * res[idx]\r\n    else:\r\n    res += [x] * x\r\n    idx += 1\r\n    return res[: n]\r\n",
  "65553172219a8c8e263b58ff": "from textwrap import fill\n\n\ndef hex_to_bitmap(h):\n    return fill(f' { int ( h , 16 ):0 128 b } ', 8)\n",
  "5bc6f9110ca59325c1000254": "from collections import defaultdict\r\n\r\n\r\ndef count(chessBoard):\r\n    # Initialize:\r\n    board = chessBoard . copy()\r\n    tally = defaultdict(int)\r\n\r\n    # Compute Longest square ending in bottom right corner of each element and tally up:\r\n    for i, row in enumerate(board):\r\n    for j, element in enumerate(row):\r\n        # Edge detection:\r\n    if i == 0 or j == 0:\r\n    continue\r\n    # Compute & Tally:\r\n    if element:\r\n    n = board[i][j] = min(board[i - 1][j], board[i]\r\n                          [j - 1], board[i - 1][j - 1]) + 1\r\n    for x in range(n, 1, - 1):\r\n    tally[x] += 1\r\n    return tally\r\n",
  "5f24315eff32c4002efcfc6a": "from collections import defaultdict\r\n\r\n\r\ndef setter(prep, k, v, supSetter):\r\n    if callable(v):\r\n    def wrap(* args):\r\n    f = prep . d[k][len(args)]\r\n    if isinstance(f, int):\r\n        raise AttributeError()\r\n    return f(* args)\r\n    prep . d[k][v . __code__ . co_argcount] = v\r\n    v = wrap\r\n    supSetter(k, v)\r\n\r\n    class Prep (dict):\r\n    def __init__(self): self . d = defaultdict(lambda: defaultdict(int))\r\n    def __setitem__(self, k, v): setter(self, k, v, super(). __setitem__)\r\n\r\n    class Meta (type):\r\n    @ classmethod\r\n    def __prepare__(cls, * args, * * kwds): return Prep()\r\n\r\n    def __new__(metacls, name, bases, prep, * * kwargs):\r\n    prep['_Meta__DCT'] = prep\r\n    return super(). __new__(metacls, name, bases, prep, * * kwargs)\r\n\r\n    def __setattr__(self, k, v): setter(\r\n        self . __DCT, k, v, super(). __setattr__)\r\n",
  "63cb1c38f1504e1deca0f282": "def dequeue_count(queues):\r\n    return sum(len(q) - next((j for j, v in enumerate(q) if v != i), len(q))\r\n               for i, q in enumerate(queues))\r\n",
  "5b3bec086be5d8893000002e": "''' \r\n WARNING: EXTREMELY BAD PRACTICE ALERT \r\n DO NOT DO THIS IF YOU ARE WORKING ON A PROJECT \r\n ALTHOUGH HARD CODING CAN SOMETIMES MAKE CODE RUN FASTER, IT MAKES IT MESSY AND UNREADABLE \r\n '''\r\nrotate_face_idx = [* zip(range(1, 10), [7, 4, 1, 8, 5, 2, 9, 6, 3])]\r\n\r\n\r\ndef increase_idx(idx, n): return [\r\n    (start + n, changed + n) for start, changed in idx]\r\n\r\n\r\nU_turn_idx = rotate_face_idx + [(10, 19), (11, 20), (12, 21), (19, 28), (20, 29),\r\n                                (21, 30), (28, 37), (29, 38), (30, 39), (37, 10), (38, 11), (39, 12)]\r\nL_turn_idx = increase_idx(rotate_face_idx, 9) + [(1, 45), (4, 42), (7, 39), (\r\n    19, 1), (22, 4), (25, 7), (39, 52), (42, 49), (45, 46), (46, 19), (49, 22), (52, 25)]\r\nF_turn_idx = increase_idx(rotate_face_idx, 18) + [(7, 18), (8, 15), (9, 12), (\r\n    12, 46), (15, 47), (18, 48), (28, 7), (31, 8), (34, 9), (46, 34), (47, 31), (48, 28)]\r\nR_turn_idx = increase_idx(rotate_face_idx, 27) + [(3, 21), (6, 24), (9, 27), (\r\n    21, 48), (24, 51), (27, 54), (37, 9), (40, 6), (43, 3), (48, 43), (51, 40), (54, 37)]\r\nB_turn_idx = increase_idx(rotate_face_idx, 36) + [(1, 30), (2, 33), (3, 36), (\r\n    10, 3), (13, 2), (16, 1), (30, 54), (33, 53), (36, 52), (52, 10), (53, 13), (54, 16)]\r\nD_turn_idx = increase_idx(rotate_face_idx, 45) + [(16, 43), (17, 44), (18, 45), (\r\n    25, 16), (26, 17), (27, 18), (34, 25), (35, 26), (36, 27), (43, 34), (44, 35), (45, 36)]\r\nM_turn_idx = [(2, 44), (5, 41), (8, 38), (20, 2), (23, 5), (26, 8),\r\n              (38, 53), (41, 50), (44, 47), (47, 20), (50, 23), (53, 26)]\r\nE_turn_idx = [(13, 40), (14, 41), (15, 42), (22, 13), (23, 14), (24, 15),\r\n              (31, 22), (32, 23), (33, 24), (40, 31), (41, 32), (42, 33)]\r\nS_turn_idx = [(4, 17), (5, 14), (6, 11), (11, 49), (14, 50), (17, 51),\r\n              (51, 29), (50, 32), (49, 35), (29, 4), (32, 5), (35, 6)]\r\n\r\n\r\ndef make_turn(pos, idx):\r\n    copied = pos . copy()\r\n    for start, changed in idx:\r\n    pos[start] = copied[changed]\r\n\r\n    def perform(seq):\r\n        # idea is you only need to use moves in the set {U, L, F, R, B, D, M, E, S} to get any position\r\n        # it is possible to do it with the moves {U, L, F, X, Y, Z} only, but it makes things a bit harder\r\n        # this method is quite inefficient, but it makes things easier and this isn't a performance-based kata anyway\r\n    for move in 'ULFRBDulfrbdMESXYZ':\r\n    for times, char in enumerate('2\\''):\r\n    seq = seq . replace(move + char, move * (times + 2))\r\n\r\n    for comb in [('XYZ', 'rLLL uDDD fBBB' . split()), ('ulfrbd', 'UEEE LM FS RMMM BSSS DE' . split())]:\r\n    for move in zip(* comb):\r\n    seq = seq . replace(* move)\r\n\r\n    seq = seq . replace(' ', '')\r\n    position = {idx + 1: colour for idx,\r\n                colour in enumerate('' . join(c * 9 for c in 'ybrgow'))}\r\n\r\n    for move in seq:\r\n    exec(f'make_turn(position, { move } _turn_idx)')\r\n    return '' . join(position . values())\r\n",
  "5ecef4a6640dbb0032bc176d": "happy = {1, 7, 10, 13, 19, 23, 28, 31, 32,\r\n         44, 49, 68, 70, 79, 82, 86, 91, 94, 97}\r\nsums = {0: [0]}\r\n\r\nfor _ in range(7):\r\n    new_sums = {}\r\n    for x, terms in sums . items():\r\n    for d in range(10):\r\n    new_sums . setdefault(x + d * d, []). extend(term *\r\n                                                 10 + d for term in terms)\r\n    sums = new_sums\r\n    for x, terms in sums . items():  # order matters\r\n    if x in happy:\r\n    happy . update(terms)\r\n\r\n    from bisect import bisect\r\n\r\n    def perf_happy(n, happy_list=sorted(happy)\r\n                   ): return happy_list[: bisect(happy_list, n)]\r\n",
  "571ec81d7e8954ce1400014f": "import numpy as np\r\nfrom itertools import combinations\r\n\r\n\r\ndef validate_battlefield(field):\r\n    return validate(np . array(field), [(1, 4), (2, 3), (3, 2)], 20)\r\n\r\n    def validate(field, ships, expected):\r\n    if field . sum() != expected:\r\n        return False\r\n    elif not ships:\r\n        return True  # single-unit ships can be anywhere, so we can shortcut\r\n    # We are looking for (n) ships of length (size).\r\n    (n, size), remaining = ships[0], ships[1:]\r\n\r\n    # Find horizontal/vertical slices of the appropriate length containing all ones ...\r\n    slices = filter(all, (f[i, j: j + size] for f in (field, field . T)\r\n                    for (i, j) in zip(* np . where(f))))\r\n\r\n    # ... and try zeroing-out (n) of them at a time to find a valid combination.\r\n    # If the recursive check fails, we backtrack by setting the slices back to one.\r\n    return any(\r\n        assign(s, 0) or validate(field, remaining,\r\n                                 expected - n * size) or assign(s, 1)\r\n        for s in combinations(slices, n)\r\n    )\r\n\r\n    def assign(slices, x):\r\n        # Set the value of all array slices in a collection\r\n    for arr in slices:\r\n        arr[:] = x\r\n",
  "5f134651bc9687000f8022c4": "idx, n, seq = 2, 6, [1, 2, 4, 6]\r\nwhile n < 2 * * 41:\r\n    idx += 1\r\n    seq . extend(range(n + idx, n + (seq[idx] - seq[idx - 1]) * idx + 1, idx))\r\n    n += (seq[idx] - seq[idx - 1]) * idx\r\n    from bisect import bisect\r\n    def find(n): return bisect(seq, n)\r\n",
  "6545283611df271da7f8418c": "def three_powers(n): return n > 2 and n . bit_count() <= 3\n",
  "5eee6c930514550026cefe9e": "from itertools import permutations\r\n\r\n\r\ndef packing_rectangles(* args):\r\n    result, inputs = float(\"inf\"), {\r\n        args[: 2], args[2: 4], args[4:], args[1:: - 1], args[3: 1: - 1], args[: 3: - 1]}\r\n    for a, b, c, d, e, f in permutations(args):\r\n    if (a, b) in inputs and (c, d) in inputs and (e, f) in inputs:\r\n    result = min(result, (a + c + e) * max(b, d, f),\r\n                 (a + max(c, e)) * max(b, d + f))\r\n    return result\r\n",
  "5e90f0544af7f400102675ca": "import numpy as np\r\n\r\n\r\nclass Basis:  # stores the active basis\r\n    def __init__(self, A, basis_list, Binv):\r\n    self . A = np . copy(A)\r\n    self . Binv = np . copy(Binv)\r\n    self . basis_list = np . copy(basis_list)\r\n\r\n    self . is_basis = np . array([False] * A . shape[1])\r\n    self . is_basis[basis_list] = True\r\n    self . not_basis_list = np . where(~ self . is_basis)[0]\r\n\r\n    self . indexes = np . array([0] * A . shape[1])\r\n    self . indexes[basis_list] = np . arange(len(basis_list))\r\n    self . indexes[self . not_basis_list] = np . arange(\r\n        len(self . not_basis_list))\r\n\r\n    def update(self, oldcol, newcol):  # updates efficiently the inverse of the basis at every step\r\n    Y = self . Binv @ self . A[:, newcol]\r\n    i = self . indexes[oldcol]\r\n    self . Binv[i, :] *= 1 / Y[i]\r\n    Y[i] = 0.0\r\n    self . Binv -= np . outer(Y, self . Binv[i, :])\r\n\r\n    oldindex, newindex = self . indexes[oldcol], self . indexes[newcol]\r\n    self . basis_list[oldindex], self . not_basis_list[newindex] = newcol, oldcol\r\n    self . indexes[oldcol], self . indexes[newcol] = newindex, oldindex\r\n    self . is_basis[oldcol] = False\r\n    self . is_basis[newcol] = True\r\n    class OTSimplexSolver:  # Optimal transport solver based on the simplex method\r\n    def __init__(self, src, dst, cost):\r\n    self . src, self . dst, self . cost = src, dst, cost\r\n    self . n_src, self . n_dst = len(src), len(dst)\r\n\r\n    self . rank = self . n_src + self . n_dst - 1\r\n    self . n_params = self . n_src * self . n_dst\r\n    # We create a corresponding linear programming problem\r\n    self . A = np . zeros((self . rank, self . n_params))\r\n    for i in range(self . n_src):\r\n    for j in range(self . n_dst):\r\n    self . A[i, self . n_dst * i + j] = 1.0\r\n    if j < self . n_dst - 1:\r\n    self . A[self . n_src + j, self . n_dst * i + j] = 1.0\r\n    self . b = np . concatenate((src, dst[: - 1]))\r\n    self . c = np . array(cost). flatten()\r\n    self . basis = None\r\n    def init_basis(self):  # creates the initial basis\r\n    basis_list = np . array(list(range(self . n_dst - 1)) + list(\r\n        range(self . n_dst - 1, self . n_dst * self . n_src, self . n_dst)))\r\n\r\n    Binv = np . zeros((self . rank, self . rank))\r\n    Binv[self . n_dst - 1:, : self . n_src] = np . identity(self . n_src)\r\n    Binv[: self . n_dst - 1, self . n_src:] = np . identity(self . n_dst - 1)\r\n    Binv[self . n_dst - 1, self . n_src:] = - 1.0\r\n    return Basis(self . A, basis_list, Binv)\r\n\r\n    # finds initial basic feasible solution using the least-cost method\r\n    def find_initial_solution_lcm(self):\r\n    x = np . zeros(self . n_params)\r\n    basis = self . init_basis()\r\n\r\n    src_remaining, dst_remaining = self . src[:], self . dst[:]\r\n    used = np . full(self . n_params, False)\r\n    allowed = np . full(self . n_params, False)\r\n    basis_size = 0\r\n    indexes = np . argsort(self . c)\r\n    for k in indexes:\r\n    i, j, loc_cost = k / / self . n_dst, k % self . n_dst, self . c[k]\r\n    transported = min(src_remaining[i], dst_remaining[j])\r\n    if (transported == 0):\r\n    continue\r\n    used[k] = True\r\n    basis_size += 1\r\n    x[k] += transported\r\n    src_remaining[i] -= transported\r\n    dst_remaining[j] -= transported\r\n    if not basis . is_basis[k]:\r\n    allowed[:] = False\r\n    allowed[basis . basis_list[np . abs(\r\n        basis . Binv @ self . A[:, k]) > 0.01]] = True\r\n    allowed[used] = False\r\n    basis . update(np . where(allowed)[0][0], k)\r\n    if basis_size == self . rank:\r\n    break\r\n    return x, basis\r\n    def simplex_step(self):\r\n    lambd = self . c[self . basis . basis_list] @ self . basis . Binv\r\n    lambd = np . concatenate((lambd, [0.0]))\r\n    # faster computation of s = c - A^T \\lambda\r\n    s = self . c - (lambd[None, self . n_src:] +\r\n                    lambd[: self . n_src, None]). flatten()\r\n    # nonbasic variables with s < 0\r\n    indexes_pivots = np . where((s < - 0.01) & ~ self . basis . is_basis)[0]\r\n    if len(indexes_pivots) == 0:  # if there is none, solution is optimal\r\n    return True\r\n    pivot = indexes_pivots[np . argmin(s[indexes_pivots])]\r\n    d = self . basis . Binv @ self . A[:, pivot]\r\n    # In OT, no need to worry about unboundedness\r\n    cond = d > 0.01\r\n    indexes = np . where(cond)[0]\r\n\r\n    xb = self . x[self . basis . basis_list]\r\n    j = indexes[np . argmin(xb[cond] / d[cond])]\r\n    oldcol = self . basis . basis_list[j]\r\n    xi = xb[j] / d[j]\r\n\r\n    self . x[self . basis . basis_list] -= d * xi\r\n    self . x[pivot] = xi\r\n    self . basis . update(oldcol, pivot)\r\n    return False\r\n    def solve(self):\r\n    self . x, self . basis = self . find_initial_solution_lcm()\r\n    res = False\r\n    while not res:\r\n    res = self . simplex_step()\r\n    return self . x @ self . c, self . x\r\n    def minimum_transportation_price(suppliers, consumers, costs):\r\n    solver = OTSimplexSolver(suppliers, consumers, costs)\r\n    return solver . solve()[0]\r\n",
  "65382cfc5396a5bc37d19395": "def vertical_sum(n, i):\n    idx = abs(i) + 1\n    top = idx * (idx + 1) / / 2\n    if i < 0:\n        top += i\n    hgt = (n - idx) / / 2\n    return hgt * (hgt + 1) * (n - 1 - (n + idx) % 2) - hgt * (hgt + 1) * (hgt - 1) * 4 / / 3 + (hgt + 1) * top\n",
  "5f5bef3534d5ad00232c0fa8": "from itertools import count\r\nfrom functools import reduce\r\n\r\n\r\ndef converge(g, * us):\r\n    floods = [frozenset({u}) for u in us]\r\n    vus = set()\r\n    for step in count(0):\r\n    if all(s in vus for s in floods):\r\n        break\r\n    vus . update(floods)\r\n    overlap = reduce(set . intersection, floods[1:], set(floods[0]))\r\n    if overlap:\r\n        return step\r\n    floods = [frozenset(neigh for u in f for neigh in g[u]) for f in floods]\r\n",
  "59b9a92a6236547247000110": "import math\r\nimport string\r\nfrom functools import cached_property\r\nfrom itertools import count\r\n\r\n\r\nclass Deck:\r\n    def __init__(self):\r\n    self . suits = tuple('CDHS')\r\n    self . ranks = tuple('A23456789TJQK')\r\n    self . cards = tuple(r + s for s in self . suits for r in self . ranks)\r\n\r\n    def __len__(self) - > int:\r\n    return len(self . cards)\r\n\r\n    def find_nth_permutation(self, n: int) - > list[str]:\r\n    cards, result = [* self . cards], []\r\n    for i in range(len(self) - 1, - 1, - 1):\r\n    index, n = divmod(n, math . factorial(i))\r\n    result . append(cards . pop(index))\r\n    return result\r\n    def find_ordinal_number_of_permutation(self, state: list[str]) - > int:\r\n    cards, num_of_perm = [* self . cards], 0\r\n    for i, card in zip(count(len(self) - 1, - 1), state):\r\n    index = cards . index(card)\r\n    num_of_perm += index * math . factorial(i)\r\n    _ = cards . pop(index)\r\n    return num_of_perm\r\n    class ValidAlphabet:\r\n    def __init__(self):\r\n    self . valid_symbols = tuple(' ' + string . ascii_uppercase)\r\n\r\n    def __len__(self) - > int:\r\n    return len(self . valid_symbols)\r\n\r\n    @ cached_property\r\n    def symbols_table(self) - > dict[str, int]:\r\n    return {s: i for i, s in enumerate(self . valid_symbols)}\r\n\r\n    @ cached_property\r\n    def indexes_table(self) - > dict[int, str]:\r\n    return {i: s for s, i in self . symbols_table . items()}\r\n\r\n    class PlayingCards:\r\n    ALPHA = ValidAlphabet()\r\n    DECK = Deck()\r\n\r\n    @ classmethod\r\n    def encode(cls, message: str) - > list[str]:\r\n    k, rm = len(cls . ALPHA), reversed(message)\r\n    perm_n = sum(\r\n        cls . ALPHA . symbols_table[s] * k * * i for i, s in enumerate(rm)\r\n    )\r\n    return cls . DECK . find_nth_permutation(perm_n)\r\n\r\n    @ classmethod\r\n    def decode(cls, deck: list[str]) - > str:\r\n    n = cls . DECK . find_ordinal_number_of_permutation(deck)\r\n    result = []\r\n    while n:\r\n    n, index = divmod(n, len(cls . ALPHA))\r\n    result . append(cls . ALPHA . indexes_table[index])\r\n    return '' . join(reversed(result))\r\n",
  "59c2ff946bddd2a2fd00009e": "from string import ascii_uppercase\r\n\r\n\r\nclass CardChameleon:\r\n\r\n    __slots__ = ('deck', 'is_valid', 'text')\r\n\r\n    ALPHABET = ascii_uppercase + ' '\r\n    BLACK_CARDS = [\r\n        rank + suit for suit in 'CS' for rank in 'A23456789TJQK'] + ['XB']\r\n    RED_CARDS = [\r\n        rank + suit for suit in 'DH' for rank in 'A23456789TJQK'] + ['XR']\r\n\r\n    TO_BLACK = dict(zip(ALPHABET, BLACK_CARDS))\r\n    FROM_BLACK = dict(zip(BLACK_CARDS, ALPHABET))\r\n    TO_RED = dict(zip(ALPHABET, RED_CARDS))\r\n    FROM_RED = dict(zip(RED_CARDS, ALPHABET))\r\n\r\n    def __init__(self, text: str, deck: list) - > None:\r\n    self . is_valid = set(deck) == self . FROM_BLACK . keys(\r\n    ) | self . FROM_RED . keys() and set(text) <= set(self . ALPHABET)\r\n    self . deck = self . prepare(deck) if self . is_valid else deck\r\n    self . text = text\r\n    def prepare(self, deck) - > list:\r\n    res = [''] * len(deck)\r\n    black, red = [], []\r\n    for card in deck:\r\n        (black if card in self . FROM_BLACK else red). append(card)\r\n    res[0:: 2] = red\r\n    res[1:: 2] = black\r\n    return res\r\n    def swap(self, i: int, j: int) - > None:\r\n    self . deck[i], self . deck[j] = self . deck[j], self . deck[i]\r\n\r\n    def shift(self, n: int) - > None:\r\n    self . deck = self . deck[n:] + self . deck[: n]\r\n\r\n    def encrypt(self) - > str or None:\r\n    return self . __cipher(self . TO_BLACK, self . FROM_RED, mode=0)\r\n\r\n    def decrypt(self) - > str or None:\r\n    return self . __cipher(self . TO_RED, self . FROM_BLACK, mode=1)\r\n\r\n    def __cipher(self, to_card: dict, from_card: dict, mode: int) - > str or None:\r\n    if not self . is_valid:\r\n        return None\r\n    res = []\r\n    for char in self . text:\r\n    swap_index = 0\r\n    for i in range(2):\r\n    card = to_card[char]\r\n    index = self . deck . index(card) + mode - 1\r\n    if i ^ mode:\r\n        swap_index = index\r\n    card = self . deck[index + mode]\r\n    char = from_card[card]\r\n    self . swap(0, swap_index), self . shift(2)\r\n    res . append(char)\r\n    return '' . join(res)\r\n",
  "653db02b1eca91b474817307": "def rake_and_burn(days):\r\n    rain = yard = pile = 0\r\n    for p, ws, wd in days:\r\n    if p == 'snow':\r\n    return yard / / 12\r\n    if p != 'rain' and not rain:\r\n    if pile == 2 and ws <= 10 and 'S' not in wd:\r\n    pile = 0\r\n    yard += 3\r\n    elif pile < 2 and ws <= 12:\r\n    pile += 1\r\n    yard += 4\r\n    rain = p == 'rain'\r\n",
  "6532414794f1d24774f190ae": "import copy\r\n# Modifica el poder de salto y el arreglo seg\u00fan la direcci\u00f3n de salto e \u00edndice dado\r\n\r\n\r\ndef Jump():\r\n    global jumpPower, array, index, direction, length\r\n    global indexSequense, jumpPowerSequense, arraySequense, directionSequense\r\n    global contador\r\n    jumpPower += array[index]\r\n    array[index] = 0\r\n    jumpPowerSequense . append(jumpPower)\r\n\r\n    directionSequense . append(direction)\r\n    if direction < 0:\r\n    array . reverse()\r\n    arraySequense . append(copy . deepcopy(array))\r\n    array . reverse()\r\n    indexSequense . append(length - index - 1)\r\n    else:\r\n    arraySequense . append(copy . deepcopy(array))\r\n    indexSequense . append(index)\r\n\r\n    # Calcula el pr\u00f3ximo \u00edndice y direcci\u00f3n (izq o der), seg\u00fan el poder de salto e \u00edndice actual\r\n\r\n    def NextIndex():\r\n    global jumpPower, array, index, direction, length, contador\r\n    index += jumpPower\r\n    q = index / / length\r\n    if q > 0:\r\n    direction *= (- 1) * * q\r\n    if q % 2 == 1:\r\n    array . reverse()\r\n    index = index % length\r\n    else:\r\n    index = index % length\r\n    contador += 1\r\n    # print(f\"\\nEstado # {contador}: {newState}\\n{arraySequense}\")\r\n    # Personaliza las condiciones iniciales\r\n    def InitialConditions(ARRAY, START):\r\n    global jumpPower, array, index, direction, length\r\n    global indexSequense, jumpPowerSequense, arraySequense, directionSequense\r\n    global states, newState, contador\r\n    array = ARRAY\r\n    length = len(array)\r\n    # indice inicial (cualquier \u00edndice positivo y menor que length)\r\n    index = START\r\n    jumpPower = 0  # poder de salto inicial (cualquier entero positivo)\r\n    # direcci\u00f3n inicial (1 si coienza hacia la derecha y -1 si comienza hacia la izquierda)\r\n    direction = 1\r\n    indexSequense = [index]\r\n    jumpPowerSequense = [jumpPower]\r\n    arraySequense = [copy . deepcopy(array)]\r\n    directionSequense = [direction]\r\n    states = set()\r\n\r\n    contador = 0\r\n    newState = (indexSequense[0], jumpPowerSequense[0], directionSequense[0])\r\n    # print(f\"\\nEstado # {contador}: {newState}\\n{arraySequense}\")\r\n    # Determina si el conejo termina o se queda estancado (funciona para arrays solo con naturales)\r\n    # el primer argumento es el campo o arreglo y el segundo ser\u00e1 la posici\u00f3n inicial del conejo\r\n    def crazy_rabbit(field, cr):\r\n    global jumpPower, array, index, direction, length\r\n    global indexSequense, jumpPowerSequense, arraySequense, directionSequense\r\n    global states, newState\r\n    InitialConditions(field, cr)\r\n\r\n    while newState not in states:\r\n    states . add(newState)\r\n    Jump()\r\n    newState = (indexSequense[- 1],\r\n                jumpPowerSequense[- 1], directionSequense[- 1])\r\n\r\n    NextIndex()\r\n\r\n    # Aplica solo para un arreglo de naturales\r\n    if sum(array) == 0:\r\n    return True\r\n    else:\r\n    return False\r\n",
  "59a07c8810963911ca000090": "steps_up = {\r\n    'Cb': ('Dbb', 'Db'),\r\n    'C': ('Db', 'D'),\r\n    'C#': ('D', 'D#'),\r\n    'Db': ('Ebb', 'Eb'),\r\n    'D': ('Eb', 'E'),\r\n    'D#': ('E', 'E#'),\r\n    'Eb': ('Fb', 'F'),\r\n    'E': ('F', 'F#'),\r\n    'E#': ('F#', 'FX'),\r\n    'Fb': ('Gbb', 'Gb'),\r\n    'F': ('Gb', 'G'),\r\n    'F#': ('G', 'G#'),\r\n    'Gb': ('Abb', 'Ab'),\r\n    'G': ('Ab', 'A'),\r\n    'G#': ('A', 'A#'),\r\n    'Ab': ('Bbb', 'Bb'),\r\n    'A': ('Bb', 'B'),\r\n    'A#': ('B', 'B#'),\r\n    'Bb': ('Cb', 'C'),\r\n    'B': ('C', 'C#'),\r\n    'B#': ('C#', 'CX')\r\n}\r\n\r\n\r\ndef get_scale(mode, note): return [\r\n    note] + [(note := steps_up[note][step == 'W']) for step in mode . split()[: - 1]]\r\n",
  "5e1ab1b9fe268c0033680e5f": "def solve(n):\r\n    def length(n):\r\n    s = 0\r\n    for i in range(20):\r\n    o = 10 * * i - 1\r\n    if o > n:\r\n        break\r\n    s += (n - o) * (n - o + 1) / / 2\r\n    return s\r\n    def binary_search(k):\r\n    n = 0\r\n    for p in range(63, - 1, - 1):\r\n    if length(n + 2 * * p) < k:\r\n        n += 2 * * p\r\n    return n\r\n    def sequence(n):\r\n    if n < 10:\r\n        return n\r\n    for i in range(1, 19):\r\n    segment = i * 9 * 10 * * (i - 1)\r\n    if n <= segment:\r\n    return str(10 * * (i - 1) + (n - 1) / / i)[(n - 1) % i]\r\n    else:\r\n    n -= segment\r\n    return int(sequence(n - length(binary_search(n))))\r\n",
  "652643925c042100247fffc6": "import re\r\n\r\n\r\ndef fruit_pack(orders):\r\n    arr = []\r\n    for order in orders:\r\n    shelf = ['', '', '']\r\n    for num, fruit in re . findall('(\\d+)(\\D)', order):\r\n    pallet, box, bag = int(num) / / 50, (int(num) % 50) / / 10, int(num) % 10\r\n    if pallet:\r\n        shelf[2] += ('[' + fruit + ']') * pallet\r\n    if box:\r\n        shelf[1] += ('{' + fruit + '}') * box\r\n    if bag:\r\n        shelf[0] += ('(' + fruit * bag + ')')\r\n    m = max(map(len, shelf))\r\n    arr . append([x . rjust(m, '-') for x in shelf])\r\n    return arr\r\n",
  "6525caefd77c582baf678ddf": "from math import ceil\n\n\ndef number_lappings(my_speed, ghost_speed, time, round_length):\n    if my_speed <= ghost_speed:\n    return 0\n    return ceil((my_speed - ghost_speed) * time / round_length) - 1\n",
  "6523a71df7666800170a1954": "from gmpy2 import digits\r\n\r\n\r\ndef esthetic(num, max_base=10):\r\n    return [base for base in range(2, max_base + 1) if (dig := digits(num, base))\r\n            and all(abs(int(a) - int(b)) == 1 for a, b in zip(dig, dig[1:]))]\r\n",
  "6521bbf23256e8e5801d64f1": "def next_palin(n):\r\n    s = str(n)\r\n    l = len(s)\r\n    h = l / / 2\r\n    r = l % 2\r\n    t = s[: h + r] + s[: h][:: - 1]\r\n\r\n    if t > s:\r\n    return int(t)\r\n    elif t == '9' * l:\r\n    return 10 * * l + 1\r\n    else:\r\n    m = str(int(s[: h + r]) + 1)\r\n    return int(m + m[: h][:: - 1])\r\n",
  "58febc23627d2f48de000060": "from heapq import heappush, heappop\r\n\r\n\r\ndef closure_gen(* s):\r\n    q = sorted(s)\r\n    m = set(s)\r\n    while q:\r\n    curr = heappop(q)\r\n    yield curr\r\n    for i in s:\r\n    t = curr * i\r\n    if t not in m:\r\n    heappush(q, t)\r\n    m . add(t)\r\n",
  "651bfcbd409ea1001ef2c3cb": "class Weapon:\r\n    def __init__(self, factors):\r\n    self . factors = factors\r\n    self . enhanced = False\r\n    def enhance(self, factors):\r\n    self . factors = [max(a, b) for a, b in zip(self . factors, factors)]\r\n    self . enhanced = True\r\n    def damage(self, characteristics):\r\n    return sum(c * f for c, f in zip(characteristics, self . factors)) + self . factors[3]\r\n\r\n    class Character:\r\n    def __init__(self, name='Hero', strength=10, dexterity=10, intelligence=10):\r\n    self . name = name\r\n    self . characteristics = [strength, dexterity, intelligence]\r\n    self . weapons = {'limbs': Weapon([1, 1, 1, 0])}\r\n    self . _best_weapon = None\r\n    self . log = []\r\n\r\n    def __getattr__(self, method):\r\n    def wrapper(* args):\r\n    name = method . replace('_', ' '). capitalize()\r\n    if len(args) == 4:\r\n    self . find_weapon(name, args)\r\n    else:\r\n    self . manage_event(name, args)\r\n\r\n    return wrapper\r\n    def character_info(self) - > str:\r\n    weapon = self . weapons[self . best_weapon]\r\n    return '\\n' . join([self . name, * [f' { c } { v } ' for c, v in zip(['str', 'dex', 'int'], self . characteristics)],\r\n                        f' { self . best_weapon }{[ \"\" , \"(enhanced)\" ][ weapon . enhanced ]} { weapon . damage ( self . characteristics )} dmg'])\r\n\r\n    def event_log(self) - > str:\r\n    return '\\n' . join(self . log)\r\n\r\n    def find_weapon(self, name, factors):\r\n    if name in self . weapons:\r\n    self . weapons[name]. enhance(factors)\r\n    else:\r\n    self . weapons[name] = Weapon(factors)\r\n    self . _best_weapon = None\r\n    self . log . append(f\" { self . name } finds ' { name } '\")\r\n\r\n    @ property\r\n    def best_weapon(self):\r\n    if self . _best_weapon is None:\r\n    self . _best_weapon = min(self . weapons . keys(\r\n    ), key=lambda n: (- self . weapons[n]. damage(self . characteristics), n))\r\n    return self . _best_weapon\r\n    def manage_event(self, name, modifiers):\r\n    self . characteristics = [c + m for c,\r\n                              m in zip(self . characteristics, modifiers)]\r\n    self . _best_weapon = None\r\n    self . log . append(f' { name } : ' + ', ' . join(f' { c } { m : + } ' for c,\r\n                        m in zip(['strength', 'dexterity', 'intelligence'], modifiers) if m))\r\n",
  "651bfcbcdb0e8b104175b97e": "def pop_blocks(lst):\r\n    stk, popping = [], None\r\n    for v in lst:\r\n    if v == popping:\r\n    continue\r\n    if stk and stk[- 1] == v:\r\n    popping = stk . pop()\r\n    else:\r\n    stk . append(v)\r\n    popping = None\r\n    return stk\r\n",
  "651ab89e80f7c46fc482ba12": "def asteroid_collision(asteroids):\r\n    i = 0\r\n    while i < len(asteroids):\r\n    if asteroids[i] > 0:\r\n    if i + 1 < len(asteroids) and asteroids[i + 1] < 0:\r\n    s = asteroids[i] + asteroids[i + 1]\r\n    if s > 0:\r\n    asteroids . pop(i + 1)\r\n    else:\r\n    asteroids . pop(i)\r\n    if s == 0:\r\n    asteroids . pop(i)\r\n    i -= 1\r\n    if i >= 0:\r\n        continue\r\n    i += 1\r\n    return asteroids\r\n",
  "651478c7ba373c338a173de6": "from preloaded import TreeNode\r\n\r\n\r\ndef build_tree(inorder, postorder):\r\n    if not inorder or not postorder:\r\n    return None\r\n    # Create a hashmap to store the indices of elements in the inorder list\r\n    idx_map = {val: idx for idx, val in enumerate(inorder)}\r\n\r\n    def helper(in_start, in_end, post_start, post_end):\r\n    if in_start > in_end or post_start > post_end:\r\n    return None\r\n    root_val = postorder[post_end]\r\n    root = TreeNode(root_val)\r\n\r\n    root_index = idx_map[root_val]\r\n    left_size = root_index - in_start\r\n    root . left = helper(in_start, root_index - 1,\r\n                         post_start, post_start + left_size - 1)\r\n    root . right = helper(root_index + 1, in_end,\r\n                          post_start + left_size, post_end - 1)\r\n\r\n    return root\r\n    return helper(0, len(inorder) - 1, 0, len(postorder) - 1)\r\n",
  "6515e6788f32503cd5b1ee51": "def f(a, b): return 0 - - a / / b\n",
  "6512b3775bf8500baea77663": "def gimme_the_letters(rng):\r\n    a, b = map(ord, rng . split('-'))\r\n    return '' . join(map(chr, range(a, b + 1)))\r\n",
  "65128d27a5de2b3539408d83": "def win_round(you, opp):\r\n    return sorted(you)[: 2: - 1] > sorted(opp)[: 2: - 1]\r\n",
  "65128732b5aff40032a3d8f0": "def neutralise(s1, s2):\r\n    return '' . join('0' if i != j else i for i, j in zip(s1, s2))\r\n",
  "65127302a5de2b11c940973d": "def swap_cards(a, b):\n    p, q = a / / 10, a % 10\n    r, s = b / / 10, b % 10\n    return p > q or (r, q) > (p, s)\n",
  "65127141a5de2b1dcb40927e": "def spin_around(lst):\r\n    return abs(2 * lst . count(\"left\") - len(lst)) / / 4\r\n",
  "65126d52a5de2b11c94096d2": "def closing_in_sum(n):\r\n    n_str = str(n)\r\n\r\n    left = 0\r\n    right = len(n_str) - 1\r\n    total = 0\r\n    while left <= right:\r\n    left_number = n_str[left]\r\n    right_number = n_str[right]\r\n\r\n    if left_number == right_number and left == right:\r\n    total += int(f\" { right_number } \")\r\n    else:\r\n    total += int(f\" { left_number }{ right_number } \")\r\n\r\n    left += 1\r\n    right -= 1\r\n    return total\r\n",
  "65126a26597b8597d809de48": "import re\n\n\ndef numbers_need_friends_too(n):\n    return int(re . sub(r'(.)\\1*+(?<!\\1.)', r'\\1' * 3, str(n)))\n",
  "622e4b5028bf330017cd772f": "def min_move(a, b):\n    count = 0\n    seen = set()\n    i = 0\n    j = 0\n    while j < len(b):\n    if a[i] == b[j]:\n    i += 1\n    j += 1\n    elif a[i] in seen:\n    i += 1\n    else:\n    seen . add(b[j])\n    j += 1\n    count += 1\n    return count\n",
  "65116501a5de2bc51f409c1a": "import re\n\n\ndef is_ladder_safe(ldr):\n    s = ldr[0]\n    base = f'# { \" \" * ( len ( s ) - 2 ) } #'\n    full = \"#\" * len(s)\n    O, C = '{}'\n    reg = rf\" { base } o { full } o((?: { base } o) { O } ,2 { C }{ full } o)\\1* { base } \"\n    return len(s) > 4 and bool(re . fullmatch(reg, 'o' . join(ldr)))\n",
  "6510238b4840140017234427": "from itertools import pairwise\n\n\ndef matryoshka(ls): return all(a[0] < b[0] and a[- 1] > b[- 1]\n                               for a, b in pairwise(sorted(map(sorted, ls), key=lambda l: (l[0], - l[- 1]))))\n",
  "650c7503a5de2be5b74094bf": "def weird(n):\r\n    return weird(n / / 2) if n % 2 else (n / / 2 + 1)\r\n",
  "650a86e8404241005fc744ca": "from re import compile\nREGEX = compile(r\"(1*)(0*)\"). findall\n\n\ndef same_length(txt):\n    return all(len(x) == len(y) for x, y in REGEX(txt))\n",
  "650850aa0b700930130c7981": "PRIMES = {n for n in range(2, 10 * * 4 + 1) if all(n % p for p in range(2, int(n * * .5) + 1))}\r\n\r\n\r\ndef rev(n, b):\r\n    r = 0\r\n    while n:\r\n        r, n = r * b + n % b, n / / b\r\n    return r\r\n\r\n    def prime_reflections(mp, mb): return {b: sum(rev(p, b) < p <= mp and rev(\r\n        p, b) in PRIMES for p in PRIMES) for b in range(2, mb + 1)}\r\n",
  "5b9ecec33c5b95e2b00000ba": "import csv\r\nimport shutil\r\nimport urllib . request\r\nfrom collections import defaultdict\r\nfrom enum import Enum\r\nfrom zipfile import ZipFile\r\n# constants and helper functions\r\nFILES = 'abcdefgh'\r\nRANKS = '12345678'\r\nALPHA_NUMS = 'zero one two three four five six seven eight nine ten eleven twelve thirteen fourteen fifteen sixteen draw'\r\nTEXT_TO_DIGIT = {w: i for i, w in enumerate(ALPHA_NUMS . split())}\r\n\r\n# tablebase fetching and processing logic\r\n\r\n\r\ndef prepare_tablebase(url):\r\n    fn = \"endgame.zip\"\r\n    tablebase = {}\r\n    with urllib . request . urlopen(url) as response, open(fn, 'wb') as out_file:\r\n    shutil . copyfileobj(response, out_file)\r\n    with ZipFile(fn) as zf:\r\n    file = zf . extract('krkopt.data')\r\n    with open(file) as file:\r\n    reader = csv . reader(file)\r\n    for row in reader:\r\n    keys = row[: 6]  # First 6 elements are the positions\r\n    dtm = TEXT_TO_DIGIT . get(row[6], None)\r\n    if dtm is not None:\r\n    tablebase[tuple(keys)] = dtm\r\n    return tablebase\r\n    KRK_TABLEBASE = prepare_tablebase(\r\n        \"https://archive.ics.uci.edu/static/public/23/chess+king+rook+vs+king.zip\")\r\n\r\n    # board symmetry and translation logic\r\n\r\n    class Scenario (Enum):\r\n    BASE = 1\r\n    ROT90 = 2\r\n    ROT180 = 3\r\n    ROT270 = 4\r\n    REFLECT1 = 5\r\n    REFLECT2 = 6\r\n    REFLECT3 = 7\r\n    REFLECT4 = 8\r\n    def rotate90(pos):\r\n    f, r = pos\r\n    return FILES[RANKS . index(r)] + RANKS[7 - FILES . index(f)]\r\n\r\n    def rotate180(pos):\r\n    f, r = pos\r\n    return FILES[7 - FILES . index(f)] + RANKS[7 - RANKS . index(r)]\r\n\r\n    def rotate270(pos):\r\n    f, r = pos\r\n    return FILES[7 - RANKS . index(r)] + RANKS[FILES . index(f)]\r\n\r\n    def reflect1(pos):\r\n    f, r = pos\r\n    return FILES[7 - RANKS . index(r)] + RANKS[7 - FILES . index(f)]\r\n\r\n    def reflect2(pos):\r\n    f, r = pos\r\n    return f + RANKS[7 - RANKS . index(r)]\r\n\r\n    def reflect3(pos):\r\n    f, r = pos\r\n    return FILES[RANKS . index(r)] + RANKS[FILES . index(f)]\r\n\r\n    def reflect4(pos):\r\n    f, r = pos\r\n    return FILES[7 - FILES . index(f)] + r\r\n    # Maps for each scenario\r\n    scenario_maps_actual_to_base = {\r\n        Scenario . BASE: {f' { f }{ r } ': f' { f }{ r } ' for f in FILES for r in RANKS},\r\n        Scenario . ROT90: {f' { f }{ r } ': rotate90(f' { f }{ r } ') for f in FILES for r in RANKS},\r\n        Scenario . ROT180: {f' { f }{ r } ': rotate180(f' { f }{ r } ') for f in FILES for r in RANKS},\r\n        Scenario . ROT270: {f' { f }{ r } ': rotate270(f' { f }{ r } ') for f in FILES for r in RANKS},\r\n        Scenario . REFLECT1: {f' { f }{ r } ': reflect1(f' { f }{ r } ') for f in FILES for r in RANKS},\r\n        Scenario . REFLECT2: {f' { f }{ r } ': reflect2(f' { f }{ r } ') for f in FILES for r in RANKS},\r\n        Scenario . REFLECT3: {f' { f }{ r } ': reflect3(f' { f }{ r } ') for f in FILES for r in RANKS},\r\n        Scenario . REFLECT4: {f' { f }{ r } ': reflect4(f' { f }{ r } ') for f in FILES for r in RANKS},\r\n    }\r\n\r\n    scenario_maps_actual_to_base\r\n    scenario_maps_base_to_actual = {\r\n        s: {v: k for k, v in scenario_maps_actual_to_base[s]. items()} for s in scenario_maps_actual_to_base\r\n    }\r\n\r\n    king_to_scenario_iter = [\r\n        (('a1', 'b1', 'b2', 'c1', 'c2',\r\n          'c3', 'd1', 'd2', 'd3', 'd4'), Scenario . BASE),\r\n        (('a8', 'a7', 'b7', 'a6', 'b6',\r\n          'c6', 'a5', 'b5', 'c5', 'd5'), Scenario . ROT90),\r\n        (('h8', 'g8', 'g7', 'f8', 'f7',\r\n          'f6', 'e8', 'e7', 'e6', 'e5'), Scenario . ROT180),\r\n        (('h1', 'h2', 'g2', 'h3', 'g3',\r\n          'f3', 'h4', 'g4', 'f4', 'e4'), Scenario . ROT270),\r\n        (('h8', 'h7', 'g7', 'h6', 'g6',\r\n          'f6', 'h5', 'g5', 'f5', 'e5'), Scenario . REFLECT1),\r\n        (('a8', 'b8', 'b7', 'c8', 'c7',\r\n          'c6', 'd8', 'd7', 'd6', 'd5'), Scenario . REFLECT2),\r\n        (('a1', 'a2', 'b2', 'a3', 'b3',\r\n          'c3', 'a4', 'b4', 'c4', 'd4'), Scenario . REFLECT3),\r\n        (('h1', 'g1', 'g2', 'f1', 'f2',\r\n          'f3', 'e1', 'e2', 'e3', 'e4'), Scenario . REFLECT4),\r\n    ]\r\n\r\n    king_to_scenarios_map = defaultdict(set)\r\n\r\n    for kps, s in king_to_scenario_iter:\r\n    for kp in kps:\r\n    king_to_scenarios_map[kp]. add(s)\r\n\r\n    class Position:\r\n    def __init__(self, file, rank):\r\n    self . file = file\r\n    self . rank = rank\r\n    @ classmethod\r\n    def from_algebraic(cls, pos_str):\r\n    return cls(pos_str[0], pos_str[1])\r\n\r\n    @ classmethod\r\n    def from_indices(cls, fi, ri):\r\n    return cls(FILES[fi], RANKS[ri])\r\n\r\n    def to_algebraic(self):\r\n    return f' { self . file }{ self . rank } '\r\n    def to_tuple(self):\r\n    return self . file, self . rank\r\n    def is_immediately_adjacent(self, other):\r\n    fi, ri = FILES . index(self . file), RANKS . index(self . rank)\r\n    foi, roi = FILES . index(other . file), RANKS . index(other . rank)\r\n    return max(abs(fi - foi), abs(ri - roi)) <= 1\r\n    def __repr__(self):\r\n    return self . to_algebraic()\r\n\r\n    def __hash__(self):\r\n    return hash(str(self))\r\n\r\n    def __eq__(self, other):\r\n    return hash(self) == hash(other)\r\n\r\n    def translate_to_base_position(self, scenario):\r\n    return scenario_maps_base_to_actual[scenario][self]\r\n\r\n    class PieceType (Enum):\r\n    K = 1\r\n    R = 2\r\n    k = 3\r\n    class ChessPosition:\r\n    def __init__(self, king_pos, rook_pos, opponent_king_pos):\r\n    self . king_pos = Position . from_algebraic(king_pos)\r\n    self . rook_pos = Position . from_algebraic(rook_pos)\r\n    self . opponent_king_pos = Position . from_algebraic(opponent_king_pos)\r\n\r\n    self . scenario = None\r\n    self . base_king_pos = None\r\n    self . base_rook_pos = None\r\n    self . base_opponent_king_pos = None\r\n    self . dtm = None\r\n    self . set_scenario()\r\n\r\n    if self . dtm is None:\r\n    raise ValueError('Chess position created with no DTM.',\r\n                     king_pos, rook_pos, opponent_king_pos)\r\n\r\n    def __repr__(self):\r\n    return f'K { self . king_pos } , R { self . rook_pos } , k { self . opponent_king_pos } '\r\n    def __hash__(self):\r\n    return hash(str(self))\r\n\r\n    @ classmethod\r\n    def from_existing(cls, chess_position, piece_type=None, new_position=None):\r\n    king_pos = chess_position . king_pos . to_algebraic()\r\n    rook_pos = chess_position . rook_pos . to_algebraic()\r\n    opponent_king_pos = chess_position . opponent_king_pos . to_algebraic()\r\n    if piece_type is not None:\r\n    if isinstance(new_position, Position):\r\n    pos = new_position . to_algebraic()\r\n    else:\r\n    pos = new_position\r\n    if piece_type . value == 1:\r\n    king_pos = pos\r\n    elif piece_type . value == 2:\r\n    rook_pos = pos\r\n    elif piece_type . value == 3:\r\n    opponent_king_pos = pos\r\n    else:\r\n    raise ValueError(\r\n        'Invalid piece type for new chess position from existing.')\r\n    return cls(king_pos, rook_pos, opponent_king_pos)\r\n\r\n    def set_scenario(self):\r\n    for scenario in king_to_scenarios_map[self . king_pos . to_algebraic()]:\r\n    nKf, nKr = self . king_pos . translate_to_base_position(scenario)\r\n    nRf, nRr = self . rook_pos . translate_to_base_position(scenario)\r\n    nkf, nkr = self . opponent_king_pos . translate_to_base_position(scenario)\r\n    dtm = KRK_TABLEBASE . get((nKf, nKr, nRf, nRr, nkf, nkr), None)\r\n    if dtm is not None:\r\n    self . scenario = scenario\r\n    self . base_king_pos = Position(nKf, nKr)\r\n    self . base_rook_pos = Position(nRf, nRr)\r\n    self . base_opponent_king_pos = Position(nkf, nkr)\r\n    self . dtm = dtm\r\n    break\r\n    def translate_position(self):\r\n    if self . scenario:\r\n    return ChessPosition(\r\n        self . base_king_pos . to_algebraic(),\r\n        self . base_rook_pos . to_algebraic(),\r\n        self . base_opponent_king_pos . to_algebraic()\r\n    )\r\n    else:\r\n    raise ValueError('Position does not have an assigned scenario')\r\n\r\n    def get_king_moves(self):\r\n    f, r = self . king_pos . to_tuple()\r\n    fi, ri = FILES . index(f), RANKS . index(r)\r\n    Rf, Rr = self . rook_pos . to_tuple()\r\n    Rfi, Rri = FILES . index(Rf), RANKS . index(Rr)\r\n    kf, kr = self . opponent_king_pos . to_tuple()\r\n    kfi, kri = FILES . index(kf), RANKS . index(kr)\r\n    for df in (- 1, 0, 1):\r\n    for dr in (- 1, 0, 1):\r\n    if df or dr:\r\n    fn = fi + df\r\n    rn = ri + dr\r\n    if (\r\n        0 <= fn < 8 and 0 <= rn < 8 and\r\n        (fn, rn) not in ((Rfi, Rri), (kfi, kri)) and\r\n        not Position . from_indices(\r\n            fn, rn). is_immediately_adjacent(self . opponent_king_pos)\r\n    ):\r\n    yield Position . from_indices(fn, rn)\r\n\r\n    def get_rook_moves(self):\r\n    f, r = self . rook_pos . to_tuple()\r\n    fi, ri = FILES . index(f), RANKS . index(r)\r\n    Kf, Kr = self . king_pos . to_tuple()\r\n    Kfi, Kri = FILES . index(Kf), RANKS . index(Kr)\r\n    kf, kr = self . opponent_king_pos . to_tuple()\r\n    kfi, kri = FILES . index(kf), RANKS . index(kr)\r\n    for i in range(1, 8):\r\n    if (fi - i, ri) in ((Kfi, Kri), (kfi, kri)) or (fi - i < 0):\r\n    break\r\n    yield Position . from_indices(fi - i, ri)\r\n    for i in range(1, 8):\r\n    if (fi + i, ri) in ((Kfi, Kri), (kfi, kri)) or (fi + i > 7):\r\n    break\r\n    yield Position . from_indices(fi + i, ri)\r\n    for i in range(1, 8):\r\n    if (fi, ri - i) in ((Kfi, Kri), (kfi, kri)) or (ri - i < 0):\r\n    break\r\n    yield Position . from_indices(fi, ri - i)\r\n    for i in range(1, 8):\r\n    if (fi, ri + i) in ((Kfi, Kri), (kfi, kri)) or (ri + i > 7):\r\n    break\r\n    yield Position . from_indices(fi, ri + i)\r\n\r\n    def get_all_possible_moves(self):\r\n    for move in self . get_king_moves():\r\n    yield PieceType(1), move\r\n    for move in self . get_rook_moves():\r\n    yield PieceType(2), move\r\n    def _generate_valid_moves(self, strict=True):\r\n    res = []\r\n    for piece_type, pos in self . get_all_possible_moves():\r\n    new_chess_position = ChessPosition . from_existing(self, piece_type, pos)\r\n    if new_chess_position . dtm is not None and self . dtm is not None and (\r\n            ((new_chess_position . dtm < self . dtm + 1) and strict) or new_chess_position . dtm <= self . dtm + 1):\r\n    res . append(new_chess_position)\r\n    return sorted(res, key=lambda pn: pn . dtm)\r\n\r\n    def generate_valid_moves(self):\r\n    return vm if (vm := self . _generate_valid_moves()) else self . _generate_valid_moves(False)\r\n\r\n    class WhitePlayer:\r\n\r\n    def __init__(self, position):\r\n    self . chess_position = None\r\n    self . position_history = []\r\n    self . set_position(ChessPosition(\r\n        * self . parse_initial_position(position)))\r\n\r\n    def parse_initial_position(self, position):\r\n    pieces = position . split('-')\r\n    wk_pos, wr_pos = pieces[0]. split(',')\r\n    bk_pos = pieces[1]. strip()\r\n    return wk_pos[1:]. strip(), wr_pos[1:]. strip(), bk_pos[1:]. strip()\r\n\r\n    def set_position(self, chess_position):\r\n    self . position_history . append(chess_position)\r\n    self . chess_position = chess_position\r\n    @ property\r\n    def dtm(self):\r\n    return self . chess_position . dtm\r\n    def play(self, black_move):\r\n    new_black_pos_str = black_move[1:]\r\n    self . set_position(ChessPosition . from_existing(\r\n        self . chess_position, PieceType(3), new_black_pos_str))\r\n    for new_position in self . chess_position . generate_valid_moves():\r\n    if new_position . dtm is not None and new_position not in self . position_history[\r\n            max(0, len(self . position_history) - 2):]:\r\n    str_to_return = (\r\n        f'K { new_position . king_pos . to_algebraic ()} ' if new_position . king_pos != self . chess_position . king_pos\r\n        else f'R { new_position . rook_pos . to_algebraic ()} '\r\n    )\r\n    self . set_position(new_position)\r\n    return str_to_return\r\n",
  "65080590b6b5ee01db990ca1": "from bisect import bisect_left, bisect_right\n# Only 96 total\nmemo = [t for t in range(24 * 3600) if (s := f\" { t / / 3600 :0 2 d } : { t / / 60 % 60 :0 2 d } : { t % 60 :0 2 d } \") == s[:: - 1]]\n\n\ndef palindrome_time(lst):\n    h1, m1, s1, h2, m2, s2 = lst\n    t1, t2 = 3600 * h1 + 60 * m1 + s1, 3600 * h2 + 60 * m2 + s2\n    return bisect_right(memo, t2) - bisect_left(memo, t1)\n",
  "6507e3170b7009117e0c7865": "def freed_prisoners(prison):\r\n    unlocked, freed = prison[0], 0\r\n    if unlocked:\r\n    for cell in prison:\r\n    if cell is unlocked:\r\n    freed += 1\r\n    unlocked = not unlocked\r\n    return freed\r\n",
  "6502ea6bd504f305f3badbe3": "def twins(age, distance, velocity):\n    \u03b1 = (1 - velocity * * 2) * * 0.5\n    t = 2 * distance / velocity\n    return age + \u03b1 * t, age + t\n",
  "6501aa820038a6b0bd098afb": "def safecracker(start, incs):\n    a = (start - incs[0]) % 100\n    b = (a + incs[1]) % 100\n    c = (b - incs[2]) % 100\n    return (a, b, c)\n",
  "65013fc50038a68939098dcf": "def party_people(lst):\r\n    lst = sorted(lst)\r\n    while lst and lst[- 1] > len(lst):\r\n        lst . pop()\r\n    return len(lst)\r\n",
  "65006177f534f65b2594df05": "def rank(lst):\r\n    p = {}\r\n    for i, v in enumerate(sorted(lst)):\r\n        p . setdefault(v, []). append(i)\r\n    return [sum(p[v]) / len(p[v]) for v in lst]\r\n",
  "650017e142964e000f19cac3": "def empty_values(lst):\r\n    return [type(x)() for x in lst]\r\n",
  "65001dd40038a647480989c8": "def sort_it(array):\r\n    return sorted(array, key=lambda x: x[0] if isinstance(x, list) else x)\r\n",
  "64ffefcb3ee338415ec426c1": "from math import comb\n# https://oeis.org/A174061\n\n\ndef lucky_ticket(n):\n    return sum((- 1) * * k * comb(n, k) * comb(n / / 2 * 11 - 10 * k - 1, n - 1) for k in range(n >> 1))\n",
  "64fd5072fa88ae669bf15342": "from math import inf\n\n\ndef tree_photography(lst):\n    a, b = count(lst), count(reversed(lst))\n    return 'left' if a > b else 'right'\n    def count(it):\n    n, m = 0, - inf\n    for v in it:\n    if v > m:\n        n, m = n + 1, v\n    return n\n",
  "64fb5c7a18692c0876ebbac8": "from math import prod\nPRIMES = [n for n in range(2, 10 * * 5 + 1) if all(n % p for p in range(2, int(n * * .5) + 1))]\n\n\ndef play(query):\n    z = {}\n    for p in PRIMES:\n    if not query(p, 1):\n        continue\n    l, r = 1, 10 * * 9 + 1\n    while r - l > 1:\n    m = (r + l) / / 2\n    if query(p, m):\n        l = m\n    else:\n        r = m\n    if l:\n        z[p] = l\n    return prod(v + 1 for v in z . values()) - 2 * * len(z)\n",
  "64fbfa3518692c2ed0ebbaa2": "def diving_minigame(lst):\r\n    breath_meter = 10\r\n    for x in lst:\r\n    if x < 0:\r\n    breath_meter -= 2\r\n    else:\r\n    breath_meter = min(10, breath_meter + 4)\r\n\r\n    if breath_meter <= 0:\r\n    return False\r\n    return True\r\n",
  "64fc00392b610b1901ff0f17": "def get_coin_balances(lst1, lst2):\r\n    x, y = lst1 . count(\"share\"), lst2 . count(\"share\")\r\n    return 3 - x + 3 * y, 3 - y + 3 * x\r\n",
  "64fc03a318692c1333ebc04c": "def best_friend(t, a, b):\r\n    return t . count(a) == t . count(a + b)\r\n",
  "64fbfe2618692c2018ebbddb": "def flick_switch(lst):\r\n\t res, state = [], True\r\n for i in lst :\r\n\t\t if i == 'flick' :\r\n\t\t\t state = not state \r\n res . append ( state )\r\n\t return res",
  "64fbf7eb2b610b1a6eff0e44": "import re\r\n\r\n\r\ndef nonstop_hotspot(area):\r\n    ans = re . search(r'[* ]*P[* ]*', area)\r\n    return ans . group(). count('*')\r\n",
  "64f4ef596f222e004b877272": "def rain_tacos(landscape, word='TACO'):\r\n    n = len(grid := landscape . splitlines())\r\n    grid = [('' . join(row). rstrip() + word[i % len(word)]). ljust(n, ' ')[: n]\r\n            for i, row in enumerate(zip(* grid[:: - 1]))]\r\n    return '\\n' . join(map('' . join, list(zip(* grid))[:: - 1]))\r\n",
  "64f41ad92b610b64c1067590": "def full_cycle(lst):\r\n    return all((x := lst[i and x]) for i in range(len(lst) - 1))\r\n",
  "64ebbfc4f1294ff0504352be": "def convert_number(height, num):\n    pre = 1\n    inoreder = 2 * * (height - 1)\n    post = (2 * * height) - 1\n    depth = 1\n    while 2 * * depth <= num:\n    depth += 1\n    while depth > 1:\n    height -= 1\n    depth -= 1\n    if 2 * * (depth - 1) & num != 0:\n    pre += 2 * * height\n    inoreder += 2 * * (height - 1)\n    post -= 1\n    else:\n    pre += 1\n    inoreder -= 2 * * (height - 1)\n    post -= 2 * * height\n    return pre, inoreder, post\n",
  "64f04307c6307f003106ac2c": "from gmpy2 import next_prime\n\n\ndef min_ops(n):\n    k, p = 0, 2\n    while n > 1:\n    while n % p:\n    p = next_prime(p)\n    n / /= p\n    k += p\n    return k\n",
  "64edf7ab2b610b16c2067579": "def largest_radial_sum(arr, d):\r\n    return max(sum(arr[i:: len(arr) / / d]) for i in range(len(arr) / / d))\r\n",
  "64eca9a7bc3127082b0bc7dc": "from preloaded import DECK\r\n\r\n\r\ndef deal(n):\r\n    deck = list(DECK)\r\n    state = n\r\n    dealt_cards = []\r\n\r\n    while (len(deck) != 0):\r\n    state = (state * 214013 + 2531011) % (2 * * 31)\r\n    next_value = int(state / (2 * * 16))\r\n\r\n    card_index = next_value % len(deck)\r\n    if card_index != len(deck) - 1:\r\n    last_card = deck[- 1]\r\n    current_card = deck[card_index]\r\n    deck[- 1] = current_card\r\n    deck[card_index] = last_card\r\n    dealt_cards . append(deck . pop())\r\n\r\n    return dealt_cards\r\n",
  "56d6d927c9ae3f115b0008dd": "from decimal import Decimal as dec, getcontext\r\nimport re\r\ngetcontext(). prec = 28\r\n\r\n\r\ndef reduced(arr, comparator):\r\n    def check_divider(arr, compare):\r\n    for i, (x, y) in enumerate(zip(arr, compare)):\r\n    try:\r\n    if i == 0:\r\n        test = x / y\r\n    elif x / y != test:\r\n        return False\r\n    except:\r\n        return False\r\n    return True\r\n    return any(check_divider(arr, compare) for compare in comparator)\r\n\r\n    def collumn_extract(lst, col_index): return list(zip(* lst))[col_index]\r\n\r\n    def GaussJordan(x: list[list], y: list):\r\n    a = x . copy()\r\n    b = y . copy()\r\n    dim = len(a[0])\r\n\r\n    for col in range(dim - 1):\r\n    for row in range(1 + col, dim):\r\n    if a[row][col] != 0:\r\n    if a[col][col] == 0:\r\n    a[row], a[col] = a[col], a[row]\r\n    b[row], b[col] = b[col], b[row]\r\n    else:\r\n    divider = a[row][col] / a[col][col]\r\n    a[row] = [a[row][collar] - divider * a[col][collar]\r\n              for collar in range(dim)]\r\n    b[row] = b[row] - divider * b[col]\r\n\r\n    for row in range(dim):\r\n    if [round(elem, 10) for elem in a[row]] == [0] * len(a[row]):\r\n        return None\r\n    for col in range(dim - 1, - 1, - 1):\r\n    for row in range(col - 1, - 1, - 1):\r\n    if a[row][col] != 0:\r\n    if a[col][col] == 0:\r\n    a[row], a[col] = a[col], a[row]\r\n    b[row], b[col] = b[col], b[row]\r\n    else:\r\n    divider = a[row][col] / a[col][col]\r\n    a[row] = [a[row][collar] - divider * a[col][collar]\r\n              for collar in range(dim)]\r\n    b[row] = b[row] - divider * b[col]\r\n\r\n    try:\r\n    return [round(b[i] / a[i][i], 15) for i in range(dim)]\r\n    except:\r\n        return None\r\n\r\n    def solve(* equation):\r\n    print(equation)\r\n    vars = list(sorted(set(re . findall(r'[a-zA-Z]+', \" \" . join(equation)))))\r\n    if len(vars) > len(equation):\r\n        return None\r\n    comparator = [0] * len(equation)\r\n    coeffs = []\r\n    for iteration, lines in enumerate(equation):\r\n    isolate = re . findall(r'([+\\-]?)([0-9]*)([a-zA-Z]*)|(=)', lines)\r\n    found = False\r\n    coeff = [0] * len(vars)\r\n\r\n    for sign, coef, var, prob_equal in isolate:\r\n    if (sign, coef, var, prob_equal) != (\"\", \"\", \"\", \"\"):\r\n    if (sign, coef, var, prob_equal) == (\"\", \"\", \"\", \"=\"):\r\n        found = True\r\n    else:\r\n    if coef == '':\r\n        coef = '1'\r\n    if var:\r\n    numb = dec(int(sign + coef) if not found else - int(sign + coef))\r\n    coeff[vars . index(var)] += dec(numb)\r\n    else:\r\n    numb = dec(- int(sign + coef) if not found else int(sign + coef))\r\n    comparator[iteration] += dec(numb)\r\n    coeffs += [coeff]\r\n\r\n    if len(vars) < len(equation):\r\n    reduction = len(equation) - len(vars)\r\n    iteration = 0\r\n    while reduction != 0:\r\n    try:\r\n    if reduced(coeffs[iteration], coeffs[: iteration] + coeffs[iteration + 1:]):\r\n    coeffs . pop(iteration)\r\n    comparator . pop(iteration)\r\n    reduction -= 1\r\n    else:\r\n        iteration += 1\r\n    except:\r\n        return None\r\n    final = {}\r\n    res = GaussJordan(coeffs, comparator)\r\n    try:\r\n    for i in range(len(res)):\r\n    final . update({vars[i]: float(res[i])})\r\n    except:\r\n        return None\r\n    return final\r\n",
  "64e5e192f1294f96fd60a5ae": "import re\r\n\r\n\r\ndef block_pushing(l, n):\r\n    s = '' . join(l)\r\n    for _ in range(n):\r\n        s = re . sub('(>[>#]*)-', lambda g: '-' + g . group(1), s)\r\n    return list(s)\r\n",
  "64e5b47cc065e56fb115a5bf": "def dice_game(scores):\r\n    players = ['p1', 'p2', 'p3', 'p4']\r\n\r\n    while len(players) > 1:\r\n    results = list(zip(players, scores))\r\n    scores = scores[len(players):]\r\n    results . sort(key=lambda x: (sum(x[1]), x[1][0]))\r\n    if results[0][1] != results[1][1]:\r\n    players . remove(results[0][0])\r\n    return players[0]\r\n",
  "64e5bb63c065e575db15a3f1": "def solve(game):\r\n    if game[0] == str(len(game)):\r\n        return [(int(game[0]),)]\r\n    solutions = []\r\n    for i in range(1, int(game[0]) + 1):\r\n    if i >= len(game):\r\n        break\r\n    move_made = game[i:]\r\n    if int(move_made[0]) <= i:\r\n        continue\r\n    move_made = str(int(move_made[0]) - i) + move_made[1:]\r\n    other_solutions = solve(move_made)\r\n    solutions += [(i,) + os for os in other_solutions]\r\n    if not solutions:\r\n        return []\r\n    min_length = min(map(len, solutions))\r\n    return [s for s in solutions if len(s) == min_length]\r\n",
  "64b7bcfb0ca7392eca9f8e47": "def fair_swap(a, b):\r\n    r = set()\r\n    swap_size, odd_diff = divmod(sum(a) - sum(b), 2)\r\n    if odd_diff:\r\n        return r\r\n    b = set(b)\r\n    for n1 in set(a):\r\n    if (n2 := n1 - swap_size) in b:\r\n    r . add((n1, n2))\r\n    return r\r\n",
  "64e4cdd7f2bfcd142a880011": "from decimal import Context, Decimal, ROUND_DOWN\r\nfrom re import sub\r\n\r\n\r\ndef format_number(x):\r\n    dec = (\r\n        (Context(prec=3, rounding=ROUND_DOWN)\r\n         . create_decimal_from_float(x * 100)\r\n         . to_integral_exact(rounding=ROUND_DOWN) / 100)\r\n        . normalize()\r\n        . to_eng_string()\r\n    )\r\n    return '0' if dec == '-0' else sub(\r\n        'E\\+(\\d+)',\r\n        lambda m: ('KMBT' [n - 1] if (n := int(m[1]) / / 3) < 5 else\r\n                   '' . join(chr(x + 97) for x in divmod(n - 5, 26))),\r\n        dec,\r\n    )\r\n",
  "64dbfcbcf9ab18004d15d17e": "CARS = {\r\n    enterprise: {model: ignition . split('-')\r\n                 for model, ignition in models . items()}\r\n    for enterprise, models in CARS . items()\r\n}\r\n\r\n\r\ndef find_misfire(fire_in_the_holes):\r\n    enterprise, model, fire = fire_in_the_holes . split()\r\n    return '-' . join(a for a, b in zip(CARS[enterprise][model], fire . split('-')) if a != b)\r\n",
  "64e06b8f55bbb752ac2e66f5": "from collections import defaultdict\r\n\r\n\r\ndef score31(c1, c2, c3):\r\n    d = defaultdict(int)\r\n    values = set()\r\n    for c in c1, c2, c3:\r\n    v = c[1:]\r\n    values . add(v)\r\n    d[c[0]] += int(v) if v . isdigit() else 10 + (v == \"A\")\r\n    return max(d . values()) if len(values) > 1 else 30.5 + 1.5 * (v == \"A\")\r\n",
  "648b579a731d7526828173cc": "from preloaded import PRIMES\r\nfrom itertools import chain, takewhile\r\n\r\n\r\ndef prime_grasshopper(arr):\r\n    dp = arr[:]\r\n    for i, x in enumerate(dp):\r\n    dp[i] = max(\r\n        chain([x], [dp[i - p] + x for p in takewhile(i . __ge__, PRIMES)]))\r\n    return max(chain([0], dp))\r\n",
  "64d1d067e58c0e0025860f4b": "def play_a_round(alex_cards, bob_cards, chris_cards, dave_cards):\r\n    return_list = []\r\n    if '2C' in bob_cards:\r\n    leader = 'bob'\r\n    elif '2C' in chris_cards:\r\n    leader = 'chris'\r\n    elif '2C' in dave_cards:\r\n    leader = 'dave'\r\n    else:\r\n    leader = 'alex'\r\n    # Play until players have no more cards\r\n    while len(alex_cards) > 0:\r\n\r\n        # Build this hand\r\n    this_hand = []\r\n    if leader == 'alex':\r\n    this_hand . append(get_card(alex_cards, this_hand))\r\n    this_hand . append(get_card(bob_cards, this_hand))\r\n    this_hand . append(get_card(chris_cards, this_hand))\r\n    this_hand . append(get_card(dave_cards, this_hand))\r\n    elif leader == 'bob':\r\n    this_hand . append(get_card(bob_cards, this_hand))\r\n    this_hand . append(get_card(alex_cards, this_hand))\r\n    this_hand . append(get_card(chris_cards, this_hand))\r\n    this_hand . append(get_card(dave_cards, this_hand))\r\n    elif leader == 'chris':\r\n    this_hand . append(get_card(chris_cards, this_hand))\r\n    this_hand . append(get_card(alex_cards, this_hand))\r\n    this_hand . append(get_card(bob_cards, this_hand))\r\n    this_hand . append(get_card(dave_cards, this_hand))\r\n    elif leader == 'dave':\r\n    this_hand . append(get_card(dave_cards, this_hand))\r\n    this_hand . append(get_card(alex_cards, this_hand))\r\n    this_hand . append(get_card(bob_cards, this_hand))\r\n    this_hand . append(get_card(chris_cards, this_hand))\r\n\r\n    # Determine winner and add it to list to be returned\r\n    winning_card = play_a_hand(this_hand)\r\n    return_list . append(winning_card)\r\n\r\n    # Determine who leads next hand\r\n    if winning_card in alex_cards:\r\n    leader = 'alex'\r\n    elif winning_card in bob_cards:\r\n    leader = 'bob'\r\n    elif winning_card in chris_cards:\r\n    leader = 'chris'\r\n    elif winning_card in dave_cards:\r\n    leader = 'dave'\r\n    # Remove cards just played from players' hands\r\n    for card in this_hand:\r\n    if card in alex_cards:\r\n    alex_cards . remove(card)\r\n    elif card in bob_cards:\r\n    bob_cards . remove(card)\r\n    elif card in chris_cards:\r\n    chris_cards . remove(card)\r\n    elif card in dave_cards:\r\n    dave_cards . remove(card)\r\n\r\n    return return_list\r\n    # Use the strategy from the instructions to determine which card this player plays\r\n\r\n    def get_card(player_cards, this_hand):\r\n        # First check\r\n    if '2C' in player_cards:\r\n    return '2C'\r\n    # Second check\r\n    if len(this_hand) == 0:\r\n    return player_cards[0]\r\n    else:\r\n    led_suit = this_hand[0][- 1]\r\n    for card in player_cards:\r\n    if card[- 1] == led_suit:\r\n    return card\r\n    # Third check\r\n    for card in player_cards:\r\n    suit = card[- 1]\r\n    if card == 'QS' or suit == 'H':\r\n    return card\r\n    # Final check\r\n    return player_cards[0]\r\n\r\n    # Which card wins this hand? Return it.\r\n    def play_a_hand(cards):\r\n    ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A']\r\n    suit = cards[0][- 1]\r\n    top_rank = cards[0][0: - 1]\r\n    for i in range(1, 4):\r\n    this_card = cards[i]\r\n    this_suit = this_card[- 1]\r\n    if this_suit == suit:\r\n    this_rank = this_card[0: - 1]\r\n    if ranks . index(this_rank) > ranks . index(top_rank):\r\n    top_rank = this_rank\r\n    return top_rank + suit\r\n",
  "64dbb4ab529cad81578c61e7": "import ast\n\n\nclass YourFirstNodeTransformer (ast . NodeTransformer):\n    ...  # you can do this !\n    def visit_Constant(self, node):\n    return ast . Constant(node . value + 0.5)\n",
  "64db008b529cad38938c6e28": "import re\r\n\r\n\r\ndef longest_substring(digits):\r\n    regex = r'({e}?({o}{e})*{o}?)|({o}?({e}{o})*{e}?)' . format(\r\n        e='[02468]', o='[13579]')\r\n    return max((x[0] for x in re . findall(regex, digits)), key=len)\r\n",
  "64915dc9d40f96004319379a": "def type_of_function(d, c, r): return 'It is not a function' if len(k: = dict(r)) != len(r) else ('Bijective' if len(k) == len(d) == len(c) else 'Surjective') if set(k . values()) == set(c) else 'Injective' if len(set(k . values())) == len(k . values()) else 'General function'\n",
  "64d4cd29ff58f0002301d5db": "from itertools import combinations\n\n\ndef pair_em_up(n):\n    return sorted((list(x) for k in range(2, n + 1, 2) for x in combinations(range(n), k)), key=lambda x: x + [n] * (n - len(x)))\n",
  "64d482b76fad180017ecef0a": "from collections import Counter\n\n\ndef consecutive_nums(lst, size):\n    if len(lst) % size:\n        return False\n    cnt = Counter(lst)\n    for v in sorted(cnt)[: - size + 1 or None]:\n    if not cnt[v]:\n        continue\n    n = cnt[v]\n    for x in range(v, v + size):\n    if cnt[x] < n:\n        return False\n    cnt[x] -= n\n    return not sum(cnt . values())\n",
  "64cd52397a14d81a9f78ad3e": "def compute_final_position(b, m):\n\n    def pos(a, b): return (8 - int(b), 'abcdefgh' . index(a))\n\n    for t, e in enumerate(m):\n\n    if e[2] in '-x':\n        i, j = pos(* e[0: 2])\n        p, q = pos(* e[3: 5])\n        b[p][q] = b[i][j]\n        b[i][j] = '.'  # regular move\n    if e[- 2:] == 'ep':\n        b[i][q] = '.'  # en passant\n    if len(e) == 6:\n        b[p][q] = e[5]  # pawn promotion\n    if e == 'O-O' and t % 2 < 1:\n        b[7][4] = b[7][7] = '.'\n        b[7][5] = 'R'\n        b[7][6] = 'K'  # castling king size white\n    if e == 'O-O' and t % 2 > 0:\n        b[0][4] = b[0][7] = '.'\n        b[0][5] = 'r'\n        b[0][6] = 'k'  # castling king size black\n    if e == 'O-O-O' and t % 2 < 1:\n        b[7][0] = b[7][4] = '.'\n        b[7][2] = 'K'\n        b[7][3] = 'R'  # castling queen size white\n    if e == 'O-O-O' and t % 2 > 0:\n        b[0][0] = b[0][4] = '.'\n        b[0][2] = 'k'\n        b[0][3] = 'r'  # castling queen size black\n    return b\n",
  "64d16a4d8a9c272bb4f3316c": "VALUES = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A']\r\n\r\n\r\ndef score_a_hand(cards):\r\n    suit = cards[0][- 1]\r\n    in_suit = filter(lambda card: card . endswith(suit), cards)\r\n    return max(in_suit, key=lambda card: VALUES . index(card[: - 1]))\r\n",
  "64d0f8fc8a9c270041f33a3c": "from math import gcd\r\nfrom itertools import count\r\n\r\n\r\ndef gcd_neq_one(a, b, k):\r\n    for n in count(0):\r\n    for i in range(0, n * k + 1, k):\r\n    for ai in (a + i, a - i):\r\n    if ai > 1:\r\n    j = n * k - i\r\n    for bj in (b + j, b - j):\r\n    if bj > 1 and gcd(ai, bj) > 1:\r\n    return n\r\n",
  "64cf5ba625e2160051ad8b71": "from collections import defaultdict, deque\r\n\r\n\r\ndef finish_all(edges):\r\n    n_entrants = defaultdict(int)\r\n    succs = defaultdict(list)\r\n    for b, a in edges:\r\n    n_entrants[b] += 1\r\n    n_entrants[a] += 0\r\n    succs[a]. append(b)\r\n\r\n    q = deque(k for k, n in n_entrants . items() if not n)\r\n    while q:\r\n    a = q . popleft()\r\n    del n_entrants[a]\r\n    for b in succs[a]:\r\n    n_entrants[b] -= 1\r\n    if not n_entrants[b]:\r\n        q . append(b)\r\n    return not n_entrants\r\n",
  "64cfc5f033adb608e2aaedef": "memo = [0] * (10 * * 7)\r\n\r\n\r\ndef solve_using_prev(n):\r\n    memo[n] = memo[n - sum(int(x) for x in str(n))] + 1\r\n    for n in range(1, 8):\r\n        solve_using_prev(n)\r\n    for n in range(9, 10 * * 7, 9):\r\n        solve_using_prev(n)\r\n\r\n    def jump_to_zero(a): return [memo[x - sum(int(x)\r\n                                              for x in str(x))] + 1 for x in a]\r\n",
  "64cf34314e8a905162e32ff5": "def smallest_transform(num):\r\n    lst = [int(i) for i in str(num)]\r\n    number = []\r\n    for i in range(min(lst), max(lst) + 1):\r\n    total = 0\r\n    for k in lst:\r\n    total += abs(k - i)\r\n    number . append(total)\r\n    return min(number)\r\n",
  "64cbc840129300011fa78108": "from gmpy2 import iroot\n\n\ndef root_sum(n):\n    return sum(r[0] for k in range(1, n . bit_length() + 1) if (r := iroot(n, k))[1])\n",
  "64cac86333ab6a14f70c6fb6": "def check_logs(log): return sum(\n    a >= b for a, b in zip(log, log[1:])) + bool(log)\n",
  "64c64be38f9e4603e472b53a": "from math import ceil\n\n\ndef legal_backlog(cases, mds):\n    return max(ceil(sum(cases . values()) / mds), max(cases . values()))\n",
  "64c7bbad0a2a00198657013d": "from itertools import groupby\r\n\r\n\r\ndef rev_sub(arr):\r\n    r = []\r\n    for i in [list(g) for n, g in groupby(arr, key=lambda x: x % 2)]:\r\n    if i[0] % 2:\r\n    r += i\r\n    else:\r\n    r += i[:: - 1]\r\n    return r\r\n",
  "64c766dd16982000173d5ba1": "class Menu:\r\n    def __init__(self, menu: list) - > None:\r\n    self . menu = menu\r\n    self . index = 0\r\n    self . length = len(menu)\r\n\r\n    def to_the_right(self) - > None:\r\n    self . index = (self . index + 1) % self . length\r\n    def to_the_left(self) - > None:\r\n    self . index = (self . index - 1) % self . length\r\n    def display(self) - > str:\r\n    temp = self . menu . copy()\r\n    temp[self . index] = [self . menu[self . index]]\r\n    return str(temp)\r\n",
  "64c743cb0a2a00002856ff73": "def switch_gravity(lst):\r\n    return list(map(list, zip(* map(sorted, zip(* lst)))))[:: - 1]\r\n",
  "64c5886e24409ea62aa0773a": "class C:\r\n    def __init__(self, fn): self . fn = fn\r\n    def __call__(self, * args, * * kwargs): return self . fn(* args, * * kwargs)\r\n\r\n    IncrementMe = C(lambda v: v + 1)\r\n    DoubleMe = C(lambda v: v * 2)\r\n    AmIEven = C(lambda v: v % 2 == 0)\r\n\r\n    def Map(fn): return C(lambda l: list(map(fn, l)))\r\n    def Filter(fn): return C(lambda l: list(filter(fn, l)))\r\n\r\n    def do_the_magic(kls):\r\n    for k, p in kls . __annotations__ . items():\r\n    if isinstance(p, C):\r\n        setattr(kls, k, p(getattr(kls, k)))\r\n",
  "64c45287edf1bc69fa8286a3": "def solution(s):\r\n    res, cur = [], [s[0]]\r\n    for x in s[1:]:\r\n    if ord(x) - ord(cur[- 1]) == 1:\r\n    cur . append(x)\r\n    else:\r\n    res . extend(cur[:: - 1])\r\n    cur = [x]\r\n\r\n    return '' . join(res + cur[:: - 1])\r\n",
  "64bd5ff1bb8f1006708e545e": "def secret_number(n):\r\n    return bin(n). count(str(n % 2)) * * 2\r\n",
  "64be81b50abf66c0147de761": "def find_missing_number(m):\r\n    L, s = 0, 0\r\n    while m . read():\r\n    L += 1\r\n    s ^= L\r\n    m . nand(m . R1, m . R0, m . R3)\r\n    m . nand(m . R2, m . R0, m . R1)\r\n    m . nand(m . R1, m . R1, m . R3)\r\n    m . nand(m . R3, m . R2, m . R1)\r\n    m . nand(m . R0, m . R3, 65535)\r\n    s ^= (~ m . output()) & 65535\r\n    return s\r\n",
  "64be6f070381860017dba5ab": "def hex_distance(grid):\r\n    flat = \"\" . join(grid)\r\n    size = len(grid[0])\r\n\r\n    # find start + end coordinates\r\n    start = flat . find(\"x\")\r\n    end = flat[start + 1:]. find(\"x\") + start + 1\r\n    x1, y1 = divmod(start, size)\r\n    x2, y2 = divmod(end, size)\r\n\r\n    # calculate distance\r\n    dx = x2 - x1\r\n    dy = abs(y2 - y1)\r\n    dy = max(dy - dx, 0) / / 2\r\n    return dx + dy\r\n",
  "64be5c99c9613c0329bc7536": "def is_polygonal(n):\r\n    a = 1\r\n    th = \"4567890\"\r\n    poly = []\r\n    while (a * (a + 1) / 2) < n - 1:\r\n    num_check = (n - 1) / (a * (a + 1) / 2)\r\n    if num_check . is_integer() and num_check > 2:\r\n    if 10 <= a % 100 <= 20 or str(a)[len(str(a)) - 1:] in th:\r\n    poly . append(f\" { int ( a )} th { int ( num_check )} -gonal number\")\r\n    elif str(a)[len(str(a)) - 1:] == \"1\":\r\n    poly . append(f\" { int ( a )} st { int ( num_check )} -gonal number\")\r\n    elif str(a)[len(str(a)) - 1:] == \"2\":\r\n    poly . append(f\" { int ( a )} nd { int ( num_check )} -gonal number\")\r\n    elif str(a)[len(str(a)) - 1:] == \"3\":\r\n    poly . append(f\" { int ( a )} rd { int ( num_check )} -gonal number\")\r\n    a += 1\r\n    return poly[:: - 1]\r\n",
  "64b84ed4b46f91004b493d87": "TREE = {'guess': '1+2=3', 'feedback': {'GGGGG': {'val': '1+2=3'}, 'GGBGR': {'val': '1+3=4'}, 'GGBGB': {'guess': '1+2=3', 'feedback': {'GGBGB': {'guess': '1+3=4', 'feedback': {'GGBGR': {'val': '1+4=5'}, 'GGBGB': {'guess': '2+6=8', 'feedback': {'BGRGB': {'val': '1+5=6'}, 'BGGGB': {'val': '1+6=7'}, 'BGBGG': {'val': '1+7=8'}, 'BGBGR': {'val': '1+8=9'}, 'BGBGB': {'val': '1+0=1'}}}}}}}, 'BBRGR': {'guess': '1+2=3', 'feedback': {'BBRGR': {'guess': '1+2=3', 'feedback': {'BBRGR': {'guess': '1+5=6', 'feedback': {'BBBGG': {'val': '2*3=6'}, 'BBRGB': {'val': '5-3=2'}, 'BBBGR': {'val': '6/3=2'}}}}}}}, 'BBRGB': {'guess': '1+2=3', 'feedback': {'BBRGB': {'guess': '1+3=4', 'feedback': {'BBBGR': {'guess': '1+7=8', 'feedback': {'BBBGG': {'val': '2*4=8'}, 'BBBGB': {'val': '6-4=2'}, 'BBBGR': {'val': '8/4=2'}}}, 'BBBGB': {'guess': '7-1=6', 'feedback': {'GGBGB': {'val': '7-5=2'}, 'BGBGR': {'val': '8-6=2'}, 'RGBGB': {'val': '9-7=2'}, 'BBBGB': {'val': '2*0=0'}, 'BGBGB': {'val': '2-0=2'}}}}}}}, 'RGRGG': {'val': '2+1=3'}, 'BGRGR': {'val': '2+3=5'}, 'BGRGB': {'guess': '1+2=3', 'feedback': {'BGRGB': {'guess': '1+2=3', 'feedback': {'BGRGB': {'guess': '1+6=7', 'feedback': {'BGRGB': {'val': '2+4=6'}, 'BGBGG': {'val': '2+5=7'}, 'BGGGB': {'val': '2+6=8'}, 'BGBGR': {'val': '2+7=9'}, 'BGBGB': {'val': '2+0=2'}}}}}}}, 'BBGGR': {'val': '3*2=6'}, 'RGBGR': {'val': '3+1=4'}, 'BGGGR': {'val': '3+2=5'}, 'BGBGR': {'guess': '1+2=3', 'feedback': {'BGBGR': {'guess': '1+3=4', 'feedback': {'BGRGR': {'val': '3+4=7'}, 'BGRGB': {'guess': '1+4=5', 'feedback': {'BGBGR': {'val': '3+5=8'}, 'BGBGB': {'val': '3+6=9'}}}, 'BGGGR': {'val': '4+3=7'}, 'BGGGB': {'guess': '1+5=6', 'feedback': {'BGRGB': {'val': '5+3=8'}, 'BGBGR': {'val': '6+3=9'}, 'BGBGG': {'val': '3+3=6'}}}}}}}, 'RBRGR': {'val': '3-1=2'}, 'RBGGR': {'val': '3-2=1'}, 'BBGGB': {'guess': '1+2=3', 'feedback': {'BBGGB': {'guess': '1+3=4', 'feedback': {'BBBGR': {'guess': '3-1=2', 'feedback': {'BBBGR': {'val': '4*2=8'}, 'BGBGG': {'val': '4-2=2'}, 'BBBGG': {'val': '4/2=2'}}}, 'BBBGG': {'guess': '2*3=6', 'feedback': {'RBBGR': {'val': '6-2=4'}, 'RBBGB': {'val': '8/2=4'}, 'GGBGB': {'val': '2*2=4'}}}, 'BBBGB': {'guess': '7*0=0', 'feedback': {'GBBGB': {'val': '7-2=5'}, 'BBBGB': {'val': '8-2=6'}, 'RBBGB': {'val': '9-2=7'}, 'BGRGG': {'val': '0*2=0'}, 'BBRGG': {'val': '0/2=0'}, 'BBBGG': {'val': '2-2=0'}}}}}}}, 'RGBGB': {'guess': '1+2=3', 'feedback': {'RGBGB': {'guess': '1+3=4', 'feedback': {'RGBGR': {'val': '4+1=5'}, 'RGBGB': {'guess': '6+2=8', 'feedback': {'RGBGB': {'val': '5+1=6'}, 'GGBGB': {'val': '6+1=7'}, 'BGBGG': {'val': '7+1=8'}, 'BGBGR': {'val': '8+1=9'}, 'BGBGB': {'val': '0+1=1'}}}}}}}, 'BGGGB': {'guess': '1+2=3', 'feedback': {'BGGGB': {'guess': '1+3=4', 'feedback': {'BGBGR': {'val': '4+2=6'}, 'BGBGB': {'guess': '1+6=7', 'feedback': {'BGBGG': {'val': '5+2=7'}, 'BGRGB': {'val': '6+2=8'}, 'BGBGR': {'val': '7+2=9'}, 'BGBGB': {'val': '0+2=2'}}}, 'BGBGG': {'val': '2+2=4'}}}}}, 'BGBGB': {'guess': '1+4=5', 'feedback': {'BGRGR': {'val': '4+5=9'}, 'BGGGR': {'val': '5+4=9'}, 'BGGGB': {'guess': '1+2=3', 'feedback': {'BGBGB': {'guess': '1+3=4', 'feedback': {'BGBGG': {'val': '0+4=4'}, 'BGBGR': {'val': '4+4=8'}}}}}, 'BGBGG': {'guess': '1+2=3', 'feedback': {'BGBGB': {'guess': '1+5=6', 'feedback': {'BGGGB': {'val': '0+5=5'}, 'BGRGB': {'val': '5+0=5'}}}}}, 'BGBGB': {'guess': '1+6=7', 'feedback': {'BGGGB': {'val': '0+6=6'}, 'BGBGG': {'guess': '1+7=8', 'feedback': {'BGGGB': {'val': '0+7=7'}, 'BGRGB': {'val': '7+0=7'}}}, 'BGBGB': {'guess': '9-8=1', 'feedback': {'BBGGB': {'val': '0+8=8'}, 'RBBGB': {'val': '0+9=9'}, 'BBRGB': {'val': '8+0=8'}, 'GBBGB': {'val': '9+0=9'}, 'BBBGB': {'val': '0+0=0'}}}, 'BGRGB': {'val': '6+0=6'}}}, 'BGRGB': {'val': '4+0=4'}}}, 'RBBGG': {'guess': '1+2=3', 'feedback': {'RBBGG': {'guess': '1+2=3', 'feedback': {'RBBGG': {'guess': '2*4=8', 'feedback': {'BBRGB': {'val': '4-1=3'}, 'BGBGB': {'val': '3*1=3'}, 'BBBGB': {'val': '3/1=3'}}}}}}}, 'RBBGR': {'guess': '1+2=3', 'feedback': {'RBBGR': {'guess': '1+2=3', 'feedback': {'RBBGR': {'guess': '1+3=4', 'feedback': {'RBGGR': {'val': '4-3=1'}, 'RBGGB': {'val': '3/3=1'}}}}}}}, 'RBBGB': {'guess': '1+4=5', 'feedback': {'RBRGR': {'val': '5-1=4'}, 'RBGGR': {'val': '5-4=1'}, 'RBBGG': {'guess': '1+2=3', 'feedback': {'RBBGB': {'guess': '2*3=6', 'feedback': {'BBBGR': {'val': '6-1=5'}, 'BGBGB': {'val': '5*1=5'}, 'BBBGB': {'val': '5/1=5'}}}}}, 'RBBGR': {'guess': '1+2=3', 'feedback': {'RBBGB': {\r\n    'guess': '1+5=6', 'feedback': {'RBGGR': {'val': '6-5=1'}, 'RBGGB': {'val': '5/5=1'}}}}}, 'RBBGB': {'guess': '6+1=7', 'feedback': {'RBGGR': {'val': '7-1=6'}, 'RBRGR': {'val': '7-6=1'}, 'BBGGG': {'guess': '2*4=8', 'feedback': {'BBBGR': {'val': '8-1=7'}, 'BGBGB': {'val': '7*1=7'}, 'BBBGB': {'val': '7/1=7'}}}, 'BBRGR': {'guess': '1+7=8', 'feedback': {'RBGGR': {'val': '8-7=1'}, 'RBGGB': {'val': '7/7=1'}}}, 'BBGGB': {'guess': '8*0=0', 'feedback': {'RBBGB': {'val': '9-1=8'}, 'BGRGG': {'val': '0*1=0'}, 'BBRGG': {'val': '0/1=0'}, 'GGBGB': {'val': '8*1=8'}, 'GBBGB': {'val': '8/1=8'}, 'BGBGB': {'val': '9*1=9'}, 'BBBGB': {'val': '9/1=9'}}}, 'BBRGB': {'guess': '1+8=9', 'feedback': {'RBGGR': {'val': '9-8=1'}, 'RBGGB': {'val': '8/8=1'}, 'RBBGR': {'val': '9/9=1'}}}, 'GBGGB': {'guess': '2*3=6', 'feedback': {'BGBGG': {'val': '6*1=6'}, 'BBBGG': {'val': '6/1=6'}}}, 'GBRGB': {'val': '6/6=1'}}}, 'RBRGB': {'guess': '1+2=3', 'feedback': {'RBBGB': {'guess': '2*3=6', 'feedback': {'BGBGB': {'val': '4*1=4'}, 'BBBGB': {'val': '4/1=4'}}}}}, 'RBGGB': {'val': '4/4=1'}}}, 'BBGGG': {'guess': '1+2=3', 'feedback': {'BBGGG': {'guess': '1+2=3', 'feedback': {'BBGGG': {'guess': '1+4=5', 'feedback': {'BBBGR': {'val': '5-2=3'}, 'BBBGB': {'val': '6/2=3'}}}}}}}, 'BBBGR': {'guess': '1+2=3', 'feedback': {'BBBGR': {'guess': '1+3=4', 'feedback': {'BBGGG': {'val': '7-3=4'}, 'BBGGB': {'guess': '0*5=0', 'feedback': {'BBRGB': {'val': '8-3=5'}, 'BBBGB': {'val': '9-3=6'}, 'GGBGG': {'val': '0*3=0'}, 'GBBGG': {'val': '0/3=0'}, 'BGBGB': {'val': '3*3=9'}, 'BBBGG': {'val': '3-3=0'}}}, 'BBRGB': {'val': '3*0=0'}}}}}, 'BBBGG': {'guess': '1+2=3', 'feedback': {'BBBGG': {'guess': '1+3=4', 'feedback': {'BBRGR': {'val': '7-4=3'}, 'BBRGB': {'guess': '1+5=6', 'feedback': {'BBGGB': {'val': '8-5=3'}, 'BBBGR': {'val': '9-6=3'}, 'BBBGB': {'val': '3-0=3'}}}, 'BBGGB': {'guess': '1+5=6', 'feedback': {'BBBGR': {'val': '6-3=3'}, 'BBBGB': {'val': '9/3=3'}}}}}}}, 'BBBGB': {'guess': '1+5=6', 'feedback': {'BBRGB': {'guess': '1+2=3', 'feedback': {'BBBGB': {'guess': '1+4=5', 'feedback': {'BBGGG': {'val': '9-4=5'}, 'BBBGR': {'val': '5*0=0'}, 'BBBGG': {'val': '5-0=5'}}}}}, 'BBGGB': {'guess': '1+2=3', 'feedback': {'BBBGB': {'guess': '0*1=0', 'feedback': {'BBBGB': {'val': '9-5=4'}, 'GGBGG': {'val': '0*5=0'}, 'GBBGG': {'val': '0/5=0'}, 'BBBGG': {'val': '5-5=0'}}}}}, 'BBBGB': {'guess': '2*4=8', 'feedback': {'BGGGB': {'val': '0*4=0'}, 'BGBGB': {'guess': '9-7=2', 'feedback': {'BBGGB': {'val': '0*7=0'}, 'RBBGB': {'val': '0*9=0'}, 'BBRGB': {'val': '7*0=0'}, 'GBBGB': {'val': '9*0=0'}, 'BBBGB': {'val': '0*0=0'}}}, 'BGBGR': {'guess': '1+8=9', 'feedback': {'BBGGB': {'val': '0*8=0'}, 'BBRGB': {'val': '8*0=0'}}}, 'BBGGB': {'guess': '3-1=2', 'feedback': {'BBBGB': {'val': '0/4=0'}, 'BGBGB': {'val': '4-4=0'}}}, 'BBBGB': {'guess': '0/7=0', 'feedback': {'GGGGG': {'val': '0/7=0'}, 'GGBGG': {'val': '0/9=0'}, 'RBRGB': {'val': '7-0=7'}, 'BBGGG': {'val': '7-7=0'}, 'RBBGB': {'val': '9-0=9'}, 'BBBGG': {'val': '9-9=0'}, 'GBBGG': {'val': '0-0=0'}}}, 'BBBGR': {'guess': '3-1=2', 'feedback': {'BBBGB': {'val': '0/8=0'}, 'BGBGB': {'val': '8-8=0'}}}, 'BGRGB': {'val': '4*0=0'}, 'BBRGB': {'val': '4-0=4'}, 'BBBGG': {'val': '8-0=8'}, 'BBGGR': {'val': '8-4=4'}}}, 'BBBGR': {'guess': '1+2=3', 'feedback': {'BBBGB': {'guess': '0*1=0', 'feedback': {'GGBGG': {'val': '0*6=0'}, 'GBBGG': {'val': '0/6=0'}, 'RGBGG': {'val': '6*0=0'}, 'BBBGG': {'val': '6-6=0'}}}}}, 'BBBGG': {'val': '6-0=6'}}}, 'BGBGG': {'guess': '1+2=3', 'feedback': {'BGBGG': {'guess': '1+2=3', 'feedback': {'BGBGG': {'guess': '1+3=4', 'feedback': {'BGGGB': {'val': '0+3=3'}, 'BGRGB': {'val': '3+0=3'}}}}}}}, 'GBBGB': {'guess': '1+4=5', 'feedback': {'GBBGB': {'guess': '6+1=7', 'feedback': {'BBRGB': {'guess': '9-1=8', 'feedback': {'BBRGB': {'val': '1*0=0'}, 'BBRGG': {'val': '1*8=8'}, 'RBRGB': {'val': '1*9=9'}, 'BGRGB': {'val': '1-0=1'}}}, 'RBRGB': {'val': '1*6=6'}, 'BBRGG': {'val': '1*7=7'}, 'BBGGB': {'guess': '0*1=0', 'feedback': {'BBGGG': {'val': '1-1=0'}, 'BGGGB': {'val': '1*1=1'}, 'BBGGB': {'val': '1/1=1'}}}}}, 'GBGGB': {'val': '1*4=4'}, 'GBBGG': {'val': '1*5=5'}}}, 'GBGGB': {'val': '1*2=2'}, 'GBBGG': {'val': '1*3=3'}, 'GGRGB': {'val': '1+1=2'}, 'RBRGB': {'guess': '1+2=3', 'feedback': {'RBRGB': {'guess': '1+2=3', 'feedback': {'RBRGB': {'guess': '6/3=2', 'feedback': {'BBBGG': {'val': '2*1=2'}, 'BBBGR': {'val': '2-1=1'}, 'BGBGG': {'val': '2/1=2'}}}}}}}, 'RBGGB': {'val': '2/2=1'}}}\r\n\r\n\r\ndef solve_micro_nerdle(history):\r\n    tree = TREE\r\n    for p, v in history:\r\n        tree = tree['feedback'][v]\r\n    return tree.get('val', tree.get('guess', None))\r\n",
  "64bc4a428e1e9570fd90ed0d": "import numpy as np\r\nMOD = 1000000007\r\n\r\n\r\ndef matrix_exp(Q, n):\r\n    if n == 0:\r\n    return np . array([[1, 0], [0, 1]], dtype=object)\r\n    return (Q @ matrix_exp(Q, n - 1) if n & 1 else matrix_exp((Q @ Q) % MOD, n >> 1)) % MOD\r\n    def ways(n, k):\r\n    return (matrix_exp(np . array([[k - 1, k - 1],\r\n                                   [1, 0]], dtype=object), n - 1) @ np . array([k * k, k], dtype=object))[1] % MOD\r\n",
  "64b8c6c09416795eb9fbdcbf": "def rep_set(n):\r\n    return [rep_set(k) for k in range(n)]\r\n",
  "64b1727867b45c41a262c072": "from itertools import chain\r\n\r\n\r\ndef team_dinner(available: list[list[int]]) - > int | None:\r\n    res = list(chain . from_iterable(available))\r\n    res = {i: res . count(i) for i in res}\r\n    result = []\r\n    for k, v in res . items():\r\n    if v >= len(available) / 2 and v == max(res . values()):\r\n    result . append(k)\r\n    if not result:\r\n    return None\r\n    elif len(result) == 1:\r\n    return result[0]\r\n    else:\r\n    res = dict . fromkeys(result, 0)\r\n    for day in result:\r\n    for person in available:\r\n    if day in person:\r\n    res[day] += len(person)\r\n    result = []\r\n    for k, v in res . items():\r\n    if v == max(res . values()):\r\n    result . append(k)\r\n\r\n    return sorted(result)[0]\r\n",
  "64b7c3e6e0abed000f6cad6c": "def block_player(a, b):\r\n    y1, x1 = divmod(a, 3)\r\n    y2, x2 = divmod(b, 3)\r\n    y3 = (y2 + (y2 - y1)) % 3\r\n    x3 = (x2 + (x2 - x1)) % 3\r\n    return y3 * 3 + x3\r\n",
  "64b7c03910f916000f493f5d": "def climbing_stairs(cost):\r\n    a = b = 0\r\n    for c in cost:\r\n    a, b = b, min(a, b) + c\r\n    return min(a, b)\r\n",
  "64b76b580ca7392eca9f886b": "def moving_particles(lst):\r\n    cur, ls = 0, lst[:]\r\n\r\n    while cur < len(ls) - 1:\r\n    if ls[cur] > 0 and ls[cur + 1] < 0:\r\n    ls[cur: cur + 2] = [(ls[cur] - ls[cur + 1]) *\r\n                        (- 1 if ls[cur] < - ls[cur + 1] else 1)]\r\n    cur = max(cur - 1, 0)\r\n    else:\r\n    cur += 1\r\n    return ls\r\n",
  "64b779a194167920ebfbdd2e": "from operator import itemgetter\r\n\r\n\r\ndef len_longest_chain(pairs):\r\n    res, x = 0, float('-inf')\r\n    for a, b in sorted(pairs, key=itemgetter(1)):\r\n    if x < a:\r\n    res, x = res + 1, b\r\n    return res\r\n",
  "64b771989416793927fbd2bf": "def closed_brackets(s):\n    a, b = 0, 0\n    for c in s:\n    if c == \")\" and b == 0:\n    return False\n    a = a + 1 if c == \"(\" else a and a - 1\n    b = b - 1 if c == \")\" else b + 1\n    return not a\n",
  "64b63c024979c9001f9307e4": "import re\r\n\r\n\r\ndef type_out(src):\r\n    dst = src . split('[', 1)[0]\r\n    for mo in re . finditer(r'\\[(\\w+)\\]([^\\[]+)', src):\r\n    match mo[1]:\r\n    case 'shift':\r\n    dst += mo[2][0]. upper() + mo[2][1:]\r\n    case 'holdshift':\r\n    dst += mo[2]. upper()\r\n    case 'unshift':\r\n    dst += mo[2]\r\n    return dst\r\n",
  "64b686e74979c90017930d57": "from functools import partial\r\nfrom re import compile\r\n\r\n\r\ndef helper(x):\r\n    r, i, l = x . groups()\r\n    if not (l or r):\r\n        return i\r\n    v = len(i)\r\n    if not l:\r\n        return \"R\" * (v + 1)\r\n    if not r:\r\n        return \"L\" * (v + 1)\r\n    q, r = divmod(v, 2)\r\n    return \"R\" * (q + 1) + \"I\" * r + \"L\" * (q + 1)\r\n\r\n    dominoes_fall = partial(compile(r\"(R?)(I+)(L?)\"). sub, helper)\r\n",
  "64b6722493f1050058dc3f98": "def eval_parentheses(s):\r\n    st = [0]\r\n    for c in s:\r\n    if c == '(':\r\n    st . append(0)\r\n    else:\r\n    x = st . pop()\r\n    st[- 1] += 2 * x or 1\r\n    return st . pop()\r\n",
  "64b6698c94167906c3fbd6c4": "from scipy . signal import correlate2d\n\n\ndef max_overlap(img1, img2):\n    return correlate2d(img1, img2). max()\n",
  "64b41e7c1cefd82a951a303e": "from itertools import combinations as combs\r\n\r\n\r\ndef configure_bar(goal, gym):\r\n    d = {plate: 2 * int(plate[1: - 3]) - len(str(plate)) for plate in gym}\r\n    w = sorted([d[plate] for plate in gym])\r\n    s = {v: k for k, v in d . items()}\r\n\r\n    for n in [2, 4, 6]:\r\n    for load in combs(w, n):\r\n    if 40 + sum(load) != goal * 2:\r\n    continue\r\n    right, left = load[1:: 2], load[- 2:: - 2]\r\n    r, l = [sum(len(s[p]) for p in side) for side in (right, left)]\r\n\r\n    if l >= 18 or r >= 18:\r\n    return ':('\r\n    return f\"-- { '' . join ([ s [ p ] for p in left ])}{ '-' * ( 36 - r - l )}{ '' . join ([ s [ p ] for p in right ])} --\"\r\n    return ':('\r\n",
  "64b2b04e22ad520058ce22bd": "from collections import defaultdict\r\nfrom functools import reduce\r\nfrom itertools import pairwise\r\nfrom operator import or_\r\nfrom gmpy2 import is_prime, next_prime\r\n\r\n\r\ndef get_neighbours():\r\n    primes = {p for p in range(1000, 9999) if is_prime(p)}\r\n    table = defaultdict(list)\r\n    for n in primes:\r\n    for a, b in pairwise((10_000, 1_000, 100, 10, 1)):\r\n    stop = n + a - n % a\r\n    for m in range(n + b, stop, b):\r\n    if m in primes:\r\n    table[n]. append(m)\r\n    table[m]. append(n)\r\n    return table\r\n    neighbours = get_neighbours()\r\n\r\n    def find_shortest_path(start, end):\r\n    paths = {start: [start]}\r\n    seen = {start}\r\n    while end not in paths:\r\n    seen . update(paths)\r\n    paths = reduce(or_, ({q: path + [q] for q in neighbours[p]\r\n                   if q not in seen} for p, path in paths . items()))\r\n    return paths[end]\r\n",
  "64a6e4dbb2bc0500171d451b": "segments = {\r\n    ' ': 0b0000000,\r\n    '0': 0b1111110,\r\n    '1': 0b0110000,\r\n    '2': 0b1101101,\r\n    '3': 0b1111001,\r\n    '4': 0b0110011,\r\n    '5': 0b1011011,\r\n    '6': 0b1011111,\r\n    '7': 0b1110000,\r\n    '8': 0b1111111,\r\n    '9': 0b1111011\r\n}\r\n\r\n\r\ndef count_segment_switches(display_size, sequence):\r\n    old = ' ' * display_size\r\n    switches = 0\r\n    for i in sequence:\r\n    new = str(i). rjust(display_size)\r\n    for old_dig, new_dig in zip(old, new):\r\n    switches += (segments[old_dig] ^ segments[new_dig]). bit_count()\r\n    old = new\r\n    return switches\r\n",
  "64ad571aa33413003e712168": "f = magic_show = lambda a: len(a) and (\n    a[0] == 'Y') - ~ (a[0] in 'YN') * f(a[1:])\n",
  "64a815e3e96dec077e305750": "import math\r\nimport heapq\r\n\r\n\r\nclass DisjointSetUnion:\r\n    def __init__(self, n):\r\n    self . parent = list(range(n))\r\n    self . size = [1] * n\r\n    def find(self, x):\r\n    if self . parent[x] != x:\r\n    self . parent[x] = self . find(self . parent[x])\r\n    return self . parent[x]\r\n\r\n    def union(self, x, y):\r\n    px, py = self . find(x), self . find(y)\r\n    if px == py:\r\n        return False\r\n    if self . size[px] > self . size[py]:\r\n    px, py = py, px\r\n    self . size[py] += self . size[px]\r\n    self . parent[px] = py\r\n    return True\r\n    # Kruskal\u2019s Minimum Spanning Tree\r\n    def bridge(islands):\r\n    heap = [(d, i, j) for i, p in enumerate(islands) for j, q in enumerate(\r\n        islands[i + 1:], i + 1) if (d := math . dist(p, q)) < 5000]\r\n    heapq . heapify(heap)\r\n    cost, edges_left = 0, len(islands) - 1\r\n    dsu = DisjointSetUnion(len(islands))\r\n    while heap:\r\n    dist, i, j = heapq . heappop(heap)\r\n    if dsu . union(i, j):\r\n    cost += dist\r\n    edges_left -= 1\r\n    if edges_left == 0:\r\n        break\r\n    return cost\r\n",
  "6474b8964386b6795c143fd8": "import re\r\nREQUIRED_ELEMENTS = {'H', 'C', 'N', 'O', 'P', 'Ca'}\r\n\r\n\r\ndef best_planet(solar_system, max_size):\r\n    candidates = []\r\n\r\n    for planet in solar_system:\r\n        # Parse the planet\r\n    elements, area = planet . split('_', 1)\r\n\r\n    area = int(area)\r\n    if area > max_size:\r\n    continue\r\n    elements = set(re . findall('[A-Z][a-z]?', elements))\r\n\r\n    if REQUIRED_ELEMENTS <= elements:\r\n    candidates . append((area, planet))\r\n\r\n    if not candidates:\r\n    return ''\r\n    candidates . sort()\r\n    return candidates[- 1][1]\r\n",
  "6495a5ad802ef5000eb70b91": "from preloaded import WORDS\r\nfrom itertools import product\r\nDIRS = set(product(range(- 1, 2), repeat=2)) - {(0, 0)}\r\n\r\n\r\nclass Trie:\r\n\r\n    def __init__(self):\r\n    self . root = {}\r\n\r\n    def insert(self, word):\r\n    cur = self . root\r\n    for char in word:\r\n    if char not in cur:\r\n    cur[char] = {}\r\n    cur = cur[char]\r\n    cur['#'] = ''\r\n    trie = Trie()\r\n    for word in WORDS:\r\n    trie . insert(word)\r\n\r\n    def squaredle(puzzle):\r\n\r\n    def dfs(x, y, snake, t):\r\n    if len(snake) > 3 and '#' in t:\r\n    res . add(snake)\r\n    for dx, dy in DIRS:\r\n    i, j = x + dx, y + dy\r\n    if N > i >= 0 <= j < M and grid[i][j] != ' ' and not seen[i][j]:\r\n    seen[i][j] = 1\r\n    char = grid[i][j]\r\n    if char in t:\r\n    dfs(i, j, snake + char, t[char])\r\n    seen[i][j] = 0\r\n    res = set()\r\n    grid = puzzle . split('-')\r\n    N, M = len(grid), len(grid[0])\r\n    for i, j in product(range(N), range(M)):\r\n    char = grid[i][j]\r\n    if char != ' ':\r\n    seen = [[0] * M for _ in range(N)]\r\n    seen[i][j] = 1\r\n    if char in trie . root:\r\n    dfs(i, j, char, trie . root[char])\r\n\r\n    return sorted(res, key=lambda w: (len(w), w))\r\n",
  "649c4012aaad69003f1299c1": "def rgb_to_grayscale(color):\r\n    \"\"\" #Assumes format: #RRGGBB \r\n    Multiply and accumulate converted(str_hex->int) RR/GG/BB with corresponding luminance values. \r\n    Convert the rounded result back to str_hex and remove the '0x' in front \r\n    Add a '#' and use the str_hex result three times. \r\n    \"\"\"\r\n    return '#' + 3 * format(round(0.299 * int(color[1: 3], 16)\r\n                                  + 0.587 * int(color[3: 5], 16)\r\n                                  + 0.114 * int(color[5: 7], 16)\r\n                                  ),\r\n                            '02X')\r\n",
  "6498aa0daff4420024ce2c88": "from itertools import count\r\nNO_SWAP = (1, 3)\r\n\r\n\r\ndef get_in_line(arr: list[int]) - > int:\r\n    arr = [v for v in reversed(arr) if not v or v > 2] + \\\r\n        [2] * arr . count(2) + [1] * arr . count(1)\r\n\r\n    for time in count(1):\r\n    match arr . pop():\r\n    case 1:\r\n    for i in range(len(arr) >> 1):\r\n    if arr[i] not in NO_SWAP and arr[- i - 1] not in NO_SWAP:\r\n    arr[i], arr[- 1 - i] = arr[- i - 1], arr[i]\r\n    case 0:\r\n    return time\r\n    case _:\r\n    return time + len(arr) - arr . index(0)\r\n",
  "6493682fbefb70000fc0bdff": "def no_adjacent_subsequences(lst):\r\n    xs, ys = [[]], [[]]\r\n    for v in lst:\r\n    xs, ys = ys, ys + [x + [v] for x in xs]\r\n    return ys\r\n",
  "648f2033d52f51608e06c458": "def count_skills(tree, required):\r\n    skils = set()\r\n    for r in required:\r\n    while r not in skils:\r\n    skils . add(r)\r\n    r = tree[r]\r\n    return len(skils)\r\n",
  "6484e0e4fdf80be241d85878": "def average_to_binary(n):\r\n    res, ln = {'x' + f' { n : b } ' [1:]\r\n               } if n > 1 else {f' { n } '}, len(f' { n : b } ')\r\n\r\n    for k in range(ln - 2):\r\n    cand = f' { n - 2 * * k : b } '\r\n    if cand[- k - 2] == '0':\r\n    res . add(cand[: - k - 2] + 'x' + cand[- k - 1:])\r\n\r\n    return res\r\n",
  "6440554ac7a094000f0a4837": "from functools import cache\r\nfrom itertools import chain\r\n\r\n\r\n@ cache\r\ndef f(n):\r\n    match n:\r\n    case 0.5: return []\r\n    case 0: return ['']\r\n    case 1: return ['1', 'x']\r\n    match n % 1:\r\n    case 0.5: return [s + 'x' for s in f((n - 0.5) / 2)]\r\n    case 0: return [* chain([s + 'x' for s in f((n - 0.5) / 2)],\r\n                            [s + '0' for s in f(n / 2)],\r\n                            [s + '1' for s in f((n - 1) / 2)])]\r\n    case _: return []\r\n\r\n    def average_to_binary(n):\r\n    match n:\r\n    case 0: return ['0']\r\n    case 0.5: return ['x']\r\n    case 1: return ['1']\r\n    return [s for s in f(n) if 'x' in s]\r\n",
  "647518391e258e80eedf6e06": "def create_two_sets_of_equal_sum(n):\r\n    if n % 4 in {1, 2}:\r\n        return []\r\n    return [[* range(1, n / / 4 + 1), * range(n * 3 / / 4 + 1, n + 1)], [* range(n / / 4 + 1, n * 3 / / 4 + 1)]]\r\n",
  "60983b03bdfe880040c531d6": "def solve(arr, k):\r\n    max_mean = 0\r\n    tapir = ()\r\n    for i in range(len(arr) - k + 1):\r\n    sum_slice = 0\r\n    for j in range(len(arr)):\r\n    sum_slice += arr[j]\r\n    if j + 1 >= k + i:\r\n    if sum_slice / (k + i) >= max_mean:\r\n    max_mean = sum_slice / (k + i)\r\n    tapir = (j - (k + i - 1), k + i)\r\n    sum_slice -= arr[j - (k + i - 1)]\r\n    return tapir\r\n",
  "6473603854720900496e1c82": "def step(x, y):\r\n    return int((4 * (y - x) - (y > x)) * * .5)\r\n",
  "6472390e0d0bb1001d963536": "def flip_pancakes(stack):\r\n    tp, st, res = len(stack) - 1, stack[:], []\r\n\r\n    while tp > 0:\r\n    if st[tp] != max(st[: tp + 1]):\r\n    ind = max(range(tp + 1), key=lambda k: st[k])\r\n    st = st[ind + 1: tp + 1][:: - 1] + st[: ind + 1] + st[tp + 1:]\r\n    res . extend([ind] * (ind > 0) + [tp])\r\n    tp -= 1\r\n    return res\r\n",
  "6470e15f4f0b26052c6151cd": "def create_euler_square(n):  # Assume n is odd.\n    return [[(i + j) % n + 1 for j in range(n)] for i in range(n)], \\\n        [[(2 * i + j) % n + 1 for j in range(n)] for i in range(n)]\n",
  "6469e4c905eaefffd44b6504": "def reverse_number(n, b):\r\n    if b == 1:\r\n        return n\r\n    m = 0\r\n    while n:\r\n    n, r = divmod(n, b)\r\n    m = m * b + r\r\n    return m\r\n",
  "646254375cee7a000ffaa404": "def verify_latin_square(array, m):\r\n    def validate():\r\n    if not is_square(array):\r\n    return \"Array not square\"\r\n    if not is_correct_size(array, m):\r\n    return \"Array is wrong size\"\r\n    value_error = fail_not_correct_values()\r\n    if value_error:\r\n    return value_error\r\n    return f\"Valid latin square of size { m } \"\r\n    def fail_not_correct_values():\r\n    for i, row in enumerate(array):\r\n    for j, value in enumerate(row):\r\n    if not is_within_range(value, m):\r\n    return f\" { value } at { i + 1 } , { j + 1 } is not between 1 and { m } \"\r\n    if value_occurs_more_than_once(value, row):\r\n    return f\" { value } occurs more than once in row { i + 1 } \"\r\n    for j in range(m):\r\n    column = [row[j] for row in array]\r\n    if len(set(column)) != m:\r\n    repeating_value = find_repeating_value(column)\r\n    return f\" { repeating_value } occurs more than once in column { j + 1 } \"\r\n    def is_square(array):\r\n    return all(len(row) == len(array) for row in array)\r\n\r\n    def is_correct_size(array, m):\r\n    return len(array) == m\r\n    def is_within_range(value, m):\r\n    return 1 <= value <= m\r\n    def value_occurs_more_than_once(value, row):\r\n    return row . count(value) > 1\r\n    def find_repeating_value(lst):\r\n    seen = set()\r\n    for value in lst:\r\n    if value in seen:\r\n    return value\r\n    seen . add(value)\r\n\r\n    def value_occurs_more_than_once_in_column(column, m):\r\n    for value in range(1, m + 1):\r\n    if column . count(value) > 1:\r\n    return value\r\n    return validate()\r\n",
  "64623e0ad3560e0decaeac26": "def nth_num_containing_ones(n, digit=1, base=10):\r\n    assert 0 < digit < base\r\n    n, a, nth = n - 1, [0], 0\r\n    while n >= a[- 1]:\r\n    a . append((base - 1) * a[- 1] + base * * (len(a) - 1))\r\n    a . pop()\r\n\r\n    while a:\r\n    x = a . pop()\r\n    l = base * * len(a)\r\n    if 0 <= n - digit * x < l:\r\n    nth = (base * nth + digit) * l + n - digit * x\r\n    return nth\r\n    if n >= l + digit * x:\r\n        n -= l - x\r\n    d, n = divmod(n, x)\r\n    nth = base * nth + d\r\n    return nth\r\n",
  "645fb55ecf8c290031b779ef": "def make_latin_square(n):\r\n    return [[(i + j) % n + 1 for i in range(n)] for j in range(n)]\r\n",
  "645e541f3e6c2c0038a01216": "def is_valid_train_arrangement(before, after):\n    if len(before) != len(after):\n        return False\n    l, r = 0, 0\n    for b, a in zip(before, after):\n    if b == '>':\n    if l != 0:\n        return False\n    r += 1\n    if a == '<':\n    if r != 0:\n        return False\n    l -= 1\n    if b == '<':\n    if r != 0 or l == 0:\n        return False\n    l += 1\n    if a == '>':\n    if l != 0 or r == 0:\n        return False\n    r -= 1\n    return l == 0 and r == 0\n",
  "64607242d3560e0043c3de25": "from math import floor, ceil\r\n\r\n\r\ndef less_than(s):\r\n    if s[0] == '-':\r\n    return 0\r\n    n = int(s[0:(len(s) + 1) / / 2]) + 10 * * (len(s) / / 2)\r\n    if s[- (len(s) / / 2):] < s[len(s) / / 2 - 1:: - 1]:\r\n    return n - 1\r\n    return n\r\n    def count_palindromes(a, b):\r\n    a, b = ceil(a), floor(b)\r\n    if a > b:\r\n    return 0\r\n    return less_than(str(b)) - less_than(str(a - 1))\r\n",
  "64600b4bbc880643faa343d1": "from itertools import product\nfrom operator import pow\nfrom math import prod\n\n\ndef get_dividers(values, powers):\n    return sorted(prod(map(pow, values, x)) for x in product(* (range(p + 1) for p in powers)))\n",
  "640f312ababb19a6c5d64927": "import random\r\nimport numpy\r\n\r\n\r\ndef simulate(disease_rate, false_positive_rate, n):\r\n    ntp = numpy . random . binomial(n, disease_rate)\r\n    nfp = numpy . random . binomial(n - ntp, false_positive_rate)\r\n\r\n    return [* random . sample(range(n), ntp)], ntp + nfp\r\n",
  "64553d6b1a720c030d9e5285": "class Worker ():\r\n    def __init__(self, position, direction, base):\r\n    self . position = position\r\n    self . direction = direction\r\n    self . base = base\r\n    def move(self):\r\n    if self . position == 0:\r\n    self . direction = 1\r\n    if self . position == self . base:\r\n    self . direction = - 1\r\n    self . position += self . direction\r\n    return self . position\r\n    class Coordinator:\r\n    def __init__(self, path):\r\n    self . workers = []\r\n    self . path_template = [\"M\"] + [\".\"] * (len(path) - 2) + [\"B\"]\r\n    self . parse(path)\r\n\r\n    def parse(self, path):\r\n    for i in range(len(path)):\r\n    if path[i] == \"<\":\r\n    self . workers . append(Worker(i, - 1, len(path) - 1))\r\n    elif path[i] == \">\":\r\n    self . workers . append(Worker(i, 1, len(path) - 1))\r\n\r\n    def move(self):\r\n    for worker in self . workers:\r\n    worker . move()\r\n\r\n    def get_path(self):\r\n    path = self . path_template . copy()\r\n    for worker in self . workers:\r\n    match path[worker . position]:\r\n    case \".\":\r\n    path[worker . position] = \"<\" if worker . direction < 0 else '>'\r\n    case \"M\":\r\n    path[worker . position] = \"*\"\r\n    case \"B\":\r\n    path[worker . position] = \"*\"\r\n    case \"<\":\r\n    path[worker . position] = \"#\"\r\n    case \">\":\r\n    path[worker . position] = \"#\"\r\n    return \"\" . join(path)\r\n\r\n    def simulate_mining(path, time):\r\n    result = []\r\n    map = Coordinator(path)\r\n    for i in range(time):\r\n    result . append(map . get_path())\r\n    map . move()\r\n    return result\r\n",
  "645797bd67ad1d92efea25a1": "def lfsr(size, pos, seed):\r\n    mask = sum(1 << i for i in pos)\r\n    while True:\r\n    yield seed\r\n    seed = seed >> 1 | ((seed & mask). bit_count() & 1) << size - 1\r\n",
  "5f1360c4bc96870019803ae2": "def pisano(n):\n    a, b, k = 1, 1, 1\n    while (a, b) != (0, 1):\n    a, b = b, (a + b) % n\n    k += 1\n    return k\n",
  "644ff2d6080a4001ff59a3b9": "def starting_number(n):\r\n    a, b = str(n), ''\r\n    while a != b and len(a) % 2 == 0 and '0' not in a[:: 2] and all(x != y for x, y in zip(a[1:: 2], a[3:: 2])):\r\n    a, b = '' . join(a[k + 1] * int(a[k]) for k in range(0, len(a), 2)), a\r\n    if a[0] == '0' and len(a) > 1:\r\n    return int(b)\r\n    if '00' in a or (len(a) == 2 and a[- 1] == '0' and a[0] != '1'):\r\n    return int(a)\r\n\r\n    return int(a)\r\n",
  "643a47fadad36407bf3e97ea": "def encode_cd(n):\n    if n > 255:\n    return - 1\n    forma = format(n, '08b')\n    form = forma[:: - 1]\n    res = \"P\"\n    p = 'P'\n    l = 'L'\n    for f in form:\n    if f == '1':  # 1 it is always change letter to another letter\n    p, l = l, p\n    res += p\n    return res\n",
  "644b17b56ed5527b09057987": "STRANGE_STRING = '\u00df'\n",
  "6446c0fe4e259c006511b75e": "def extract_bits(o, _, O): return o >> _ & ~ - (1 << O)\n",
  "644661194e259c035311ada7": "def mul_by_n(lst, n):\r\n    print(\"Inputs: \", lst, n)  # Check our inputs\r\n    result = [x * n for x in lst]\r\n    print(\"Result: \", result)  # Check our result\r\n    return result\r\n",
  "64416600772f2775f1de03f9": "def count_attacking_rooks(rooks):\r\n    s1 = set(item[0] for item in rooks)\r\n    s2 = set(item[1] for item in rooks)\r\n    return len(rooks) * 2 - len(s1) - len(s2)\r\n",
  "6444f6b558ed4813e8b70d43": "def graph(arr):\r\n    graph = []\r\n    top = max(arr, default=- 1)\r\n    for y in range(top, - 1, - 1):\r\n    row = []\r\n    for value in arr:\r\n    if value == y:\r\n        row . append(' ____ ')\r\n    elif value < y:\r\n        row . append('......')\r\n    else:\r\n        row . append('| |')\r\n    row . append(f' { \"^|\" [ y < top ]} { y } ')\r\n    graph . append('' . join(row))\r\n    return '\\n' . join(graph)\r\n",
  "643ea1adef815316e5389d17": "def quadrant_segment(A, B):\n    A = A[0] < 0, A[1] < 0\n    B = B[0] < 0, B[1] < 0\n    return A != B\n",
  "643af0fa9fa6c406b47c5399": "def quadrant(x, y): return ((1, 2), (4, 3))[y < 0][x < 0]\n",
  "643869cb0e7a563b722d50ad": "import requests\r\n\r\n\r\ndef wikidata_scraper(url):\r\n    res = requests . get(url). json()\r\n    entry = list(res['entities']. values())[0]\r\n\r\n    return {\r\n        \"ID\": entry['id'],\r\n        \"LABEL\": entry['labels']. get('en', {'value': 'No Label'})['value'],\r\n        \"DESCRIPTION\": entry['descriptions']. get('en', {'value': 'No Description'})['value'],\r\n    }\r\n",
  "64348795d4d3ea00196f5e76": "def binary_average(binary):\r\n    if len(binary) > 1 and binary[0] == 'x':\r\n    binary = '1' + binary[1:]\r\n    a = int(binary . replace('x', '1'), 2)\r\n    b = int(binary . replace('x', '0'), 2)\r\n    return (a + b) / 2\r\n",
  "642eba25b8c5c20031058225": "from gmpy2 import RoundDown, RoundUp, context\r\nfrom sys import float_info\r\n\r\n\r\ndef ifloor(n: int) - > float:\r\n    return float(context(round=RoundDown, emax=float_info . max_exp). rint(n))\r\n\r\n    def iceil(n: int) - > float:\r\n    return float(context(round=RoundUp, emax=float_info . max_exp). rint(n))\r\n",
  "6426b201e00c7166d61f2028": "def logical_immediate(imm64):\r\n    b = f' { imm64 :0 64 b } '\r\n    for i in range(1, 7):\r\n    l = 2 * * i\r\n    for w in range(1, l):\r\n    for immr in range(l):\r\n    z = '0' * (l - w) + '1' * w\r\n    y = (z[- immr:] + z[: - immr]) * (64 / / l)\r\n    if y == b:\r\n    r = f' { 2 * * ( 7 - i ) - 2 : 0 b }{ w - 1 : 0 { i } b } '\r\n    i, imms = '01' ['10' . index(r[0])], r[1:]\r\n    return int(f' { i }{ immr :0 6 b }{ imms } ', 2)\r\n",
  "642b375dca15841d3aaf1ede": "def f(a, b): return (b - a). bit_length()\n",
  "63e5119516648934be4c98bd": "def validate_sudoku(b, R=range): return all({* r} == {* R(1, 10)} for r in [* zip(* b)] + b + [[b[i / / 3 * 3 + j / / 3][i % 3 * 3 + j % 3] for j in R(9)] for i in R(9)])\n",
  "64294e2be00c71422d1f59c2": "from math import log\r\n# 6kyu????????????????\r\n\r\n\r\ndef f(n):\r\n    if not n:\r\n    return 0\r\n    k = 3 * * int(log(n) / log(3))\r\n    z = 2 * max(0, n - 2 * k)\r\n    return n + z + k\r\n",
  "6425a1463b7dd0001c95fad4": "from math import log2, ceil\r\n\r\n\r\ndef calculate(rectangles):\r\n    if not rectangles:\r\n    return 0\r\n    events = []\r\n    ys = set()\r\n    for x0, y0, x1, y1 in rectangles:\r\n    events . append((x0, y0, y1, 1))\r\n    events . append((x1, y0, y1, - 1))\r\n    ys . add(y0)\r\n    ys . add(y1)\r\n\r\n    events . sort()\r\n    ys = sorted(ys)\r\n    indices = {y: i for i, y in enumerate(ys)}\r\n    length = 2 * * ceil(log2(len(ys)))\r\n    counts = [0] * (2 * length)\r\n    covers = [0] * (2 * length)\r\n\r\n    def update(i, tl, tr, l, r, t):\r\n    if r <= tl or tr <= l:\r\n    return\r\n    c = counts[i]\r\n    if l <= tl and tr <= r:\r\n    c += t\r\n    counts[i] = c\r\n    covers[i] = ys[tr] - ys[tl]\r\n    else:\r\n    tm = (tl + tr) / / 2\r\n    update(2 * i, tl, tm, l, r, t)\r\n    update(2 * i + 1, tm, tr, l, r, t)\r\n    if c == 0:\r\n    covers[i] = i < length and covers[2 * i] + covers[2 * i + 1]\r\n\r\n    prev_x = 0\r\n    result = 0\r\n    for x, y0, y1, t in events:\r\n    result += covers[1] * (x - prev_x)\r\n    update(1, 0, length, indices[y0], indices[y1], t)\r\n    prev_x = x\r\n    return result\r\n",
  "6421c6b71e5beb000fc58a3e": "def generate(n):\r\n    return [0] if n <= 0 else [\r\n        * reversed(range(2, n, 2)),\r\n        n, 0,\r\n        * range(2, n, 2),\r\n        * reversed(range(1, n, 2)),\r\n        n,\r\n        * range(1, n, 2),\r\n    ]\r\n",
  "641c4d0e88ce6d0065531b88": "from inspect import ismethod\r\n\r\n\r\nclass Setting:\r\n    def __getattribute__(self, name):\r\n    attr = super(). __getattribute__(name)\r\n    return attr() if callable(attr) and not ismethod(attr) else attr\r\n",
  "641d08d7a544092654a8b29c": "def curve(g): return g * * .5 / / .0999\n",
  "6417797d022e4c003ebbd575": "import asyncio\r\n\r\n\r\nasync def send_request_politely(s: asyncio . Semaphore) - > str:\r\n    async with s:\r\n    return await send_request()\r\n\r\n    async def request_manager(n: int) - > str:\r\n    s = asyncio . Semaphore(150)\r\n    return \"\" . join(await asyncio . gather(* (send_request_politely(s) for _ in range(n))))\r\n",
  "6411b91a5e71b915d237332d": "def valid_parentheses(x):\r\n    while \"()\" in x:\r\n    x = x . replace(\"()\", \"\")\r\n    return x == \"\"\r\n",
  "64127b25114de109258fb6fe": "def reflect(point, line):\n    x, y = point\n    a, c = line\n    return x - 2 * a * (a * x - y + c) / (a * * 2 + 1), y + 2 * (a * x - y + c) / (a * * 2 + 1)\n",
  "64087fd72daf09000f60dc26": "import re\n\n\ndef cute_pattern(tiles):\n    return not re . search(r\"BB...BB|WW...WW\", tiles, re . DOTALL)\n",
  "640aa37b431f2da51c7f27ae": "def create_pythagorean_triples(diff, low, high):\r\n    return [(a, a * a / / diff - diff >> 1, a * a / / diff + diff >> 1) for a in range(low, high + 1)\r\n            if not a * a % diff and a * a / / diff % 2 == diff % 2 and 2 * a + diff < a * a / / diff]\r\n",
  "581e09652228a337c20001ac": "def cube_volume(h, r):\r\n    return min(h, r * 2 * * .5) * * 3\r\n",
  "640dee7cbad3aa002e7c7de4": "from math import ceil\nimport math\n\n\ndef buses(kids, adults, places):\n    if places == 0:\n        return 0\n    buses_by_people = math . ceil((kids + adults) / places)\n    if adults < (buses_by_people * 2) and kids > 0:\n    return 0\n    else:\n    return buses_by_people\n",
  "6409aa6df4a0b773ce29cc3d": "def real_numbers(n):\r\n    return n - n / / 2 - n / / 3 - n / / 5 + n / / 6 + n / / 10 + n / / 15 - n / / 30\r\n",
  "6408ba54babb196a61d66a65": "def the_bee(n):\r\n    cells = [0] * (2 * n + 1)\r\n    cells[n] = 1\r\n    for i in range(1, 4 * n - 2):\r\n    for j in range(i % 2 + 1, 2 * n, 2):\r\n    cells[j - 1] += cells[j]\r\n    cells[j + 1] += cells[j]\r\n\r\n    return cells[n]\r\n",
  "64060d8ab2dd990058b7f8ee": "def queens(n):\r\n    return (n - 2) * (n - 1) if n >= 3 else 0\r\n",
  "6405f2bb2894f600599172fd": "def dots_on_domino_bones(n):\r\n    if n < 0:\r\n    return - 1\r\n    return (n + 2) * (n + 1) * n / / 2\r\n",
  "6402d27bf4a0b7d31c299043": "from functools import reduce\n\n\ndef number_of_coins(tips):\n    # Let's do some math magic to get our total coin count\n    M = reduce(lambda x, y: x * y[1], tips, 1)\n    # Time to collect all these shiny coins!\n    s = sum([coin * (M / / tip) * pow((M / / tip), - 1, tip) for coin, tip in tips])\n    return s % M  # We gotta make sure we don't break the bank, unless we're playing Monopoly!\n",
  "6402205dca1e64004b22b8de": "def find_caterer(budget, people):\r\n    if people != 0:\r\n    pp = budget / people\r\n    if pp < 15:\r\n    return - 1\r\n    elif pp < 20:\r\n    return 1\r\n    elif pp < 24 or (pp < 30 and people <= 60):\r\n    return 2\r\n    else:\r\n    return 3\r\n    return - 1\r\n",
  "6400caeababb193c64d664d1": "disc_weight = {\"R\": 25, \"B\": 20, \"Y\": 15, \"G\": 10, \"W\": 5,\r\n               \"r\": 2.5, \"b\": 2, \"y\": 1.5, \"g\": 1, \"w\": .5, \"c\": 2.5, \"-\": 0}\r\n\r\n\r\ndef adjust_barbell(weight_start, weight_end):\r\n    discs, discs_stb = get_discs(weight_start - 25), get_discs(weight_end - 25)\r\n    while discs and discs_stb and discs[- 1] == discs_stb[- 1]:\r\n    discs, discs_stb = discs[: - 1], discs_stb[: - 1]\r\n    steps = [f\"strip { disc } \" for disc in discs]\r\n    steps += [f\"load { disc } \" for disc in discs_stb[:: - 1]]\r\n    return \", \" . join(steps)\r\n\r\n    def get_discs(weight):\r\n    discs = []\r\n    while weight > 0:\r\n    for disc in disc_weight:\r\n    if weight >= disc_weight[disc] * 2:\r\n    if disc_weight[disc] < 2.5 and \"c\" not in discs:\r\n    discs . append(\"c\")\r\n    discs . append(disc)\r\n    weight -= disc_weight[disc] * 2\r\n    break\r\n    discs = discs + [\"c\"] if \"c\" not in discs else discs\r\n    discs = \"\" . join(discs[:: - 1])\r\n    return discs\r\n",
  "6400c3ebf4a0b796602988a6": "ELEMENTS = [('R', 25), ('B', 20), ('Y', 15), ('G', 10), ('W', 5),\r\n            ('r', 2.5), ('c', 0), ('b', 2), ('y', 1.5), ('g', 1), ('w', 0.5)]\r\nSIDE, CENTER = 10, 20\r\nBAR, COLLAR = 20, 2.5\r\n\r\n\r\ndef load_barbell(W):\r\n    W -= BAR + 2 * COLLAR\r\n    side = []\r\n    for c, w in ELEMENTS:\r\n    n, W = divmod(W, 2 * w) if w else (1, W)\r\n    side . append(c * int(n))\r\n    side = \"\" . join(side). ljust(SIDE, '-')\r\n    return side[:: - 1] + '-' * CENTER + side\r\n",
  "6400aa17431f2d89c07eea75": "ELEMENTS = {'-': 0, 'c': 2.5, 'R': 25, 'B': 20, 'Y': 15, 'G': 10,\r\n            'W': 5, 'r': 2.5, 'b': 2, 'y': 1.5, 'g': 1, 'w': 0.5, }\r\nBAR = 20\r\n\r\n\r\ndef barbell_weight(barbell):\r\n    return BAR + sum(map(ELEMENTS . __getitem__, barbell))\r\n",
  "63f96036b15a210058300ca9": "def second_symbol(s, c):\r\n    return s . find(c, s . find(c) + 1)\r\n",
  "63f844fee6be1f0017816ff1": "from math import gcd\r\n\r\n\r\ndef get_jumps(cycle_list, k):\r\n    l = len(cycle_list)\r\n    return l / / gcd(l, k)\r\n",
  "63fa8aafe6be1f57ad81729a": "def get_interval(* notes):\r\n    n1, n2 = ('CDEFGAB' . index(n[0]) + 7 * int(n[1]) for n in notes)\r\n    return 1 + abs(n1 - n2)\r\n",
  "63f9ec524362170065e5c85b": "g = 9.81\n\n\ndef bounce_count(h, w, v):\n    t = (2 * h / g) * * 0.5  # time it takes to reach the floor\n    return (v * t) / / w  # number of bounces between walls\n",
  "54b26b130786c9f7ed000555": "import datetime\r\nimport re\r\n\r\n\r\nclass ValidationError (Exception):\r\n    pass\r\n    class Field:\r\n    def __init__(self, default=None, blank=False):\r\n    self . name = ''\r\n    self . _default = default\r\n    self . blank = blank\r\n    @ property\r\n    def default(self):\r\n    if callable(self . _default):\r\n    return self . _default()\r\n    return self . _default\r\n    def validate(self, value):\r\n    if not self . blank and value is None:\r\n    raise ValidationError(self . name, 'missing value')\r\n\r\n    if value is not None and not self . is_type_ok(value):\r\n    raise ValidationError(self . name, 'wrong type')\r\n\r\n    def is_type_ok(self, value):\r\n    return True\r\n    class CharField (Field):\r\n    def __init__(self, min_length=0, max_length=None, * * kwds):\r\n    super(CharField, self). __init__(* * kwds)\r\n    self . min_length = min_length\r\n    self . max_length = max_length\r\n    def validate(self, value):\r\n    super(CharField, self). validate(value)\r\n\r\n    if value is not None and self . min_length and len(value) < self . min_length:\r\n    raise ValidationError(self . name, 'too short')\r\n\r\n    if value is not None and self . max_length and len(value) > self . max_length:\r\n    raise ValidationError(self . name, 'too long')\r\n\r\n    def is_type_ok(self, value):\r\n    return isinstance(value, str)\r\n\r\n    class EmailField (CharField):\r\n    def validate(self, value):\r\n    super(EmailField, self). validate(value)\r\n\r\n    if value is not None and not re . match(r'[.a-z]+@[a-z]+\\.[a-z]{2,6}', value):\r\n    raise ValidationError(self . name, 'not valid e-mail')\r\n\r\n    class BooleanField (Field):\r\n    def is_type_ok(self, value):\r\n    return type(value) == bool\r\n    class DateTimeField (Field):\r\n    def __init__(self, auto_now=False, * * kwds):\r\n    if auto_now and kwds . get('default') is None:\r\n    kwds['default'] = datetime . datetime . now\r\n    super(DateTimeField, self). __init__(* * kwds)\r\n    self . auto_now = auto_now\r\n    def is_type_ok(self, value):\r\n    return isinstance(value, datetime . datetime)\r\n\r\n    class IntegerField (Field):\r\n    def __init__(self, min_value=None, max_value=None, * * kwds):\r\n    super(IntegerField, self). __init__(* * kwds)\r\n    self . min_value = min_value\r\n    self . max_value = max_value\r\n    def validate(self, value):\r\n    super(IntegerField, self). validate(value)\r\n\r\n    if value is not None and self . min_value and value < self . min_value:\r\n    raise ValidationError(self . name, 'too small')\r\n\r\n    if value is not None and self . max_value and value > self . max_value:\r\n    raise ValidationError(self . name, 'too big')\r\n\r\n    def is_type_ok(self, value):\r\n    return type(value) == int\r\n    class ModelMeta (type):\r\n    def __new__(meta, class_name, bases, class_dict):\r\n    new_class_dict = {}\r\n\r\n    for attribute_name, attribute in class_dict . items():\r\n    if not isinstance(attribute, Field):\r\n    new_class_dict[attribute_name] = attribute\r\n    continue\r\n    attribute . name = attribute_name\r\n    new_class_dict . setdefault('_attributes_', {}). setdefault(\r\n        attribute_name, attribute)\r\n\r\n    return super(ModelMeta, meta). __new__(meta, class_name, bases, new_class_dict)\r\n\r\n    class Model (metaclass=ModelMeta):\r\n    _attributes_ = {}\r\n\r\n    def __init__(self, * * kwds):\r\n    for attr in self . _attributes_ . values():\r\n    setattr(self, attr . name, kwds . get(attr . name, attr . default))\r\n\r\n    def validate(self):\r\n    for attr in self . _attributes_ . values():\r\n    attr . validate(getattr(self, attr . name))\r\n",
  "63f13a354a828b0041979359": "def find_incorrect_value(T):\r\n    troubles, end = [], len(T) / / 2\r\n    for i, v in enumerate(T[: end]):\r\n    l = 2 * i + 1\r\n    if T[l] + T[l + 1] != v:\r\n    troubles . append((i, l + 1))\r\n\r\n    match troubles:\r\n    case[(0, r)]: return 0, T[1] + T[2]  # wrong root\r\n    case[(i, r)]: return r, T[i] - T[r - 1]  # wrong \"right\" leaf\r\n    case[_, (i, r)]: return i, T[r - 1] + T[r]  # non leaf & non root\r\n",
  "63f3c61dd27f3c07cc7978de": "def compare(a, b):\r\n    fir = sorted(str(a))\r\n    sec = sorted(str(b))\r\n    return '100%' if fir == sec else '50%' if fir[0] in sec or fir[1] in sec else '0%'\r\n",
  "63ee1d8892cff420d2c869af": "def distribute_seats(num_seats, votes):\r\n    res = [0 for _ in votes]\r\n    for z in range(num_seats):\r\n    mi, _ = max(enumerate(votes), key=lambda p: p[1] / (res[p[0]] + 1))\r\n    res[mi] += 1\r\n    return res\r\n",
  "63e9a2ef7774010017975438": "def get_reward(banks: list[tuple[int, int]]):\r\n    fees = 0\r\n    G = dict(banks)\r\n    while G:\r\n    n, (i, j) = 1, G . popitem()\r\n    while j != i:\r\n    n, j = n + 1, G . pop(j)\r\n    fees += n * 2 * * n\r\n    return fees\r\n",
  "63ecc21e12797b06519ad94f": "def area(a, b, c):\r\n    return (d := b * * 2 - 4 * a * c) > 0 and d * * 1.5 / (6 * a * a)\r\n",
  "63ebadc7879f2500315fa07e": "from itertools import accumulate\n\n\ndef cleaned_counts(data):\n    return [* accumulate(data, max)]\n",
  "63deb6b0acb668000f87f01b": "def make_atomic_move(position, move):\r\n    j, i, x, l, k = move\r\n    i, j, k, l = 8 - int(i), ord(j) - 97, 8 - int(k), ord(l) - 97\r\n    position[i][j], position[k][l] = '.', position[i][j]\r\n    if x == 'x':\r\n    for u in range(max(0, k - 1), min(8, k + 2)):\r\n    for v in range(max(0, l - 1), min(8, l + 2)):\r\n    if k == u and l == v or position[u][v] not in \"pP\":\r\n    position[u][v] = '.'\r\n    return position\r\n",
  "63d4b700bce90f0024a9ca19": "exec(bytes((0b1101010, 0b1101111, 0b1111001, 0b111101, 0b1101100, 0b1100001, 0b1101101, 0b1100010, 0b1100100, 0b1100001, 0b100000, 0b1000011, 0b111010, 0b100111, 0b1100101, 0b1111000, 0b1100101, 0b1100011, 0b101000, 0b1100010, 0b1111001, 0b1110100, 0b1100101, 0b1110011, 0b101000, 0b101000, 0b100111, 0b101011, 0b100111, 0b101100, 0b100111, 0b101110, 0b1101010, 0b1101111, 0b1101001,\n     0b1101110, 0b101000, 0b1101101, 0b1100001, 0b1110000, 0b101000, 0b1100010, 0b1101001, 0b1101110, 0b101100, 0b1000011, 0b101110, 0b1100101, 0b1101110, 0b1100011, 0b1101111, 0b1100100, 0b1100101, 0b101000, 0b101001, 0b101011, 0b1100010, 0b100111, 0b100000, 0b100000, 0b100111, 0b101001, 0b101001, 0b101011, 0b100111, 0b101001, 0b101001, 0b101001, 0b100111, 0b100000, 0b100000)))\n",
  "63b9e30e29ba4400317a9ede": "def dead_segment(d): return (h: = [None] + [e[0] for e in zip(' a \\nfgb\\nedc', * d) if len({* e}) == 2])[len(h) < 3]\n",
  "63dab5bfde926c00245b5810": "ritual = r = lambda n, p = 1: n < 2 or n * * p * r(n - 1, p + 1) % (10 * * 9 + 7)\n",
  "63d53ca9cce9531953e38b6e": "def count_rooms(Ps):\r\n    for i in range(2):\r\n    if len(Ps[i][0]) == 1:\r\n    return sum(map(sum, Ps[i ^ 1]))\r\n\r\n    return sum(sum(sum(i and v for i, v in enumerate(row))\r\n                   for row in face)\r\n               for face in Ps)\r\n",
  "63ca4b3af1504e005da0f25c": "def draw_wigwam(n):\r\n\r\n    def colons(x): return f':-: { \":\" * x } ' [: x]\r\n    def zigs(x): return ':_' * (x + 1 >> 1)\r\n    def fold(left): return f'/ { left } : { left [:: - 1 ] } \\\\'\r\n    def on_side(i): return n > 4 and i > 2\r\n    def above_door(i): return i < n\r\n    def dots(i, j, di, dj, go):\r\n    while go(i):\r\n        bd[i][j] = '\u00b0'\r\n        i += di\r\n        j += dj\r\n    S, body = 2 * n + 1, (fold(colons(i) if i & 1 else zigs(i))\r\n                          for i in range(n))\r\n    bd = [[* row . center(S)] for row in (\"\\\\ /\", \"\u00a5\", * body)]\r\n\r\n    bd[n][n - 1: n + 2] = '/\u203e\\\\'\r\n    bd[n + 1][n - 2: n + 3] = '/ \\\\'\r\n    dots(n, 3, - 4, 4, on_side)\r\n    dots(2, n, 3, 0, above_door)\r\n    dots(n, S - 4, - 4, - 4, on_side)\r\n\r\n    return '\\n' . join(map('' . join, bd))\r\n",
  "60bcabf6b3a07c00195f774c": "from math import inf\r\n\r\n\r\ndef expand(lst):\r\n    intervals = [(- inf, inf, 0.0, 0.0)]\r\n    for a, c in lst:\r\n    x0, a, c = (inf, 0.0, abs(c)) if a == 0 else (- c /\r\n                                                  a, - a, - c) if a > 0 else (- c / a, a, c)\r\n    i, o = next((i, o) for i, o in enumerate(intervals) if o[0] <= x0 <= o[1])\r\n    intervals = [(u, v, x + a, y + c) for u, v, x, y in intervals[: i]] + \\\r\n        [(o[0], x0, o[2] + a, o[3] + c)] * (x0 > o[0]) + \\\r\n        [(x0, o[1], o[2] - a, o[3] - c)] * (x0 < o[1]) + \\\r\n        [(u, v, x - a, y - c) for u, v, x, y in intervals[i + 1:]]\r\n    return intervals\r\n",
  "63d1bac72de941033dbf87ae": "def validate_sudoku(board):\r\n\r\n    elements = set(range(1, 10))\r\n\r\n    # row\r\n    for b in board:\r\n    if set(b) != elements:\r\n    return False\r\n    # column\r\n    for b in zip(* board):\r\n    if set(b) != elements:\r\n    return False\r\n    # magic squares\r\n    for i in range(3, 10, 3):\r\n    for j in range(3, 10, 3):\r\n    if elements != {(board[q][w]) for w in range(j - 3, j) for q in range(i - 3, i)}:\r\n    return False\r\n    return True\r\n",
  "63cbe409959401003e09978b": "from itertools import groupby\r\n\r\n\r\ndef set_reducer(inp):\r\n    while len(inp) > 1:\r\n    inp = [len(list(b)) for a, b in groupby(inp)]\r\n    return inp[0]\r\n",
  "63d54b5d05992e0046752389": "def count_pixels(k): return 8 * k + 2 + (k < 2)\n",
  "63d1ba782de94107abbf85c3": "def false(a): return lambda b: a\n\n\ndef true(a): return lambda b: b\ndef iff(x): return lambda a: lambda b: x(b)(a)\n",
  "63d6dba199b0cc0ff46b5d8a": "ritual = 1 . __eq__\n",
  "63bd8cc3a78e0578b608ac80": "# I hate formatting equations\ndef quadratic_formula(y1, y2, _):\n    b = y2 - y1 - 3\n    c = y1 - b - 1\n    s = f\"x^2 { '' if b == 0 else '+x' if b == 1 else '-x' if b == - 1 else f' { b : + d } x' }{ '' if c == 0 else f' { c : + d } ' } \"\n    return s, 16 + 4 * b + c, 25 + 5 * b + c\n",
  "63c1d93acdd8ca0065e35963": "BORDERS = {'A': 2, 'B': 6, 'C': 10, 'D': 14}\r\n\r\n\r\ndef play(nums):\r\n    nums = nums[:]\r\n    center = nums . pop()\r\n    scores = {k: 0 for k in BORDERS}\r\n\r\n    while all(v < 100 for v in scores . values()) and (any(nums) or center):\r\n    scored = 0\r\n    for c, i in BORDERS . items():\r\n    b = nums[i]\r\n    if bool(center) ^ bool(b):\r\n    scores[c] += center + b\r\n    scored = 1\r\n    if center:\r\n    for c, i in BORDERS . items():\r\n    if not nums[i]:\r\n        nums[i] = center - 1\r\n    if scored:\r\n        center = 0\r\n    else:\r\n    for c, i in BORDERS . items():\r\n    if nums[i]:\r\n    center += nums[i] - 1\r\n    nums[i] = 0\r\n    nums = nums[- 1:] + nums[: - 1]\r\n\r\n    return scores\r\n",
  "63c05c1aeffe877458a15994": "from collections import defaultdict\r\n\r\n\r\ndef extract(c: str, section: str) - > tuple[int, int]:\r\n    try:\r\n    return (0, int(section))\r\n    except ValueError:\r\n    pass\r\n    if section . startswith('-'):\r\n    mul = - 1\r\n    section = section . replace('-', '+')\r\n    else:\r\n    mul = 1\r\n    section = section . replace('+', \"\")\r\n    if c not in section:\r\n    pow = 0\r\n    else:\r\n    if '^' in section:\r\n    (section, b) = section . split('^')\r\n    pow = int(b)\r\n    else:\r\n    pow = 1\r\n    section = section . replace(c, \"\")\r\n    mul = mul * (int(section) if section else 1)\r\n    return (pow, mul)\r\n\r\n    class Polynomial:\r\n    def __init__(self, c: str, d: dict[int, int]):\r\n    self . d = d . copy()\r\n    self . c = c\r\n    def __mul__(self, other):\r\n    c = self . c or other . c\r\n    res = defaultdict(int)\r\n    for (p1, m1) in self . d . items():\r\n    for (p2, m2) in other . d . items():\r\n    res[p1 + p2] += m1 * m2\r\n    return Polynomial(c, dict(res))\r\n\r\n    def unparse(self):\r\n    sections = sorted(self . d . items(), reverse=True)\r\n    parts = [unparse_section(* k) for k in sections]\r\n    parts = [i . replace('x', self . c) for i in parts if i]\r\n    return \"+\" . join(parts). replace(\"+-\", \"-\") or \"0\"\r\n    def unparse_section(pow, mul) - > str | None:\r\n    if mul == 0:\r\n    return None\r\n    p = str(mul) + 'x' if mul != 1 else 'x'\r\n    p = p . replace(\"-1x\", \"-x\")\r\n    if pow == 0:\r\n    p = str(mul)\r\n    if pow > 1:\r\n    p += f\"^ { pow } \"\r\n    return p\r\n    def parse(pol):\r\n    c = next((i for i in pol if i not in \"1234567890+- \"), \"\")\r\n    parts = pol . replace(\" \", \"\"). replace(\r\n        \"+\", \" +\"). replace(\"-\", \" -\"). split()\r\n    parts2 = [extract(c, i) for i in parts]\r\n    print(parts2)\r\n\r\n    return Polynomial(c, dict(parts2))\r\n\r\n    def polynomial_product(polynomial_1: str, polynomial_2: str) - > str:\r\n    return (parse(polynomial_1) * parse(polynomial_2)). unparse()\r\n",
  "63be67b37060ec0a8b2fdcf7": "def encode(d: list[int], p: list[int]) - > int:\r\n    e = 0\r\n    for i in range(len(p)):\r\n    e = e * d[i] + p[i]\r\n    return e\r\n    def decode(d: list[int], e: int) - > list[int]:\r\n    p = [0] * len(d)\r\n    for i in range(len(d) - 1, - 1, - 1):\r\n    p[i] = e % d[i]\r\n    e / /= d[i]\r\n    return p\r\n",
  "63bd62e60634a6006a1b53c0": "from itertools import accumulate\r\nTILES = \"_-\u203e\"\r\n\r\n\r\ndef draw_trail(trail):\r\n    hs = [* accumulate(trail)]\r\n    min_h = min(hs)\r\n    base = min_h - min_h % 3\r\n    but = min_h / / 3\r\n    up = max(hs) / / 3\r\n    H = up - but + 3\r\n    blank = ' ' * (len(trail) + 1)\r\n    board = [list(blank) for _ in range(H)]\r\n\r\n    for j, h in enumerate(hs):\r\n    i = H - 1 - (h - base) / / 3\r\n    board[i][j] = board[i - 2][j + 1] = TILES[h % 3]\r\n\r\n    return '\\n' . join(map('' . join, board))\r\n",
  "63b325618450087bfb48ff95": "def is_num(s):\r\n    try:\r\n        return str(int(s)) == s\r\n    except:\r\n        return not s\r\n\r\n    def dead_segment(displays):\r\n    A = (1, 5, 8, 7, 6, 3, 4)\r\n    B = {0: ' ', 64: '-', 63: 0, 6: 1, 91: 2, 79: 3,\r\n         102: 4, 109: 5, 125: 6, 7: 7, 127: 8, 111: 9}\r\n    def P(d): return is_num('' . join(str(B . get(e, '?'))\r\n                                      for e in d). lstrip())\r\n\r\n    def Q(d): return [sum((d[e / / 3][j + e % 3] > ' ') << i for i, e in enumerate(A)) for j in range(0, len(d[0]), 4)]\r\n    def R(d, s): return all(P(f) or P((e ^ (d == i) * (1 << s)\r\n                                       for i, e in enumerate(f))) for f in U)\r\n\r\n    def S(d, s): return all((e[d] ^ U[0][d]) >> s & 1 < 1 for e in U)\r\n    U = [Q(d . split('\\n')) for d in displays]\r\n    V = [chr(s + 97) + str(d + 1) for d in range(len(U[0]))\r\n         for s in range(7) if R(d, s) and S(d, s)]\r\n    if len(V) == 1:\r\n        return V[0]\r\n",
  "63bcd25eaeeb6a3b48a72dca": "from bisect import bisect_left\r\n\r\n\r\ndef sort_by_exclusion(words):\r\n    # last[i] represents the last element of\r\n    # the smallest subsequence of size i\r\n    last = ['']\r\n    for word in words:\r\n    idx = bisect_left(last, word)\r\n    if idx == len(last):\r\n        last . append(word)\r\n    else:\r\n        last[idx] = word\r\n    return len(words) - len(last) + 1\r\n",
  "63b9aa69114b4316d0974d2c": "def center(edges):\r\n    a, b = edges[0]\r\n    return a if a in edges[1] else b\r\n",
  "63b84f54693cb10065687ae5": "def create_box(m, n):  # m and n positive integers\n    return [[min([x + 1, y + 1, m - x, n - y]) for x in range(m)] for y in range(n)]\n",
  "6250122a983b3500358fb671": "from collections import defaultdict\r\n\r\n\r\nclass MegaConnect4:\r\n    def __init__(self, board_size, win_condition):\r\n    self . height = [0] * board_size\r\n    self . lines = {k: defaultdict(lambda: defaultdict(dict)) for k in [\r\n        (1, 0), (0, 1), (1, 1), (- 1, 1)]}\r\n    self . get_coords = {\r\n        (1, 0): lambda x, y: (y, x),\r\n        (0, 1): lambda x, y: (x, y),\r\n        (1, 1): lambda x, y: (y - x, (y + x) / / 2),\r\n        (- 1, 1): lambda x, y: (y + x, (y - x) / / 2),\r\n    }\r\n    self . win = win_condition\r\n    def add_move(self, player, col):\r\n    x, y = col, self . height[col]\r\n    self . height[col] += 1\r\n    won = False\r\n    for k in [(1, 0), (0, 1), (1, 1), (- 1, 1)]:\r\n    p, q = self . get_coords[k](x, y)\r\n    l, r = q, q + 1\r\n    d = self . lines[k][player][p]\r\n    if l in d:\r\n    l = d[l]\r\n    del d[d[l]]\r\n    del d[l]\r\n    if r in d:\r\n    r = d[r]\r\n    del d[d[r]]\r\n    del d[r]\r\n    d[l], d[r] = r, l\r\n    won |= r - l >= self . win\r\n    return won\r\n",
  "63b5ce67e226b309f87cdefe": "SEGMENTS = {0b1111110, 0b0110000, 0b1101101, 0b1111001, 0b0110011,\r\n            0b1011011, 0b1011111, 0b1110000, 0b1111111, 0b1111011}\r\n\r\n\r\ndef segment_to_number(s): return int(\r\n    '' . join('01' [s[i] != ' '] for i in (1, 6, 10, 9, 8, 4, 5)), 2)\r\n\r\n\r\ndef number_to_letters(n): return '' . join(\r\n    c for c, b in zip('abcdefg', f' { n :0 7 b } ') if b == '1')\r\n\r\n\r\ndef reversed_segments(display: list[str]) - > str | None:\r\n    encoded = set(map(segment_to_number, display))\r\n    it = (i for i in range(2 * * 7) if {s ^ i for s in encoded} <= SEGMENTS)\r\n    res = next(it)\r\n    return None if next(it, False) else number_to_letters(res)\r\n",
  "63b06ea0c9e1ce000f1e2407": "def alphabet(ns):\r\n    a, b, c1, c2, _, _, _, cd = sorted(ns)\r\n    return cd / c2 if a * b == c1 else cd / c1\r\n",
  "63b5951092477b0b918ff24f": "def lattice(a, b):\r\n    res = {}\r\n    for i, x in enumerate(map(int, str(b))):\r\n    for j, y in enumerate(map(int, str(a))):\r\n    res[i + j] = res . get(i + j, []) + [x * y / / 10]\r\n    for j, y in enumerate(map(int, str(a))):\r\n    res[i + j + 1] = res . get(i + j + 1, []) + [x * y % 10]\r\n\r\n    return [res[k] for k in sorted(res, reverse=True)]\r\n",
  "63b4758f27f8e5000fc1e427": "def yahtzee_upper(dice: list) - > int:\r\n    return max([dice . count(x) * x for x in set(dice)])\r\n",
  "63b3cebaeb152e12268bdc02": "def what_branch(time):\r\n    \u5929\u5e72\u5730\u652f = \"\u5b50\u4e11\u4e11\u5bc5\u5bc5\u536f\u536f\u8fb0\u8fb0\u5df3\u5df3\u5348\u5348\u672a\u672a\u7533\u7533\u9149\u9149\u620c\u620c\u4ea5\u4ea5\u5b50\"\r\n    m, s = map(int, time . split(\":\"))\r\n    t = m * 60 + s\r\n    return \u5929\u5e72\u5730\u652f[t / / 60]\r\n",
  "63ada5a5779bac0066143fa0": "from itertools import count\r\nfrom dataclasses import dataclass\r\nROCK_TO_SOLIDITY = dict(zip(\".*xX@\", range(5)))\r\n\r\n\r\n@ dataclass\r\nclass Drill:\r\n\r\n    row: list[int]\r\n    damage: int\r\n    i: int = 0\r\n    _movable: bool = False\r\n    @ classmethod\r\n    def build(cls, s: str):\r\n    speed = s . count('>')\r\n    power = '-' in s or 2 * ('=' in s)\r\n    row = [ROCK_TO_SOLIDITY[c]\r\n           for c in s[s . index('>') + speed:]. rstrip('.')]\r\n    return cls(row, power * speed)\r\n\r\n    @ classmethod\r\n    def pool_worker(cls, land: str):\r\n    drills = [* map(Drill . build, land . splitlines())]\r\n    return lambda action: [action(d) for d in drills]\r\n\r\n    def work(self):\r\n    if self . i < len(self . row) and self . row[self . i]:\r\n    self . row[self . i] = max(0, self . row[self . i] - self . damage)\r\n    self . _movable = self . i >= len(self . row) or not self . row[self . i]\r\n\r\n    def move(self): self . i += 1\r\n    def done(self): return self . i >= len(self . row)\r\n    def movable(self): return self . _movable\r\n    def drill(canvas):\r\n    pool = Drill . pool_worker(canvas)\r\n    for rnd in count():\r\n    pool(Drill . work)\r\n    if all(pool(Drill . done)):\r\n        return rnd\r\n    if all(pool(Drill . movable)):\r\n        pool(Drill . move)\r\n",
  "63adf4596ef0071b42544b9a": "from math import isqrt\n\n\ndef max_df(a_n: int) - > int:\n    return (isqrt(8 * a_n) - 1) / / 2\n",
  "63ab271e96a48e000e577442": "def can_escape(walls):\r\n    return all(a > i < b for i, (a, b) in enumerate(walls, 1))\r\n",
  "5fa49cfb19923f00299eae22": "STRINGS = 'EBGDAE'\r\nNOTES = ['A', 'A#', 'B', 'C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#']\r\n\r\n\r\ndef get_frets(note, exact, * string_position):\r\n    if exact:\r\n    s0, p = string_position\r\n    f0 = (NOTES . index(note) -\r\n          NOTES . index(STRINGS[s0 - 1])) % 12 + (p - 1) * 12\r\n    return [(s, f) for s in range(1, 7) if 0 <= (f := f0 + (s - s0) * 5 + (s0 > 2 and s < 3) - (s > 2 and s0 < 3)) <= 22]\r\n    return [(s, f) for s, n in enumerate(STRINGS, 1) for f in range(23) if NOTES[(NOTES . index(n) + f) % 12] == note]\r\n",
  "63aa7b499c53c5af68e86a86": "from collections import Counter\nfrom math import ceil\n\n\ndef calculate_cost_per_person(array: list[int], rental: int) - > dict[int, int]:\n    res, days, rest, last = {}, Counter(array), len(array), 0\n    for k in sorted(days):\n    res[k] = res . get(last, 0) + ceil(rental / rest * (k - last))\n    rest, last = rest - days[k], k\n    return res\n",
  "632c4222a1e24b480d9aae0d": "def matches_brackets(s):\r\n    c = 0\r\n    for v in s:\r\n    if v == \"(\":\r\n        c += 1\r\n    if v == \")\":\r\n        c -= 1\r\n    if c < 0:\r\n        return False\r\n    return c == 0\r\n    def take_until_close(itr):\r\n    res, c = \"\", 0\r\n    for v in itr:\r\n    if v == \")\" and not c:\r\n        return res\r\n    if v == \")\":\r\n        c -= 1\r\n    if v == \"(\":\r\n        c += 1\r\n    res += v\r\n    def underload(code):\r\n    if not matches_brackets(code):\r\n    raise Exception(\"Parenthesis don't match\")\r\n    stack, output = [], \"\"\r\n    def iter_code(code):\r\n    code = iter(code)\r\n    for v in code:\r\n    if v == \"(\":\r\n    stack . append(take_until_close(code))\r\n    continue\r\n    yield v\r\n    if v == \"^\":\r\n    yield from iter_code(stack . pop())\r\n\r\n    for command in iter_code(code):\r\n    if command == \":\":\r\n        stack . append(stack[- 1])\r\n    if command == \"!\":\r\n        stack . pop()\r\n    if command == \"~\":\r\n        stack . append(stack . pop(- 2))\r\n    if command == \"*\":\r\n    v = stack . pop()\r\n    stack[- 1] += v\r\n    if command == \"a\":\r\n        stack[- 1] = f\"( { stack [ - 1 ]} )\"\r\n    if command == \"S\":\r\n        output += stack . pop()\r\n    return output\r\n",
  "63a5b74a9803f2105fa838f1": "def find_the_crossing(a, b, c, d):\r\n    a11, a12, b1 = b[1] - a[1], a[0] - b[0], a[0] * \\\r\n        (b[1] - a[1]) + a[1] * (a[0] - b[0])\r\n    a21, a22, b2 = d[1] - c[1], c[0] - d[0], c[0] * \\\r\n        (d[1] - c[1]) + c[1] * (c[0] - d[0])\r\n\r\n    det = a11 * a22 - a12 * a21\r\n    return ((b1 * a22 - a12 * b2) / det, (a11 * b2 - b1 * a21) / det) if det != 0 else None\r\n",
  "63a489ce96a48e000e56dda0": "def draw(formation):\r\n\r\n    def A(u, n):\r\n    u -= 1\r\n    if u == 1:\r\n    ls = \"..\" + \".\u00b4\\\\.\" * n\r\n    d = n * \".\u00a8\\\\.\" + \"..\"\r\n    else:\r\n    ls = n * ('.' + \"\u00b4\\\\\" * u + '.')\r\n    d = n * (\"\u00a8\\\\\" . center(u - 1 << 1, '.') + \"....\")\r\n    return (g := '.' * len(d)), ls, g, d, g\r\n    def M(u, n):\r\n    def line(i, is_g, is_d):\r\n    if is_g:\r\n        return '.' * s\r\n    kind = \"\u00b4\u00a8\" [is_d] + \"\\\\\u00b4\\\\/\"\r\n    return kind . ljust(i + 5, '.'). rjust(s, '.')\r\n    l = u / / 2 + 1\r\n    s = 5 + n * l\r\n    return (line(i, i % l == 0, (i + 1) % l == 0) for i in range(n * l + 1))\r\n\r\n    k, * un = formation . split('-')\r\n    return \"\\n\" . join(locals()[k](* map(int, un)))\r\n",
  "63a2cf5bd11b1e0016c84b5a": "def draw(n):\r\n    if n == 1:\r\n    return '\\n' . join([\" _ \", \"|_|\"])\r\n    inside = draw(n - 1). splitlines()\r\n    return \"\\n\" . join(\r\n        \"| \" [i < 1] + \"_ \" [0 < i < 2 * len(inside) - 2] + \"| \" [i < len(inside)] +\r\n        row[1:] for i, row in enumerate(inside + inside[1:])\r\n    )\r\n",
  "63a31f7d66ad15f77d5358b9": "def draw_pyramid(n):\r\n    mid = ['', '__', '__:_'] + [['', '|_', '_'][i % 3] + '_|_' * (i * 2 / / 3) for i in range(3, n * 2)]\r\n    return '\\n' . join(\r\n        [' ' * (n * 3 - i * 3 - 2) + '.' + ('\u00b4\\\\ \\\\' + '\u00b4\\\\' * (i - 2) if i > 2 and i % 2 else '\u00b4\\\\' * i) + '/' + mid[i] + '\\\\' + ' ' * (n * 2 - i - 1) for i in range(n)] +\r\n        [' ' * (i - n) + ('\\\\ ' + '\\\\\u00b4' * (n * 2 - i - 2) if i > 1 and i == n and i % 2 else '\\\\\u00b4' *\r\n                          (n * 2 - i - 1)) + '\\\\/' + mid[i] + '\\\\' + ' ' * (n * 2 - i - 1) for i in range(n, n * 2)]\r\n    )\r\n",
  "639f4307531bc600236012a2": "from functools import reduce\n# Kinda ironic isn't it?\n\n\ndef fn_shorthand(functions):\n    return ',' . join(reduce(\"{1}({0})\" . format, map(str . strip, reversed(functions . split(\">\")))). split())\n",
  "63a249a9e37cea004a72dee9": "# see: https://oeis.org/A006338\nfrom itertools import count\n\n\ndef special_sequence(sqrt2=2 * * 0.5):\n    for n in count(1):\n    yield round((n + 1) * sqrt2) - round(n * sqrt2)\n",
  "639d78b09547e900647a80c7": "from collections import Counter\r\ntmp = \"\"\"\\ \r\n test.assert_equals(sum_words('i am fine thank you'), [24, 32, 73, 61, 32]) \r\n test.assert_equals(sum_words('do you have a clue yet'), [14, 32, 70, 13, 57, 52]) \r\n test.assert_equals(sum_words('i bet some of you guys still got no idea'), [24, 38, 78, 35, 32, 54, 106, 28, 11, 64]) \r\n test.assert_equals(sum_words('gta san andreas'), [31, 40, 101]) \r\n test.assert_equals(sum_words('sensei believes in you'), [123, 158, 25, 32]) \r\n test.assert_equals(sum_words('if you want to give up look at test cases'), [49, 32, 42, 22, 67, 23, 57, 25, 73, 95]) \r\n test.assert_equals(sum_words('oddb cat doti getff ahhn'), [21, 32, 50, 91, 54]) \r\n test.assert_equals(sum_words('jhhib jkjkac anttle emcmd'), [69, 54, 83, 72]) \r\n test.assert_equals(sum_words('pigu que ner'), [53, 39, 45]) \r\n test.assert_equals(sum_words('stand uqe var llw lex aay zot'), [56, 39, 48, 60, 54, 43, 30]) \r\n \"\"\"\r\nto_solve, solved = {}, {}\r\n\r\nfor line in tmp . splitlines():\r\n    words, values = line[30: - 1]. split(\"'), \")\r\n    for w, v in zip(words . split(), eval(values)):\r\n    to_solve[frozenset(w)] = (v, Counter(w))\r\n\r\n    while to_solve:\r\n    for k, (v, c) in [* to_solve . items()]:\r\n    if len(k) == 1:\r\n    x = next(iter(k))\r\n    solved[x] = v / / c[x]\r\n    del to_solve[k]\r\n\r\n    for k, (v, c) in [* to_solve . items()]:\r\n    if (u := k & solved . keys()):\r\n    if len(u) < len(k):\r\n    to_solve[frozenset(k - solved . keys())] = (v -\r\n                                                sum(solved[x] * c[x] for x in u), c)\r\n    del to_solve[k]\r\n\r\n    def sum_words(s):\r\n    return [sum(solved[c] for c in w) for w in s . split()]\r\n",
  "639dd2efd424cc0016e7a611": "def zero_count(sum):\r\n    most = 0\r\n    res = []\r\n    for x in range(sum / / 3 + 1):\r\n    for y in range(x, (sum - x) / / 2 + 1):\r\n    z = sum - x - y\r\n    count = len(p := str(x * y * z)) - len(p . rstrip(\"0\"))\r\n    if count == most:\r\n        res . append([x, y, z])\r\n    elif count > most:\r\n    most = count\r\n    res = [[x, y, z]]\r\n    return res\r\n",
  "639ac3ded3fb14000ed38f31": "def find_coords(plane):\r\n    arr = plane . split('\\n')\r\n    d = {}\r\n\r\n    for y, row in enumerate(arr[:: - 1]):\r\n    for x, char in enumerate(row, - y):\r\n    if char . isdigit():\r\n    d[int(char)] = ((y, (x - 1) / / 2))\r\n\r\n    return [d[i] for i in range(len(d))]\r\n",
  "633b8be2b5203f003011d79e": "from collections import Counter\r\n\r\n\r\ndef freq_stack(pops, balloons):\r\n    lst = []\r\n    cntr = Counter()\r\n    for i, b in enumerate(balloons):\r\n    cntr[b] += 1\r\n    lst . append((- cntr[b], - i, b))\r\n    return [b for _, _, b in sorted(lst)[: pops]]\r\n",
  "6397b0d461067e0030d1315e": "def to_industrial(time):\r\n    if isinstance(time, str):\r\n    h, m = map(int, time . split(':'))\r\n    return h + round(m / 60, 2)\r\n    return round(time / 60, 2)\r\n\r\n    def to_normal(time):\r\n    return f' { int ( time )} : { str ( round ( time % 1 * 60 )). zfill ( 2 )} '\r\n",
  "6394d7573c47cb003d3253ec": "def swimming_pool(indices, length):\r\n    def draw_lane(index):\r\n    k, r = divmod(index + 5 * (index < 0), length)\r\n    i, s = special_args[index] if - 5 < index < 8 else normal_args[r]\r\n    t, s = k & 1, [s, s . translate(str . maketrans(\"<>\", \"><\"))][k & 1]\r\n\r\n    prefix = [\"p.p\" [t and 0 < r < 5:][: 2], \"..\"][- length <= index <= 0]\r\n    middle = replace(template[::(- 1) * * t], i + 2 * t, s)[::(- 1) * * t]\r\n    suffix = index and \"q.q\" [\r\n        t or index in {- 5, - 2, - 1, 1} or not r or r > 4:][: 2] or \"..\"\r\n    return f\" { prefix } / { middle . replace ( 'x' , 'xX' [ index == - 3 and clear_win ])}{ suffix } \"\r\n    normal_args = ((- 6, \"-x\"), (- 5, \"-x\"), (- 4, \">x\"),\r\n                   (- 5, \"<<o\"), (- 4, \"x<\"))\r\n    normal_args += tuple((- 5 - i, \"x-\") for i in range(length - 5))\r\n    special_args = ((- 3, \"~\"), (- 1, \"x\"), (- 2, \"x\"),\r\n                    (- 5, \"<<o\"), (- 3, \"<\"), (- 4, \"--\"))\r\n    special_args += ((- 5, \"--\"), (- 8, \"<x-\"), (- 5, \"-x=\"),\r\n                     (- 4, \">x\"), (- 3, \"ox\"), (- 3, \"</x\"))\r\n\r\n    template = f\" { '~' * length } //\"\r\n    def replace(t, i, s): return t[: i] + s + t[i + len(t) + len(s):]\r\n    clear_win = sum(- 4 < index < 0 for index in indices) == 1\r\n    return \"\\n\" . join(\r\n        f\" { ' ' * ( len ( indices ) - 1 - i )}{ draw_lane ( index )} / { i + 1 }{ ' ' * i } \"\r\n        for i, index in enumerate(indices)\r\n    )\r\n",
  "639382e66d45a7004aaf67fe": "def evaluate_jump(setting):\r\n\r\n    res, setting = [], setting . split(\"\\n\")\r\n    h, w = len(setting), len(setting[0])\r\n    y0 = next(i for i, r in enumerate(setting) if 'Y' in r)\r\n    x0 = setting[y0]. index('Y')\r\n\r\n    if y0 + 1 == h:\r\n        return res\r\n\r\n    def invalid(y, x): return y < 0 or x < 0 or y >= h or x >= w\r\n    def at(y, x): return '.' if invalid(y, x) else setting[y][x]\r\n\r\n    def go(dx):\r\n    if abs(dx) > 2:\r\n        return\r\n    x1, dy = x0 + dx, 0\r\n    if x1 < 0 or x1 >= w:\r\n        return\r\n    if at(y0, x1) != '.':\r\n        return\r\n    go(dx + (- 1 if dx < 0 else 1))\r\n    while at(y0 + dy + 1, x1) == '.' and dy < 9:\r\n        dy += 1\r\n    if dy == 0 or dy > 8:\r\n        return\r\n    if dy > 2 and at(y0 + dy + 1, x1) in \"#x\":\r\n        return\r\n    if dy > 4 and at(y0 + dy + 1, x1) == \"~\" and at(y0 + dy + 2, x1) != \"~\":\r\n        return\r\n    if dy > 4 and at(y0 + dy + 1, x1) == \"~\" and at(y0 + dy + 2, x1) == \"~\":\r\n        dy += 1\r\n    if at(y0 + dy + 1, x1) == \"~\":\r\n        dy += 1\r\n    res . append((dy, dx))\r\n\r\n    for dx in [- 1, 1]:\r\n    go(dx)\r\n\r\n    return res\r\n",
  "6394c1995e54bd00307cf768": "endings = {\r\n    'Je': 'ais',\r\n    'Tu': 'ais',\r\n    'Il': 'ait',\r\n    'Elle': 'ait',\r\n    'On': 'ait',\r\n    'Nous': 'ions',\r\n    'Vous': 'iez',\r\n    'Ils': 'aient',\r\n    'Elles': 'aient'\r\n}\r\n\r\n\r\ndef to_imparfait(verb_phrase):\r\n    return verb_phrase[: - 2] + endings[verb_phrase . split()[0]]\r\n",
  "639242518e28a700283f68ee": "from concurrent . futures import *\r\n\r\n\r\ndef task_master(a):\r\n    with ThreadPoolExecutor(max_workers=len(a)) as executor:\r\n    return sum(executor . map(lambda f: f(), a))\r\n",
  "6390ea74913c7f000d2e95cd": "from socket import create_server\r\n\r\n\r\ndef socket_server():\r\n    with create_server(('127.0.0.1', 80), reuse_port=True) as s:\r\n    with s . accept()[0] as t:\r\n    while True:\r\n    bs = t . recv(0xDEAD)\r\n    if bs == b'exit':\r\n    break\r\n    t . send(bs)\r\n",
  "639107e0df52b9cb82720575": "from socket import create_connection\r\n\r\n\r\ndef socket_client():\r\n    with create_connection(('127.0.0.1', 1111)) as s:\r\n    s . send(b'ab')\r\n    return s . recv(2) == b'ab'\r\n",
  "6391fe3f322221003db3bad6": "def perpendicular(n):\r\n    return n * n / / 4\r\n",
  "638e399a2d712300309cf11c": "from collections import defaultdict, Counter\r\nfrom operator import itemgetter\r\n\r\n\r\ndef render_champions(submissions, n_min):\r\n    if len(submissions) < n_min:\r\n        return ''\r\n    best = min(map(itemgetter(1), submissions[: n_min]))\r\n    record = defaultdict(list)\r\n    order = defaultdict(list)\r\n    for name, n in submissions:\r\n    if n <= best:\r\n    best = n\r\n    order[n]. append(name)\r\n    record[name]. append(n)\r\n\r\n    def best_submission_then_best_order(name):\r\n    top = record[name][- 1]\r\n    return top, order[top]. index(name)\r\n\r\n    def format_people(name):\r\n    grp = Counter(reversed(record[name]))\r\n    perfs = ', ' . join(\r\n        str(size) if n == 1 else f' { size } ( { n } )' for size, n in grp . items())\r\n    return f' { name } - { perfs } '\r\n    ordered = sorted(record, key=best_submission_then_best_order)\r\n    return '; ' . join(map(format_people, ordered))\r\n",
  "638f6152d03d8b0023fa58e3": "from itertools import count\nfrom random import randint\nfrom gmpy2 import is_prime\n\n\ndef represent(n: int) - > int:\n    \"\"\" \n with some algebra I found that: \n (i+1)C2 + (j+1)C2 + (k+1)C2 = N is equivalent to (2i+1)^2 + (2j+1)^2 + (2k+1)^2 = 8N+3 \n so the new goal is to find 3 odd squares (A^2 + B^2 + C^2) that sum of 8N + 3 \n i do this by choosing an odd value of A (starting from 1) and computing it x := 8*N+3 - A^2 \n x will be congruent to 2 mod 8 because A^2 (an odd square) is always congruent to 1 mod 8 \n this means that x // 2 is congruent to 1 mod 4 \n i proceed if x // 2 is also a prime because this guarantees that a valid B and C can be found \n otherwise i go back and choose the next odd value A can take \n \n this assumes that for any natural number of the form 8*n+3, \n there exists a prime less than or equal to 4*n+1 congruent to 1 mod 4 \n fortunately this holds \n \n sources on representing a number as a sum of three squares (most useful sources first): \n https://math.stackexchange.com/questions/483101/rabin-and-shallit-algorithm \n https://crypto.stackexchange.com/questions/61961/sum-of-two-squares-problem \n https://mathoverflow.net/questions/110239/is-there-an-algorithm-for-writing-a-number-as-a-sum-of-three-squares \n \"\"\"\n    def gcd_complex(a, b, c, d):\n    while not (c == d == 0):\n    k = c * c + d * d\n    e = round((a * c + b * d) / k)\n    f = round((b * c - a * d) / k)\n    g = a - c * e + d * f\n    h = b - c * f - d * e\n    a, b, c, d = c, d, g, h\n    return a, b\n    def two_odd_squares(x):\n    x / /= 2\n    if not is_prime(x):\n        return None, None\n    t = (x - 1) / / 4\n    while True:\n    s = pow(randint(1, x - 1), t, x)\n    if s * s % x == x - 1:\n        break\n    a, b = sorted(map(abs, gcd_complex(x, 0, s, 1)))\n    a, b = b - a, a + b\n    return a, b\n    target = 8 * n + 3 - 1 * * 2\n    for A in count(1, 2):\n    B, C = two_odd_squares(target)\n    if (B, C) != (None, None):\n    i, j, k = map(lambda t: (t - 1) / / 2, (A, B, C))\n    f_i, f_j, f_k = map(lambda t: t * (t + 1) / / 2, (i, j, k))\n    return [f_i, f_j, f_k]\n    target -= 4 * A + 4\n",
  "638edc41458b1b00165b138b": "# Most clutched solution I found: (p[-1] - 1) // (p[0] - 1) = 4 / 3\nprimes = [24284400 * k + 1 for k in (24, 30, 33, 36, 38, 39, 40)]\n",
  "638c92b10e43cc000e615a07": "# https://en.wikipedia.org/wiki/Prime-counting_function\r\nfrom math import isqrt\r\nfrom functools import cache\r\nfrom bisect import bisect\r\nimport sys\r\nsys . setrecursionlimit(10 * * 5)\r\n\r\n# https://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188\r\n\r\n\r\ndef rwh_primes(n):\r\n    \"\"\" Returns a list of primes < n \"\"\"\r\n    sieve = [True] * n\r\n    for i in range(3, int(n * * 0.5) + 1, 2):\r\n    if sieve[i]:\r\n    sieve[i * i:: 2 * i] = [False] * ((n - i * i - 1) / / (2 * i) + 1)\r\n    return [2] + [i for i in range(3, n, 2) if sieve[i]]\r\n\r\n    PRIMES = rwh_primes(10 * * 7)\r\n\r\n    @ cache\r\n    def phi(m, n):\r\n    if n == 1 or m < 1:\r\n        return (m + 1) / / 2\r\n    p = PRIMES[n - 1]\r\n    # https://ideone.com/SnhEQA\r\n    if p * p >= m and m < PRIMES[- 1]:\r\n    return bisect(PRIMES, m) - n + 1\r\n    return phi(m, n - 1) - phi(m / / p, n - 1)\r\n\r\n    def pi(m):\r\n    if m <= PRIMES[- 1]:\r\n    return bisect(PRIMES, m)\r\n    n = pi(int((m + 0.5) * * (1 / 3)))\r\n    mu = pi(isqrt(m)) - n\r\n    return phi(m, n) + n * (mu + 1) + mu * (mu - 1) / / 2 - 1 - sum(pi(m / / PRIMES[n + k]) for k in range(mu))\r\n\r\n    count_primes_less_than = pi\r\n",
  "638b042bf418c453377f28ad": "import itertools\r\n\r\n\r\ndef guess(n):\r\n    if n == - 1:\r\n        # Start by guessing the first code in the list\r\n    guess . remaining_codes = list(itertools . permutations(range(10), 4))\r\n    guess . prev_guess = guess . remaining_codes[0]\r\n    else:\r\n        # Remove any code from the list that would not produce the same number of matches\r\n    guess . remaining_codes = [code for code in guess . remaining_codes\r\n                               if sum(a == b for a, b in zip(code, guess . prev_guess)) == n]\r\n    # Choose the next code in the list and guess it\r\n    guess . prev_guess = guess . remaining_codes[0]\r\n    return list(guess . prev_guess)\r\n\r\n    guess . remaining_codes = None\r\n    guess . prev_guess = None\r\n",
  "638b4205f418c4ab857f2692": "from collections import Counter\r\nfrom math import ceil, gcd, log, prod\r\nfrom random import randrange\r\nfrom gmpy2 import is_prime\r\n\r\n\r\ndef pollard_rho(n):\r\n    while True:\r\n    x, c = randrange(1, n), randrange(1, n)\r\n    def f(x): return (x * x + c) % n\r\n    y = f(x)\r\n    while (d := gcd(abs(x - y), n)) == 1:\r\n    x, y = f(x), f(f(y))\r\n    if d != n:\r\n    return d\r\n    def factor(n):\r\n    if is_prime(n):\r\n        return Counter([n])\r\n    return factor(r := pollard_rho(n)) + factor(n / / r)\r\n\r\n    def f(m):\r\n    if m == 1:\r\n        return 1\r\n    factors = factor(m)\r\n    product, max_order = prod(factors), max(factors . values())\r\n    return min((m := product * * k) * ceil(max_order / k / m)\r\n               for k in range(1, int(log(max_order, product)) + 2))\r\n",
  "638bc5d372d41880c7a99edc": "M = 10 * * 9 + 7\n\n\ndef f(n: int) - > int:\n    # g(x) = sum(x^k, k = 0..n)\n    # Then sum(k^2 * x^2, k = 0..n) = x^2 g''(x) + x(g'(x) - 1) + x\n    # g'(2) = (n - 1) * 2^n + 1\n    # g''(2) = ...\n    def g2(n): return (n * n * pow(2, n, M) - 3 * n *\n                       pow(2, n, M) + pow(2, n + 2, M) - 4) * pow(2, M - 2, M)\n\n    def g1(n): return pow(2, n, M) * (n - 1) + 1\n    return (4 * g2(n) + 2 * (g1(n) - 1) + 2) % M\n    # Wolfram Alpha:\n    return 2 * (pow(2, n, M) * (n * n - 2 * n + 3) - 3) % M\n",
  "638af78312eae9a23c9ec5d6": "from math import isqrt\r\nprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\r\n          41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\r\n\r\n\r\ndef g(n, i):\r\n    p = primes[i]\r\n    m = p * * (n - 1)\r\n    for d in range(2, isqrt(n) + 1):\r\n    if n % d == 0:\r\n        m = min(m, p * * (d - 1) * g(n / / d, i + 1), p * * (n / / d - 1) * g(d, i + 1))\r\n    return m\r\n    def f(n): return g(n, 0)\r\n",
  "637874b78ee59349c87b018d": "def fractalize(seed, i):\r\n    if i <= 1:\r\n        return seed\r\n    star = fractalize(seed, i - 1)\r\n    dot = [row . replace('*', '.') for row in star]\r\n    return [\r\n        '' . join(rowrow)\r\n        for row in seed\r\n        for rowrow in zip(* (star if c == '*' else dot for c in row))\r\n    ]\r\n",
  "63890d2ef418c49d4c7f50cc": "def trapped_cell(n: int, m: int) - > int:\r\n    def spiral(x, y):\r\n    u, v = (x, y) if abs(x) <= abs(y) else (y, x)\r\n    return v * (4 * v - [1, 3][y < x]) + [- u, u][y < x]\r\n    x, y = 0, 0\r\n    visited = set([(x, y)])\r\n    while True:\r\n    ps = [(x + dx, y + dy) for dx, dy in ((- n, - m), (n, - m), (- n, m), (n, m),\r\n                                          (- m, - n), (m, - n), (- m, n), (m, n)) if (x + dx, y + dy) not in visited]\r\n    if not ps:\r\n    return spiral(x, y)\r\n    x, y = min(ps, key=lambda p: spiral(p[0], p[1]))\r\n    visited . add((x, y))\r\n",
  "6387ea2cf418c41d277f3ffa": "def cube(n):\r\n    top = \"\\n\" . join(' ' * (n - i - 1) + '/\\\\' *\r\n                      (i + 1) + '_\\\\' * n for i in range(n))\r\n    bottom = \"\\n\" . join(' ' * i + '\\\\/' * (n - i) +\r\n                         '_/' * n for i in range(n))\r\n    return top + '\\n' + bottom\r\n",
  "638244fb08da6c61361d2c40": "from collections import defaultdict\r\n\r\n\r\ndef find_waldo(crowd):\r\n    d = defaultdict(list)\r\n    for y, row in enumerate(crowd):\r\n    for x, c in enumerate(row):\r\n    if c . isalpha():\r\n    d[c]. append([y, x])\r\n    return next(v[0] for k, v in d . items() if len(v) == 1)\r\n",
  "637d1d6303109e000e0a3116": "def find_matched_by_pattern(pattern):\r\n    def f(s, p=pattern):\r\n    for c in s:\r\n    if c == p[0]:\r\n        p = p[1:]\r\n    elif c in p:\r\n        break\r\n    if not p:\r\n        return True\r\n    return False\r\n    return f\r\n",
  "63838c67bffec2000e951130": "def safe_mine_field(mine_field):\r\n    if mine_field:\r\n    h, w = len(mine_field), len(mine_field[0])\r\n    for i, row in enumerate(mine_field):\r\n    for j, x in enumerate(row):\r\n    if x == 'M':\r\n    for a, b in ((- 1, 0), (1, 0), (0, - 1), (0, 1)):\r\n    k, l = i + a, j + b\r\n    while 0 <= k < h and 0 <= l < w and 'M' != mine_field[k][l] != 'T':\r\n    mine_field[k][l], k, l = 'C', k + a, l + b\r\n    return [(i, j) for i, row in enumerate(mine_field) for j, x in enumerate(row) if x == '.']\r\n",
  "637d054dca318e60ef4a3830": "import numpy\nfunny = numpy . matrix  # Sorry\nfunny . __class_getitem__ = numpy . matrix\narr = funny[[[1, 1], [1, 0]]]\nfunny . __class_getitem__ = arr . astype\narr = funny[object]\nfunny . __class_getitem__ = lambda v: v[0, 1]\ndef fibo(n): return funny[arr * * n]\n",
  "6375587af84854823ccd0e90": "LETTERS = '''\\ \n AAA BBBB CCC DDDD EEEEE FFFFF GGG H H IIIII JJJJJ K K L M M N N OOO PPPP QQQ RRRR SSS TTTTT U U V V W W X X Y Y ZZZZZ \n A A B B C C D D E F G G H H I J K K L MM MM NN N O O P P Q Q R R S S T U U V V W W X X Y Y Z \n A A B B C D D E F G H H I J K K L M M M N N O O P P Q Q R R S T U U V V W W X X Y Y Z \n AAAAA BBBB C D D EEEEE FFFFF G GGG HHHHH I J KK L M M N N N O O PPPP Q Q RRRR SSS T U U V V W W W X Y Z \n A A B B C D D E F G G H H I J K K L M M N N O O P Q Q Q R R S T U U V V W W W X X Y Z \n A A B B C C D D E F G G H H I J K K L M M N NN O O P Q QQ R R S S T U U V V W W W X X Y Z \n A A BBBB CCC DDDD EEEEE F GGG H H IIIII JJJJ K K LLLLL M M N N OOO P QQQQ R R SSS T UUU V W W X X Y ZZZZZ\\ \n ''' . split('\\n')\n\n\ndef block_print(s):\n    return s . strip() and '\\n' . join(\" \" . join(LETTERS[i][(c - 65) * 6:(c - 64) * 6 - 1] if c > 32 else \" \" * 5 for c in map(ord, s . strip(). upper())). rstrip() for i in range(7))\n",
  "6375e9030ac764004a036840": "from dateutil . parser import parse\r\nfrom dateutil . relativedelta import relativedelta\r\n\r\n\r\ndef most_weekend_birthdays(friends, conversation_date):\r\n    def func(args):\r\n    count, year, birthday = 0, 1, parse(args[1])\r\n    while (current := birthday + relativedelta(years=year)) <= today:\r\n    count += (current . weekday() >= 5)\r\n    year += 1\r\n    return count, birthday\r\n    today = parse(conversation_date)\r\n    return max(friends, key=func)[0]\r\n",
  "6376bbc66f2ae900343b7010": "def movie_times(open, close, length):\n    if close <= 6 or close < open:\n        close += 24\n    r, t, u = [], open * 60, close * 60\n    while t + length <= u:\n        r . append((t / / 60 % 24, t % 60))\n        t += length + 15\n    return r\n",
  "63753f7f64c31060a564e790": "def sleep(bits: str) - > str:\r\n    i = min(range(12), key=lambda i: (bits[i:] + bits[: i])[:: - 1])\r\n    return '0' * i + '1' + '0' * (11 - i)\r\n",
  "63744cbed39ec3376c84ff4a": "import re  # regex is good, let's use it\n\n\ndef arrow_search(string: str) - > int:\n    return sum(  # calculate sum of scores for each arrow\n        # using the below method:\n        len(arrow)  # size of the arrow\n        # multiplied by +1/-1 based on direction\n        * ((\">\" in arrow) - (\"<\" in arrow))\n        * (2 if \"=\" in arrow else 1)  # multiplied by 2 if it has a tail of \"=\"\n        for arrow in re . findall(  # for each arrow found\n            \"\"\" # using the below regex: \n <?-+>? # arrow with \"-\" tail \n | # or \n <?=*>? # arrow with \"=\" tail \n \"\"\", string, re . VERBOSE)  # in the input string\n    )\n",
  "636bebc1d446bf71b3f65fa4": "from itertools import count\r\n\r\n\r\ndef hofs():\r\n    yield 1\r\n    xs, ys, n, y = count(1), hofs(), 1, None\r\n    while True:\r\n    x, y = next(xs), y or next(ys)\r\n    if x == y:\r\n    yield (n := n + next(xs))\r\n    y = None\r\n    else:\r\n    yield (n := n + x)\r\n\r\n    hofs_gen, hofs_cache = hofs(), []\r\n\r\n    def hof(n):\r\n    while len(hofs_cache) <= n:\r\n    hofs_cache . append(next(hofs_gen))\r\n    return hofs_cache[n]\r\n",
  "636b03830ae6cd00388cd228": "def operations(x):\r\n    return x . bit_count() + x . bit_length() - 1\r\n",
  "6368426ec94f16a1e7e137fc": "import re\r\n\r\n\r\ndef contact(hallway):\r\n    pairs = re . findall('>-*<', hallway)\r\n    return min(map(len, pairs)) / / 2 if pairs else - 1\r\n",
  "6363b0c4a93345115c7219cc": "from itertools import count, islice\r\n\r\n\r\ndef sequence():\r\n    cnt, seq = count(1), sequence()\r\n    while 1:\r\n    yield next(cnt)\r\n    n = next(seq)\r\n    yield from islice(cnt, n - 1)\r\n    yield n\r\n    a112382 = list(islice(sequence(), 1_000_000)). __getitem__\r\n",
  "63624a696137b6000ed726a6": "def minimum_amount(lst):\r\n    f = s = r1 = r2 = 0\r\n    for i, x in enumerate(lst):\r\n    if i % 2:\r\n    f, s = f + x, s - x\r\n    r2 = max(r2, - s)\r\n    else:\r\n    f, s = f - x, s + x\r\n    r1 = max(r1, - f)\r\n    return r1, r2\r\n",
  "635d9b5c8f20017aa1cf2cf6": "tbl = {\r\n    'r': [\r\n        [1, 1, 1, 1, 1],\r\n        [1, 0, 1, 0, 1],\r\n        [1, 1, 1, 1, 1],\r\n        [1, 0, 1, 0, 1],\r\n        [1, 1, 1, 1, 1],\r\n    ],\r\n    'b': [\r\n        [1, 0, - 1, 0, 1],\r\n        [0, 1, 0, 1, 0],\r\n        [- 1, 0, 1, 0, - 1],\r\n        [0, 1, 0, 1, 0],\r\n        [1, 0, - 1, 0, 1],\r\n    ],\r\n    'q': [\r\n        [1, 1, 1, 1, 1],\r\n        [1, 1, 0, 1, 1],\r\n        [1, 0, 1, 0, 1],\r\n        [1, 1, 0, 1, 1],\r\n        [1, 1, 1, 1, 1],\r\n    ]\r\n}\r\n\r\n# starting_piece: a string, either 'r', 'b', 'q'\r\n# starting_row: an integer from 0 to 4 inclusive\r\n# starting_column: an integer from 0 to 4 inclusive\r\n\r\n\r\ndef transforming_chess(starting_piece, starting_row, starting_column):\r\n    # you must return one of three strings:\r\n    # 'win' if Player 1 has a guaranteed win\r\n    # 'lose' if Player 1 is guaranteed to lose\r\n    # 'draw' if the game is a never-ending infinite draw\r\n    return ['draw', 'win', 'lose'][tbl[starting_piece][starting_row][starting_column]]\r\n",
  "6361bdb5d41160000ee6db86": "search = \".+(?= (dog|cat))\"\nsubstitute = \"blue\"\n",
  "636173d79cf0de003d6834e4": "from itertools import groupby\r\nDIRS = {'^': 'up', 'v': 'down', '<': 'left', '>': 'right'}\r\n\r\n\r\ndef walk(path):\r\n    if not path:\r\n    return 'Paused'\r\n    steps = []\r\n    for k, g in groupby(path):\r\n    l = len(list(g))\r\n    steps . append(f\"Take { l } step { 's' * ( l > 1 )} { DIRS [ k ]} \")\r\n    return '\\n' . join(steps)\r\n",
  "579f54c672292dc1a20001bd": "from typing import Tuple\r\n\"\"\"Gets the chord, given the root and color. \r\n    returns \r\n    ---------- \r\n    chord : tuple \r\n    the chord consisting of its notes -> (C, Eb, G), (F#, A, C#), .. \r\n    arguments \r\n    ---------- \r\n    root : str \r\n    the root note of the chord -> C, D, F#, Ab, .. \r\n    color : str \r\n    the color or type of chord -> m, M, dim, aug \r\n    \"\"\"\r\n\r\n\r\ndef chord_triad(root: str, color: str) - > Tuple:\r\n    notes = ('C', 'D', 'E', 'F', 'G', 'A', 'B')\r\n    shifts = ('bb', 'b', '', '#', 'x')\r\n\r\n    def is_major(note):\r\n       # checks if the third from the note is major\r\n       # that's true for C, F, and G only\r\n    return note in (0, 3, 4)\r\n\r\n    def third_note(note):\r\n    return notes[(note + 2) % len(notes)]\r\n\r\n    def minor(note, shift):\r\n    shift -= is_major(note)\r\n    return third_note(note) + shifts[shift]\r\n\r\n    def major(note, shift):\r\n    shift += not is_major(note)\r\n    return third_note(note) + shifts[shift]\r\n\r\n    triads = {\r\n        'm': (minor, major),\r\n        'M': (major, minor),\r\n        'dim': (minor, minor),\r\n        'aug': (major, major),\r\n    }\r\n\r\n    def get_note(root=root):\r\n    note, shift = root[0], root[1:]\r\n    return notes . index(note), shifts . index(shift)\r\n\r\n    def get_interval(i, root=root):\r\n    return triads[color][i](* get_note(root))\r\n\r\n    third = get_interval(0)\r\n    return (root, third, get_interval(1, third))\r\n",
  "635f67667dadea064acb2c4a": "CREW = {\"F\": \"Frank\", \"S\": \"Sam\", \"T\": \"Tom\"}\r\nNON_WATER_PROOF = [* CREW, ' ', 'x']\r\n\r\n\r\nclass Flotsam:\r\n    def __init__(self, pic):\r\n    self . pic = pic\r\n    self . sea_level = next(i for i, x in enumerate(pic) if '~' in x)\r\n    self . bottom = len(self . pic)\r\n    self . width = len(self . pic[0])\r\n    self . survivors = dict(* * CREW)\r\n\r\n    def show(self):\r\n    print(\"\\n\" . join([\"\" . join(row) for row in self . pic]))\r\n\r\n    def drown(self, person):\r\n    name = self . survivors . pop(person)\r\n    print(f\" { name } drowned!\")\r\n\r\n    def leak(self, i1, j1, i2, j2) - > bool:\r\n    a, b = self . pic[i1][j1], self . pic[i2][j2]\r\n    if a == '~' and b in NON_WATER_PROOF:\r\n    if b in self . survivors:\r\n    self . drown(b)\r\n    self . pic[i2][j2] = '~'\r\n    return True\r\n    else:\r\n    return False\r\n    def sink(self):\r\n    leaked = False\r\n    for i in range(self . sea_level, self . bottom):\r\n    for direction in (1, - 1):\r\n    for j in [* range(self . width)][:: direction]:\r\n    if j < self . width - 1:\r\n    leaked |= self . leak(i, j, i, j + 1)\r\n    leaked |= self . leak(i, j + 1, i, j)\r\n    if i > self . sea_level:\r\n    leaked |= self . leak(i, j, i - 1, j)\r\n    if self . sea_level <= i < self . bottom - 1:\r\n    leaked |= self . leak(i, j, i + 1, j)\r\n    self . show()\r\n    if leaked and self . survivors:\r\n    print(self . survivors)\r\n    self . sink()\r\n\r\n    def flotsam(pic):\r\n    o = Flotsam(pic)\r\n    o . show()\r\n    o . sink()\r\n    result = \" \" . join(o . survivors . values())\r\n    return (result)\r\n",
  "635e70f47dadea004acb5663": "from itertools import pairwise\n\n\ndef triangle(row):\n    return len(row) == 1 and row or triangle('' . join(chr((x + y + 15) % 26 + 97) for x, y in pairwise(map(ord, row))))\n",
  "635d6302fdfe69004a3eba84": "from math import sin, cos, pi, radians\n\n\ndef laser_coord(h, a, l):\n    x, y = (l * cos(radians(a))) % 2, (h + l * sin(radians(a))) % 2\n    return (2 - x if x > 1 else x), (2 - y if y > 1 else y)\n",
  "635d422dfdfe6900283eb892": "\"\"\" \n (1 + P(n+2)) = (1 + P(n+1)) * (1 + P(n)) \n (1 + P(n+3)) = (1 + P(n+2)) * (1 + P(n+1)) = (1 + P(n+1))**2 + (1 + P(n)) \n (1 + P(n+4)) = (1 + P(n+3)) * (1 + P(n+2)) = (1 + P(n+1))**3 + (1 + P(n))**2 \n (1 + P(n+5)) = (1 + P(n+1))**5 + (1 + P(n))**3 \n the exponents follow a fibonacci pattern, \n so we can calculate them by raising the matrix ((0, 1), (1, 1)) to the nth power \n to keep the variables small, we can use mod 6 because all 10 digit-powers mod 9 repeat every 6 \n \"\"\"\n\n\ndef G(n):\n    if n <= 1:\n        return [7, 4][n]\n\n    def mod_6(x): return x if x <= 6 else 6 + x % 6\n    a, b, c, d, pow1, pow2, n = 0, 1, 1, 1, 1, 1, n - 2\n    while n:\n    if n % 2 == 1:\n    pow1, pow2 = map(mod_6, (a * pow1 + b * pow2, c * pow1 + d * pow2))\n    n -= 1\n    else:\n    a, b, c, d = map(mod_6, (a * a + b * c, a * b + b *\n                     d, a * c + c * d, d * d + b * c))\n    n / /= 2\n    return (pow(1 + 7, pow1, 9) * pow(1 + 31, pow2, 9) - 1) % 9\n",
  "6355b3975abf4f0e5fb61670": "from math import comb as nCk, factorial as fac\r\nfrom itertools import combinations, chain, product\r\n\r\n\r\ndef totally_good(alphabet, bads):\r\n\r\n    # starting conditions\r\n    bads = [b for b in bads if not any(o != b and o in b for o in bads)]\r\n    n, t = len(alphabet), fac(len(alphabet))\r\n\r\n    # simple edge cases\r\n    if not bads:\r\n        return t\r\n    if any(1 for b in bads if len(b) == 1):\r\n        return 0\r\n    # combinatorics & string patterns\r\n    def count(group, n):\r\n    m, seen, start_cluster = 0, set(), product(\r\n        * [list(range(n - len(b) + 1)) for b in group])\r\n    for start_group in start_cluster:\r\n    word, c = [\"*\"] * n, False\r\n    for source_idx, target_idx in enumerate(start_group):\r\n    if c:\r\n        break\r\n    b = group[source_idx]\r\n    for i in range(len(b)):\r\n    if word[target_idx + i] != \"*\" and word[target_idx + i] != b[i]:\r\n    c = True\r\n    break\r\n    word[target_idx + i] = b[i]\r\n    word = '' . join(word)\r\n    if word not in seen and all(e in word for e in group) and len(set([c for c in word if c != '*'])) == len([c for c in word if c != '*']):\r\n    open = word . count(\"*\")\r\n    m += fac(open)\r\n    seen . add(word)\r\n    return m\r\n    # set theory: inclusion/exclusion principle\r\n    history, cluster = {tuple(): t}, list(\r\n        chain(* [combinations(bads, i) for i in range(1, n)]))\r\n    for group in cluster:\r\n    if all(history[subgroup] for subgroup in combinations(group, len(group) - 1)):\r\n    history[group] = count(group, n)\r\n    t += history[group] * (- 1) * * len(group)\r\n    else:\r\n    history[group] = 0\r\n    return t\r\n",
  "6359f0158f20011969cf0ebe": "# The speeding car: \"O='`o\"\n# The other cars: \"X\"\ndef car_crash(road):\n    return \"O='`oX\" in road . replace(' ', '')\n",
  "635b8fa500fba2bef9189473": "import re\r\n\r\n\r\ndef phone_words(str):\r\n    ansd = {'0': ' ', '2': 'a', '22': 'b', '222': 'c', '3': 'd', '33': 'e', '333': 'f',\r\n            '4': 'g', '44': 'h', '444': 'i', '5': 'j', '55': 'k', '555': 'l', '6': 'm',\r\n            '66': 'n', '666': 'o', '7': 'p', '77': 'q', '777': 'r', '7777': 's', '8': 't', '88': 'u',\r\n            '888': 'v', '9': 'w', '99': 'x', '999': 'y', '9999': 'z'}\r\n    ans = ''\r\n    for i in re . findall('0|2{1,3}|3{1,3}|4{1,3}|5{1,3}|6{1,3}|7{1,4}|8{1,3}|9{1,4}', str):\r\n    ans += ansd[i]\r\n    return ans\r\n",
  "635a7827bafe03708e3e1db6": "def speed_limit(\u0441\u043a\u043e\u0440\u043e\u0441\u0442\u044c, \u0441\u0438\u0433\u043d\u0430\u043b\u044b):\r\n    \u0448\u0442\u0440\u0430\u0444 = 0\r\n    for \u0438 in \u0441\u0438\u0433\u043d\u0430\u043b\u044b:\r\n    if 10 <= \u0441\u043a\u043e\u0440\u043e\u0441\u0442\u044c - \u0438 <= 19:\r\n    \u0448\u0442\u0440\u0430\u0444 += 100\r\n    if 20 <= \u0441\u043a\u043e\u0440\u043e\u0441\u0442\u044c - \u0438 <= 29:\r\n    \u0448\u0442\u0440\u0430\u0444 += 250\r\n    if 30 <= \u0441\u043a\u043e\u0440\u043e\u0441\u0442\u044c - \u0438:\r\n    \u0448\u0442\u0440\u0430\u0444 += 500\r\n    return \u0448\u0442\u0440\u0430\u0444\r\n",
  "6359b10f8f2001f29ccf0db4": "def squares_to_odd(a, b):\r\n    return f' { a } ^2 - { b } ^2 = { \" + \" . join ( map ( str , range ( 2 * b + 1 , 2 * a , 2 )))} = { a * a - b * b } '\r\n",
  "63586460bafe0300643e2caa": "def get_sum(n):\r\n    n, m = divmod(n, 2)\r\n    return - (n + 2 * m - 1) * (n + m + 1) * * 2\r\n",
  "63579823d25aad000ecfad9f": "# see: https://oeis.org/A035608\ndef get_sum(n):\n    return (- 1) * * n * ((n := n + 1) * n + n - 1 - (n - 1) / / 2)\n",
  "634f18946a80b8003d80e728": "def make_strategies(hats):\n    ''' \n    We can ensure that one team member always wins, by \n    making sure that there is no overlap between the guesses \n    of each of our contestants. We do this by giving each \n    team member a unique number (from 0 to n-1). They are then \n    to assume that the total \"sum\" of hats modulo n (assigning \n    each hat an arbitrary value) will be equal to their number. \n    They can therefore determine what hat theirs must be by \n    seeing all the other hats, and make their guess. This means \n    that no matter what modulo a particular game produces, one \n    team member will be accounting for it. \n    This kata was inspired by this video, which also explains \n    the solution incredibly well: \n    https://www.youtube.com/watch?v=6hVPNONm7xw \n    '''\n    def sum_ind(i): return lambda seen: hats[(\n        i - sum(map(hats . index, seen))) % len(hats)]\n    return [sum_ind(i) for i in range(len(hats))]\n",
  "6357825a00fba284e0189798": "def get_sum(n):\r\n    return (n + 1) * (n + 2) * (4 * n + 3) / / 6\r\n",
  "6357205000fba205ed189a52": "# for a proper solution: ...://bellard.org/pi/pi1.c\ndef pi_gen(limit):\n    q, r, t, k, n, l, cn, d = 1, 0, 1, 1, 3, 3, 0, limit\n    while cn != d + 1:\n    if 4 * q + r - t < n * t:\n    yield n\n    if d == cn:\n        break\n    cn, nr, n, q = cn + 1, 10 * (r - n * t), ((10 * (3 * q + r)) / / t) - 10 * n, q * 10\n    r = nr\n    else:\n    nr, nn, q, t, l, k = (2 * q + r) * l, (q * (7 * k) + 2 + (r * l)) / / (t * l), q * k, t * l, l + 2, k + 1\n    n, r = nn, nr\n    PI = pi_gen(10000)\n    PI = '' . join(map(str, PI))\n\n    def pi(n):\n    return int(PI[n])\n",
  "635640ee633fad004afb0465": "from collections import defaultdict\r\nfrom itertools import chain\r\n\r\n\r\ndef letter(msg):\r\n    D = defaultdict(list)\r\n    for w in map(str . lower, msg . split()):\r\n    for i in range(len(w)):\r\n    D[w[: i + 1]]. append(w)\r\n    return sorted(chain . from_iterable(v for k, v in D . items() if len(k) == len(v)))\r\n",
  "6352feb15abf4f44f9b5cbda": "from fractions import Fraction\r\n\r\n\r\ndef get_probability(n, nbs, nrs):\r\n    pr = Fraction(0)\r\n    for i, (nb, nr) in enumerate(zip(nbs, nrs)):\r\n    pr = (nr + pr) / (nb + nr + (i != 0))\r\n    return float(pr)\r\n",
  "634d0f7c562caa0016debac5": "def is_defended(attackers, defenders):\n    survivors = [0, 0]\n    for k in range(max(len(attackers), len(defenders))):\n    if len(attackers) <= k:  # Empty attacker\n    survivors[1] += 1\n    elif len(defenders) <= k:  # Empty defender\n    survivors[0] += 1\n    elif attackers[k] < defenders[k]:\n    survivors[1] += 1\n    elif attackers[k] > defenders[k]:\n    survivors[0] += 1\n    return survivors[0] < survivors[1] if survivors[0] != survivors[1] else sum(attackers) <= sum(defenders)\n",
  "634d0723075de3f97a9eb604": "def encode(s):\r\n    return \"\" . join(s[((i + 1) / / 2) * (- 1) * * i] for i in range(len(s)))\r\n\r\n    def decode(s):\r\n    return s[:: 2] + s[1:: 2][:: - 1]\r\n",
  "6347f9715467f0001b434936": "def root(M):\r\n    return sum(sum(r) * * .5 for r in M)\r\n\r\n    def thin_or_fat(M):\r\n    w, h = root(M), root(zip(* M))\r\n    if not any(isinstance(v, complex) for v in (w, h)):\r\n    return \"perfect\" if abs(w - h) < 1e-10 else \"fat\" if w > h else \"thin\"\r\n",
  "6324c4282341c9001ca9fe03": "def tree_to_prufer(tree):\r\n    res = []\r\n    for _ in range(len(tree) - 2):\r\n    mn = min(k for k, v in tree . items() if len(v) == 1)\r\n    res . append([* tree[mn]][0])\r\n    tree . pop(mn)\r\n    for k, v in tree . items():\r\n    if mn in v:\r\n        v . remove(mn)\r\n\r\n    return res\r\n    def prufer_to_tree(prufer_sequence):\r\n    ln, pf = len(prufer_sequence), prufer_sequence[:]\r\n    s = {* range(1, ln + 3)}\r\n    res = {k: set() for k in s}\r\n\r\n    for _ in range(ln):\r\n    cur = min(s - set(pf))\r\n    s . remove(cur)\r\n    res[cur]. add(pf[0])\r\n    res[pf . pop(0)]. add(cur)\r\n\r\n    a, b = s\r\n    res[a]. add(b)\r\n    res[b]. add(a)\r\n\r\n    return res\r\n",
  "634ac4e77611b9f57dff456d": "from keyword import kwlist\nkeywords = set(kwlist)\n",
  "634913db7611b9003dff49ad": "import re\n\n\ndef purify(s: str) - > str:\n    return ' ' . join(re . sub(r\"[\\S]?[iI][^\\siI]?\", \"\", s). split())\n",
  "6344701cd748a12b99c0dbc4": "from itertools import pairwise, permutations\r\n\r\n\r\ndef solution(arr):\r\n    for perm in permutations(arr, len(arr)):\r\n    if all(a[- 1] == b[0] for a, b in pairwise(perm)):\r\n    return True\r\n    return False\r\n",
  "63454405099dba0057ef4aa0": "def draw_street(dimensions):\r\n    maxHeight = max(map(lambda x: x[0], dimensions))\r\n    def building(dimensions):\r\n    h, w = dimensions\r\n    return [' ' * w] * (maxHeight - h) + [\r\n        '\u25a0' * w] + [\r\n        '\u25a0' + ' ' * (w - 2) + '\u25a0'] * (h - 4) + [\r\n        '\u25a0' + '___' . center(w - 2, ' ') + '\u25a0',\r\n        '\u25a0' + '| |' . center(w - 2, ' ') + '\u25a0',\r\n        '\u25a0' + '| |' . center(w - 2, ' ') + '\u25a0']\r\n    view = list(map(' ' . join, zip(* map(building, dimensions))))\r\n    view . append('/' * len(view[0]))\r\n    for i in range(9, len(view[0]), 10):\r\n    for n in range(1, 5):\r\n    view[- n] = view[- n][: i] + ['#', '|'][n < 4] + view[- n][i + 1:]\r\n    return '\\n' . join(view)\r\n",
  "63431f9b9943dd4cee787da5": "def series(x): return x\r\n\r\n\r\ndef parall(x): return 1 / x if x else float('inf')\r\n\r\n\r\ndef rec(circuit):\r\n    if not isinstance(circuit, list):\r\n    return circuit\r\n    test, * circuit = circuit\r\n    if not circuit:\r\n    return not test and float('inf')\r\n    func = test and series or parall\r\n    return func(sum(func(rec(x)) for x in circuit))\r\n\r\n    def calculate_resistance(circuit):\r\n    result = rec(circuit)\r\n    if result == 0:\r\n    raise Exception(\"Short Circuit!\")\r\n    if result == float('inf'):\r\n    raise Exception(\"Broken Circuit!\")\r\n    return result\r\n",
  "634420abae4b81004afefca7": "def is_evil(number):\r\n    count = 0\r\n    while number:\r\n    number &= number - 1\r\n    count += 1\r\n    return count % 2 == 0\r\n    def get_evil(n):\r\n    t = 2 * (n - 1)\r\n    return t if is_evil(t) else t + 1\r\n",
  "6339de328a3b8f0016cc5b8d": "def magic_plant(p_feild, split, n):\r\n    t = p_feild . split('\\n')\r\n    return '\\n' . join(c * (split * * n) for c in t[: len(t) - n])\r\n",
  "63348506df3ef80052edf587": "from typing import Generator\nfrom fractions import Fraction\nimport math\nimport itertools\n\n\ndef generate_continued_fraction(b) - > Generator[int, None, None]:\n    a, c = 0, 1\n    while True:\n    if not c:\n        yield from itertools . repeat(0)\n    i = (math . isqrt(b) + a) / / c\n    yield i\n    a, c = c * i - a, (b - a * a) / / c + i * (2 * a - c * i)\n\n    def generate_modular_roots(n) - > Generator[int, None, None]:\n    p, q = 1, 0\n    z = math . isqrt(n - 1)\n    for a in generate_continued_fraction(n):\n    p, q = (a * p + q) % n, p\n    if p * p % n < 2 * z and z < p < n - z:\n        yield p % n\n",
  "633bbba75882f6004f9dae4c": "def count_loop_iterations(arr):\r\n    res = []\r\n    acc = 1\r\n    for n, b in arr:\r\n    n = n + 2 if b else n + 1\r\n    res . append(acc * n)\r\n    acc *= n - 1\r\n    return res\r\n",
  "632abe6080604200319b7818": "def primes(n):\r\n    sieve = n / / 2 * [True]\r\n    for i in range(3, int(n * * 0.5) + 1, 2):\r\n    if sieve[i / / 2]:\r\n    sieve[i * i / / 2:: i] = [False] * ((n - i * i - 1) / / (2 * i) + 1)\r\n    return [2] + [2 * i + 1 for i in range(1, n / / 2) if sieve[i]]\r\n\r\n    from string import ascii_uppercase as u, ascii_lowercase as l\r\n    def to_base(n, b, w=u + l):\r\n    return w[n] if n < b else to_base(n / / b, b). lstrip(w[0]) + w[n % b]\r\n\r\n    def transform(nums, exponents):\r\n    from math import prod\r\n    return prod(p * * i for p, i in zip(nums, exponents))\r\n\r\n    def solver(k, n, base, seq=primes(10 * * 4)):\r\n    assert k + n - 1 <= len(seq)\r\n    chain, exp = seq[k - 1: k + n - 1], range(1, n + 1)\r\n    return tuple(to_base(transform(chain, es), base) for es in (exp, exp[:: - 1]))\r\n",
  "633874ed198a4c00286aa39d": "def solution(frank, sam, tom):\r\n    count = 0\r\n    for i in range(4):\r\n    for j in range(4):\r\n    if frank[j] > sam[i] and frank[j] > tom[i]:\r\n    count += 1\r\n    frank[j] = 0\r\n    break\r\n    return count >= 2\r\n",
  "63306fdffa185d004a987b8e": "def light_switch(n, lights):\r\n    result = {0}\r\n    for s in lights:\r\n    result |= {x ^ sum(1 << x for x in s) for x in result}\r\n    return (1 << n) - 1 in result\r\n",
  "63304cd2c68f640016b5d162": "from gmpy2 import gcdext\r\n\r\n\r\ndef gcd_coeff(a, b):\r\n    _, x, y = gcdext(a, b)\r\n    return int(x), int(y)\r\n",
  "6329d94bf18e5d0e56bfca77": "def lru(n, reference_list):\r\n    cache, time = [- 1] * n, [- 1] * n\r\n    for i, x in enumerate(reference_list):\r\n    idx = cache . index(x) if x in cache else time . index(min(time))\r\n    cache[idx] = x\r\n    time[idx] = i\r\n    return cache\r\n",
  "62f7ca8a3afaff005669625a": "def pyramid(h): return (8 * h * h - 4 * h + 1, 8 * h * * 3 - 2 * h)\n",
  "6326533f8b7445002e856ca3": "def triangulate(A, dA, B, dB, C, dC):\r\n    a11, a21 = 2 * (B[0] - A[0]), 2 * (C[0] - A[0])\r\n    a12, a22 = 2 * (B[1] - A[1]), 2 * (C[1] - A[1])\r\n    b1, b2 = dA - dB - A[0] * * 2 - A[1] * * 2 + B[0] * * 2 + B[1] * * 2, dA - dC - A[0] * * 2 - A[1] * * 2 + C[0] * * 2 + C[1] * * 2\r\n    dt = a11 * a22 - a12 * a21\r\n    x, y = (b1 * a22 - a12 * b2) / / dt, (a11 * b2 - b1 * a21) / / dt\r\n    return (x, y)\r\n",
  "62cc5882ea688d00428ad2b0": "def bunch(n):\r\n    s, w = n . bit_length(), n . bit_count()\r\n    base = (1 << w) - 1\r\n    chunks = (base << i for i in range(s - w + 1))\r\n    return min(chunks, key=lambda v: ((n ^ v). bit_count(), v))\r\n",
  "6324786fcc1a9700260a2147": "from itertools import accumulate\r\nH = [0, * accumulate(range(1, 301), lambda a, n: a * n * * n % 1000000007)]\r\n\r\nhyperfact = H . __getitem__\r\n",
  "632408defa1507004aa4f2b5": "class Class:\n    value = 1\n    def get_number():\n    result = Class . value\n    Class . value *= 2\n    return result\n",
  "631f0c3a0b9cb0de6ded0529": "from functools import reduce\r\n\r\n\r\ndef evaluate(equation):\r\n    try:\r\n    return reduce(lambda a, b: a * (b + 2) + a / / b, map(int, equation . split(' @ ')))\r\n    except ZeroDivisionError:\r\n    pass\r\n",
  "6319f8370b9cb0ffc2ecd58d": "# Just having some fun with the new match/case :D\ndef level_recovery(solution):\n    D, boxes, i, j = {}, set(), 0, 0\n    for c in solution:\n    D[(i, j)] = ' '\n    match c:\n    case 'l' | 'L': k, l = 0, - 1\n    case 'r' | 'R': k, l = 0, 1\n    case 'u' | 'U': k, l = - 1, 0\n    case 'd' | 'D': k, l = 1, 0\n    if c . isupper():\n    if (i + k, j + l) not in D:\n    boxes . add((i + k, j + l))\n    D[(i + k, j + l)] = ' '\n    D[(i + 2 * k, j + 2 * l)] = '.'\n    i, j = i + k, j + l\n    for i, j in boxes:\n    match D[(i, j)]:\n    case '.': D[(i, j)] = '*'\n    case ' ': D[(i, j)] = '$'\n    match D[(0, 0)]:\n    case '.': D[(0, 0)] = '+'\n    case ' ': D[(0, 0)] = '@'\n    Y, X = zip(* D)\n    x, y = min(X) - 1, min(Y) - 1\n    H, W = max(Y) - y + 2, max(X) - x + 2\n    res = [[' '] * W for _ in range(H)]\n    for i in range(H):\n    for j in range(W):\n    if (i + y, j + x) in D:\n    res[i][j] = D[(i + y, j + x)]\n    elif any((k + y, l + x) in D for k in range(i - 1, i + 2) for l in range(j - 1, j + 2)):\n    res[i][j] = '#'\n    return '\\n' . join(map(str . rstrip, map('' . join, res)))\n",
  "631373e489d71c005d880f18": "def area_value(n):\n    res, i, j = 0, 1, 2\n    while j * j <= n:\n    if n % j == 0:\n    res += n / / i * j - n / / j * i\n    i = j\n    j += 1\n    return 0 if n < 2 else res + ((n / / i) * * 2 - i * i) / / 2\n",
  "6319dba6d6e2160015a842ed": "def count_photos(road):\n    photos = 0\n    left = 0\n    dot_founds = 0\n    for item in road:\n    if item == \">\":\n    left += 1\n    elif item == \".\":\n    photos += left\n    dot_founds += 1\n    elif item == \"<\":\n    photos += dot_founds\n    return photos\n",
  "57f2b753e3b78621da0020e8": "import re\r\ntoken = re . compile(r'([+-]?)\\s*(\\d*)\\s*([a-zA-Z\\(\\)])')\r\n\r\n\r\ndef substitute(formula, substitutes):\r\n    res = formula\r\n    for var, sub in substitutes:\r\n    res = res . replace(var, '({})' . format(sub))\r\n    return res if res == formula else substitute(res, substitutes)\r\n\r\n    def reduce(tokens):\r\n    res = dict()\r\n    for sign, num, var in tokens:\r\n    if var == ')':\r\n    return res\r\n    coef = int(sign + (num or '1'))\r\n    if var == '(':\r\n    for k, v in reduce(tokens). items():\r\n    res[k] = res . get(k, 0) + coef * v\r\n    else:\r\n    res[var] = res . get(var, 0) + coef\r\n    return res\r\n    def simplify(examples, formula):\r\n    substitutes = [(k . strip(), v)\r\n                   for v, k in map(lambda x: x . split('='), examples)]\r\n    subbed = substitute(formula, substitutes)\r\n    reduced = reduce(iter(token . findall(subbed)))\r\n    return '' . join(map('{0[1]}{0[0]}' . format, reduced . items()))\r\n",
  "63178f6f358563cdbe128886": "from typing import Generator\nfrom math import isqrt\n\n\ndef generate_continued_fraction(n) - > Generator[int, None, None]:\n    a0 = isqrt(n)\n    a, b, c = a0, 0, 1\n    yield a0\n    while True:\n    b = c * a - b\n    c = (n - b * b) / / c\n    if not c:\n        break\n    a = (a0 + b) / / c\n    yield a\n    while True:\n    yield 0\n",
  "6311b2ce73f648002577f04a": "from collections import deque\r\n\r\n\r\ndef prepare_deck(drawn_cards):\r\n    deck = deque()\r\n    for c in reversed(drawn_cards):\r\n    deck . rotate(1)\r\n    deck . appendleft(c)\r\n    return list(deck)\r\n",
  "630647be37f67000363dff04": "def draw(deck):\r\n    order = []\r\n    while deck:\r\n    order . append(deck . pop(0))\r\n    if deck:\r\n    deck . append(deck . pop(0))\r\n    return order\r\n",
  "62b76a4f211432636c05d0a9": "DECK = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\r\n        12, 13, 14, 15, 16, 17, 18, 19, 20, 21]\r\n\r\n\r\ndef guess_the_card(audience):\r\n    deck = DECK\r\n    for _ in range(3):\r\n    deal = [deck[:: 3], deck[1:: 3], deck[2:: 3]]\r\n    deal . insert(1, deal . pop(audience . get_input(deal)))\r\n    deck = sum(deal, [])\r\n    return deck[10]\r\n",
  "631082840289bf000e95a334": "def max_int_chain(n):\r\n    return - 1 if n < 5 else (n / / 2) * (n - n / / 2) if n % 2 else (n / / 2 - 1) * (n / / 2 + 1)\r\n",
  "630e55d6c8e178000e1badfc": "def degrees_of_lock(initial, first, second, third):\r\n    return 1080 + ((initial - first) % 40 + (second - first) % 40 + (second - third) % 40) * 9\r\n",
  "630649f46a30e8004b01b3a3": "def construct_graph(points):\r\n    if not points:\r\n    return [['+']]\r\n    min_x = min(0, min(point['x'] for point in points))\r\n    min_y = min(0, min(point['y'] for point in points))\r\n    max_x = max(0, max(point['x'] for point in points))\r\n    max_y = max(0, max(point['y'] for point in points))\r\n    graph = [[' '] * (max_x - min_x + 1) for _ in range(min_y, max_y + 1)]\r\n    def set(x, y, c): graph[max_y - y][x - min_x] = c\r\n    for x in range(min_x, max_x + 1):\r\n        set(x, 0, '-')\r\n    for y in range(min_y, max_y + 1):\r\n        set(0, y, '|')\r\n    set(0, 0, '+')\r\n    for point in points:\r\n        set(point['x'], point['y'], '*')\r\n    return graph\r\n",
  "589816a7d07028ac5c000016": "def new_year_celebrations(take_off_time, minutes):\r\n    h, m = map(int, take_off_time . split(':'))\r\n    res, m = 0, 60 * h + m or 1440\r\n    for x in map(int . __sub__, minutes, [0] + minutes):\r\n    res += m <= 1440 and m + x >= 1440\r\n    m += x - 60\r\n    return res + (m <= 1440)\r\n",
  "63022799acfb8d00285b4ea0": "from typing import Tuple\r\nfrom math import gcd\r\nfrom gmpy2 import is_prime\r\n\r\n\r\ndef four_squares(n: int) - > Tuple[int, int, int, int]:\r\n    print(n)\r\n    if n == 0:\r\n        return 0, 0, 0, 0\r\n    twos = 1\r\n    while n % 4 == 0:\r\n        n / /= 4\r\n        twos *= 2\r\n    nums = []\r\n    if n % 8 == 7:\r\n    sqrtn = isqrt(n)\r\n    while (n - sqrtn * * 2) % 8 in [0, 4, 7]:\r\n        sqrtn -= 1\r\n    nums . append(sqrtn)\r\n    n -= sqrtn * * 2\r\n    else:\r\n    nums . append(0)\r\n    x = isqrt(n)\r\n    while 1:\r\n    k = n - x * * 2\r\n    k2 = k / / 2 if k % 2 == 0 else k\r\n    if k2 == 1 or (k2 % 4 == 1 and is_prime(k2)):\r\n        break\r\n    # print(x, k, k2)\r\n    x -= 1\r\n    k = n - x * * 2\r\n    nums . append(x)\r\n    k2 = k / / 2 if k % 2 == 0 else k\r\n    decomp = compose_2sq(prime_2sq(k2), [1, 1] if k % 2 == 0 else [1, 0])\r\n    nums += decomp\r\n    return tuple(num * twos for num in nums)\r\n\r\n    def prime_2sq(p):\r\n    if p == 1:\r\n        return (1, 0)\r\n    if p == 2:\r\n        return (1, 1)\r\n    for q in range(2, p):\r\n    if pow(q, (p - 1) / / 2, p) == p - 1:\r\n        break\r\n    x = pow(q, (p - 1) / / 4, p)\r\n    v = p, x\r\n    rems = []\r\n    sqrtp = isqrt(p)\r\n    while len(rems) < 2:\r\n    if v[1] <= sqrtp:\r\n        rems . append(v[1])\r\n    v = v[1], v[0] % v[1]\r\n    return rems[: 2]\r\n    def compose_2sq(x, y):\r\n    a, b = x\r\n    c, d = y\r\n    return [a * c + b * d, abs(a * d - b * c)]\r\n\r\n    def isqrt(n):\r\n    x0 = n / / 2\r\n    if x0:\r\n    x1 = (x0 + n / / x0) / / 2\r\n    while x1 < x0:\r\n    x0 = x1\r\n    x1 = (x0 + n / / x0) / / 2\r\n    return x0\r\n    return n\r\n",
  "630006e1b4e54c7a7e943679": "def sierpinski_carpet_string(n):\r\n    m = [\"\u2588\u2588\"]\r\n    for i in range(n):\r\n    m = [x + x + x for x in m] + \\\r\n        [x + x . replace(\"\u2588\", \" \") + x for x in m] + [x + x + x for x in m]\r\n    return \"\\n\" . join(m)\r\n",
  "62fd5b557d267aa2d746bc19": "def matching(arg):\r\n    match arg:\r\n    case[]: return 0\r\n    case[x]: return int(x)\r\n    case[a, * _, 0 | '0']: return None\r\n    case[a, * _, b]: return int(a) / int(b)\r\n",
  "62f23d84eb2533004be50c0d": "def clock(n, xs):\r\n    ks, vs, ptr = [- 1] * n, [0] * n, 0\r\n    def inc():\r\n    nonlocal ptr\r\n    ptr = (ptr + 1) % n\r\n    for x in xs:\r\n    if x in ks:\r\n    vs[ks . index(x)] = 1\r\n    else:\r\n    while vs[ptr]:\r\n    vs[ptr] -= 1\r\n    inc()\r\n    ks[ptr] = x\r\n    inc()\r\n    return ks\r\n",
  "62fa7b95eb6d08fa9468b384": "def mandelbrot_string(x, y, width, height, stepsize, max_iter):\r\n    def mandelbrot_pixel(c):\r\n    z = 0\r\n    for n in range(max_iter + 1):\r\n    z = z * z + c\r\n    if not abs(z) < 2:\r\n        break\r\n    return n\r\n    return '\\n' . join(\r\n        '' . join(\r\n            ' \u2591\u2592\u2593\u2588' [4 * mandelbrot_pixel(\r\n                complex(x + dx * stepsize, y - 2 * dy * stepsize)\r\n            ) / / max_iter]\r\n            for dx in range(- width, width + 1)\r\n        ) for dy in range(- height, height + 1))\r\n",
  "62f8d0ac2b7cd50029dd834c": "def f(s): return s[- 1] > \"Z\" and - ~ f(s[: - 1])\n",
  "62f96f01d67d0a0014f365cf": "def ball_test(s, r):\r\n    if len(r) <= s:\r\n    return True\r\n    elif s <= 0 and r:\r\n    return False\r\n    cracks = r[: s]. count('x')\r\n    return ball_test(s - 1 - cracks, r[s:])\r\n",
  "5e320fe3358578001e04ad55": "is_check = lambda g, n = '(.{7}|.{11}|.{18}(|..))', r = '((.{9} )*.{9}| *)', b = '((.{8} )*.{8}|(.{10} )*.{10})': bool(__import__(\n    're'). search(f\"\u2654 { n } \u265e|\u265e { n } \u2654|\u2654 { r } [\u265b\u265c]|[\u265b\u265c] { r } \u2654|[\u265b\u265d] { b } \u2654|\u2654 { b } [\u265b\u265d]|\u265f.{{ 8}} (|..)\u2654\", '||' . join(map('' . join, g))))\n",
  "5c1d796370fee68b1e000611": "def loopover(mixed, solved):\r\n    t = {c: (i, j) for (i, row) in enumerate(solved)\r\n         for (j, c) in enumerate(row)}\r\n    b = {(i, j): t[c] for (i, row) in enumerate(mixed)\r\n         for j, c in enumerate(row)}\r\n    unsolved = {k for k, v in b . items() if k not in (\r\n        (0, 0), (0, 1)) and k != v}\r\n    sol = []\r\n\r\n    while unsolved:\r\n    i, j = next(iter(unsolved)) if b[0, 0] in ((0, 0), (0, 1)) else b[0, 0]\r\n    if i == 0:\r\n    sol += [f\"D { j } \", * j * [\"L1\"], \"L0\", \"U0\",\r\n            \"R0\", \"D0\", * j * [\"R1\"], f\"U { j } \"]\r\n    else:\r\n    sol += [* j * [f\"L { i } \"], \"L0\", * i * [\"U0\"],\r\n            \"R0\", * i * [\"D0\"], * j * [f\"R { i } \"]]\r\n    b[0, 0], b[0, 1], b[i, j] = b[0, 1], b[i, j], b[0, 0]\r\n\r\n    if b[i, j] == (i, j):\r\n    unsolved . remove((i, j))\r\n\r\n    if b[0, 0] != (0, 0) and len(mixed) % 2 == 0:\r\n    sol += [* len(mixed) / / 2 * [\"D0\", \"L0\", \"D0\", \"R0\"], \"D0\"]\r\n    elif b[0, 0] != (0, 0) and len(mixed[0]) % 2 == 0:\r\n    sol += [* len(mixed[0]) / / 2 * [\"R0\", \"U0\", \"R0\", \"D0\"], \"U0\", \"R0\", \"D0\"]\r\n    elif b[0, 0] != (0, 0):\r\n    return None\r\n    return sol\r\n",
  "57ff9d3b8f7dda23130015fa": "from itertools import combinations\r\n\r\n\r\ndef solve_mine(mapStr, n): return MineSweeper(mapStr, n). solve()\r\n\r\n\r\nclass MineSweeper (object):\r\n\r\n    IS_DEBUG = False\r\n    around = [(dx, dy) for dx in range(- 1, 2)\r\n              for dy in range(- 1, 2) if (dx, dy) != (0, 0)]\r\n\r\n    def __init__(self, mapStr, nMines):\r\n    lines = mapStr . split('\\n')\r\n    mapDct, unknowns, posToWorkOn = {}, set(), set()\r\n    for x, line in enumerate(lines):\r\n    for y, c in enumerate(line . split(' ')):\r\n    mapDct[(x, y)] = c\r\n    if c == '?':\r\n        unknowns . add((x, y))\r\n    else:\r\n        posToWorkOn . add((x, y))\r\n\r\n    self . map = mapDct\r\n    self . unknowns = unknowns\r\n    self . posToWorkOn = posToWorkOn\r\n    self . flagged = set()\r\n    self . nMines = nMines\r\n    self . lX = len(lines)\r\n    self . lY = len(lines[0]. split(' '))\r\n\r\n    def __str__(self): return '\\n' . join(' ' . join(\r\n        self . map[(x, y)] for y in range(self . lY)) for x in range(self . lX))\r\n\r\n    def getValAt(self, pos): return int(self . map[pos])\r\n\r\n    def getneighbors(self, pos): return {\r\n        (pos[0] + dx, pos[1] + dy) for dx, dy in self . around}\r\n\r\n    def printDebug(self): print(\" \\n------------\\n{}\\nRemaining mines: {}\" . format(\r\n        self, self . nMines - len(self . flagged))) if self . IS_DEBUG else None\r\n\r\n    def lookaroundThisPos(self, pos):\r\n    neighbors = self . getneighbors(pos)\r\n    return {'?': neighbors & self . unknowns,\r\n            'x': neighbors & self . flagged}\r\n\r\n    \"\"\" MAIN FUNCTION \"\"\"\r\n\r\n    def solve(self):\r\n\r\n    self . printDebug()\r\n    while True:\r\n    while True:\r\n        # Archive to check against modifications\r\n    archivePosToWorkOn = self . posToWorkOn . copy()\r\n    self . openAndFlag_OnTheFly()\r\n    self . printDebug()  # Open and flag in the map while simple matches can be found\r\n    self . complexSearch_OpenAndFlag()\r\n    # Use more complex algorithm to find mines or unknown positions that are surely openable\r\n    self . printDebug()\r\n    if archivePosToWorkOn == self . posToWorkOn:\r\n        break  # Repeat these two \"simple\" steps until its not possible to go further in the resolution\r\n    # Use witted combinatory approach to go further (if possible)\r\n    self . complexSearch_CombineApproach()\r\n    if archivePosToWorkOn == self . posToWorkOn:\r\n    break\r\n    # Repeat these to \"simple\" steps until its not possible to go further in the resolution\r\n    self . printDebug()\r\n    # If no more mines remaining but some unknown cases still there\r\n    if len(self . flagged) == self . nMines:\r\n    self . openThosePos(self . unknowns . copy())\r\n\r\n    # If all the remaining \"?\" are mines, flag them\r\n    elif len(self . flagged) + len(self . unknowns) == self . nMines:\r\n    self . flagThosePos(self . unknowns . copy())\r\n\r\n    self . printDebug()\r\n\r\n    return '?' if self . unknowns else str(self)\r\n\r\n    def openAndFlag_OnTheFly(self):\r\n    while True:\r\n    openables, workDonePos = set(), set()\r\n    for pos in self . posToWorkOn:  # Run through all the positions that might neighbors to open\r\n    openables, workDonePos = [baseSet | newPart for baseSet, newPart in zip(\r\n        (openables, workDonePos), self . openablePosaround_FlagOnTheFly(pos))]\r\n\r\n    # After the exit of the loop, modification of self.posToWorkOn is possible, so:\r\n    self . openThosePos(openables)\r\n    # remove the pos with full number of mines from the working set (to fasten the executions)\r\n    self . posToWorkOn -= workDonePos\r\n    if not openables and not workDonePos:\r\n        break\r\n\r\n    def openablePosaround_FlagOnTheFly(self, pos):\r\n    around = self . lookaroundThisPos(pos)\r\n\r\n    # If all the unknomn cases can be flagged (or if they are already!)...\r\n    if self . getValAt(pos) == len(around['?']) + len(around['x']):\r\n    self . flagThosePos(around['?'])  # flag them (if not already done)\r\n    # return the current position to remove it from self.posToWorkOn (\"We're done with you...\" / This behaviour will identify the \"done\" positions generated by the \"witted approach\")\r\n    return (set(), {pos})\r\n    return (around['?'], {pos}) if self . getValAt(pos) == len(around['x']) else (set(), set())\r\n\r\n    def openThosePos(self, posToOpen):\r\n    for pos in posToOpen:\r\n    self . map[pos] = str(open(* pos))  # Open squares and update the map\r\n    if self . map[pos] != '0':\r\n        self . posToWorkOn . add(pos)  # Update slef.posToWorkOn if needed\r\n    self . unknowns -= posToOpen  # Remove opened squares from the unknown positions\r\n    def flagThosePos(self, posToFlag):\r\n    for pos in posToFlag:\r\n        self . map[pos] = 'x'  # Flag mines\r\n    self . unknowns -= posToFlag  # Remove flagged squares from the unknown positions\r\n    self . flagged |= posToFlag  # update the set of flagged positions\r\n    def complexSearch_OpenAndFlag(self):\r\n    markables, openables = set(), set()\r\n    for pos in self . posToWorkOn:\r\n    newMark, newOpen = self . intelligencia_OpenAndFlag(pos)\r\n    markables |= newMark\r\n    openables |= newOpen\r\n    self . flagThosePos(markables)\r\n    self . openThosePos(openables)\r\n\r\n    def intelligencia_OpenAndFlag(self, pos):\r\n    around = self . lookaroundThisPos(pos)  # Cases around the current position\r\n    # Prepare an array with the number of remaining mines to find for the current position and the neighbor that will be worked on later\r\n    rMines = [self . getValAt(pos) - len(around['x']), 0]\r\n    # Search for neighbors (only usefull ones, meaning: self.getValAt(posneighbor) is a number and this neighbor still miss some mines)\r\n    neighToWorkOn = self . getneighbors(pos) & self . posToWorkOn\r\n    # markables: position that will be flagged / openables: positions that will be open... of course... / fullUnion: stroe all the squares\r\n    markables, openables = set(), set()\r\n    knownParts = []  # knownParts: list of the intersections of the '?' cases of all the neighbors of the current pos and the current neighbor\r\n    for pos2 in neighToWorkOn:\r\n        # Cases around the neighbor that is worked on right now\r\n    around2 = self . lookaroundThisPos(pos2)\r\n    # Update the number of mines still to find for the current neighbor\r\n    rMines[1] = self . getValAt(pos2) - len(around2['x'])\r\n    # Define the '?' that are owned only by the current \"pos\", and only by the current neighbor (\"pos2\")\r\n    onlys = [around['?'] - around2['?'], around2['?'] - around['?']]\r\n    # Define the minimum (yes \"minimum\", even if \"max\" is used!) number of mines that have to be in the '?' that are commun to \"pos\" and it's current neighbor pos2\"\r\n    mInter = max(n - len(only) for n, only in zip(rMines, onlys))\r\n    if mInter <= 0 or 1 not in rMines:\r\n        continue  # If these conditions are met, there is nothing \"extrapolable\" at the current position, so continue the iteration\r\n    currentIntersect = around['?'] & around2['?']\r\n    if currentIntersect:\r\n        # Store (if it exists) the current intersection of '?' cases for further checks\r\n        knownParts . append(currentIntersect)\r\n    for i in range(2):  # Work on the two current LOCATIONS (pos, pos2)\r\n    if len(onlys[i]) == rMines[i] - mInter:\r\n        # The number of '?' cases that are only around the treated LOCATION matches the number mines of this LOCATION that are out of the interesction \"pos & pos2\". So, those cases will be flagged\r\n        markables |= onlys[i]\r\n    elif mInter == rMines[i]:\r\n        openables |= onlys[i]  # If the number of mines surely present in the intersection \"pos & pos2\" matches the number of mines still to found arorund the treated LOCATION, all the cases out of the intersection for the current LOCATION can be opened\r\n    # Final check on the different intersections parts:\r\n    # Union of all the intersections for the current position and its differente neighbors\r\n    fullIntersection = {\r\n        posInter for posSet in knownParts for posInter in posSet}\r\n    if len(knownParts) == rMines[0] and sum(len(s) for s in knownParts) == len(fullIntersection):\r\n        # If some '?' cases are still unchecked while we can be sure that all the remaining mines are elsewhere (even without knowing their exact location), the leftovers can be opened\r\n    openables |= around['?'] - fullIntersection\r\n    return markables, openables\r\n\r\n    def complexSearch_CombineApproach(self):\r\n        # number of remaining mines to find\r\n    rMines = self . nMines - len(self . flagged)\r\n    matchPos = []\r\n\r\n    if rMines != 0:\r\n\r\n     # '?' that are joined to the current posToWorkOn...\r\n    borderUnknowns = {\r\n        pos2 for pos in self . posToWorkOn for pos2 in self . lookaroundThisPos(pos)['?']}\r\n    # ...then add the \"next layer\" of \"?\", ot be able to make more guesses on the remaining farther squares\r\n    borderUnknowns |= {\r\n        pos2 for pos in borderUnknowns for pos2 in self . lookaroundThisPos(pos)['?']}\r\n    for n in range(rMines if not (self . unknowns - borderUnknowns) else 1, min(rMines, len(borderUnknowns) - 1) + 1):\r\n    for posMines in combinations(borderUnknowns, n):\r\n    setPosMines = set(posMines)\r\n    for pos in self . posToWorkOn:\r\n    around = self . lookaroundThisPos(pos)\r\n    if self . getValAt(pos) != len(around['x']) + len(around['?'] & setPosMines):\r\n        break\r\n    else:\r\n        # if the for loop execute until its end, the current position is valid. Archive it.\r\n    matchPos . append(setPosMines)\r\n    # search for '?' that are never marked in any of the valid combinations\r\n    untouched = borderUnknowns - {flagPos for s in matchPos for flagPos in s}\r\n    if len(matchPos) == 1:\r\n        # Flag the found mines if only 1 match\r\n        self . flagThosePos(matchPos[0])\r\n    self . openThosePos(untouched)  # open the untouched '?' (free of mines!!)\r\n",
  "52dc4688eca89d0f820004c6": "def whitespace(code, inp=''):\r\n    code = '' . join(['STN' [' \\t\\n' . index(c)]\r\n                     for c in code if c in ' \\t\\n'])\r\n    output, stack, heap, calls, pos, run, search, inp = [\r\n    ], [], {}, [], [0], [True], [None], list(inp)\r\n\r\n    def set_(t, i, val):\r\n    t[i] = val\r\n    # Stack operations\r\n    def pop(n=0): return (assert_(n < len(stack)),\r\n                          stack[n], set_(stack, slice(n, n + 1), ()))[1]\r\n\r\n    def get(n): return (assert_(n >= 0 and n < len(stack)), stack[n])[1]\r\n    def push(n): return stack . insert(0, n)\r\n\r\n    # Parsing utilities\r\n    def accept(tokens, action=None):\r\n    for token in tokens . split(','):\r\n    if code[pos[0]: pos[0] + len(token)] == token:\r\n    pos[0] += len(token)\r\n    if action:\r\n    p = 0\r\n    if token in ('SS', 'STS', 'STN'):\r\n    p = number()\r\n    elif token in ('NST', 'NSN', 'NTS', 'NTT', 'NSS'):\r\n    p = label()\r\n    ((not search[0]) or token == 'NSS') and action(p)\r\n    return token\r\n    def assert_(* args):\r\n    if len(args) and args[0]:\r\n        return args[0]\r\n    raise Exception('error')\r\n\r\n    def number():\r\n    if accept('N'):\r\n        raise Exception('No digits for number')\r\n    n = '+0' if accept('S,T') == 'S' else '-0'\r\n    while not accept('N'):\r\n    n += str(int(accept('S,T') != 'S'))\r\n    return int(n, 2)\r\n\r\n    def label(l=''):\r\n    while not accept('N'):\r\n    l += accept('S,T') or ''\r\n    return l + '1'\r\n    instructions = {'SS': lambda n: push(n),\r\n                    'STS': lambda n: push(get(n)),\r\n                    'STN': lambda n: set_(stack, slice(1, len(stack) if n < 0 else 1 + n), ()),\r\n                    'SNS': lambda _: push(get(0)),\r\n                    'SNT': lambda _: set_(stack, slice(1, 1), [pop()]),\r\n                    'SNN': lambda _: pop(),\r\n                    'TSSS': lambda _: push(pop(1) + pop()),\r\n                    'TSST': lambda _: push(pop(1) - pop()),\r\n                    'TSSN': lambda _: push(pop(1) * pop()),\r\n                    'TSTS': lambda _: push(pop(1) / assert_(pop())),\r\n                    'TSTT': lambda _: (lambda d: push((pop() % d + d) % d))(assert_(pop())),\r\n                    'TTS': lambda _: set_(heap, pop(1), pop()),\r\n                    'TTT': lambda _: (assert_(stack[0] in heap), push(heap[pop()])),\r\n                    'TNSS': lambda _: output . append(chr(pop())),\r\n                    'TNST': lambda _: output . append(str(pop())),\r\n                    'TNTS': lambda _: (set_(heap, pop(), ord(assert_(inp)[0])), inp . pop(0)),\r\n                    'TNTT': lambda _: (lambda n: (set_(heap, pop(), int(assert_('' . join(inp[: n])))), set_(inp, slice(0, n + 1), ())))(inp . index('\\n') if '\\n' in inp else len(inp)),\r\n                    'NST': lambda l: (calls . append(pos[0]), set_(pos, 0, heap[l]) if heap . get(l) else set_(search, 0, l)),\r\n                    'NSN': lambda l: set_(pos, 0, heap[l]) if heap . get(l) else set_(search, 0, l),\r\n                    'NTS': lambda l: (not pop()) and (set_(pos, 0, heap[l]) if heap . get(l) else set_(search, 0, l)),\r\n                    'NTT': lambda l: pop() < 0 and (set_(pos, 0, heap[l]) if heap . get(l) else set_(search, 0, l)),\r\n                    'NTN': lambda _: set_(pos, 0, assert_(calls). pop()),\r\n                    'NNN': lambda _: set_(run, 0, False),\r\n                    'NSS': lambda l: (assert_((not heap . get(l)) or heap[l] == pos[0]), set_(heap, l, pos[0]), search[0] == l and set_(search, 0, 0)),\r\n                    }\r\n\r\n    while run[0]:\r\n    assert_(pos[0] < len(code))\r\n    any(accept(* instruction)\r\n        for instruction in instructions . items()) or assert_()\r\n\r\n    return '' . join(output)\r\n",
  "62eedcfc729041000ea082c1": "def left_right(n): return 'CLR' [int((8 * n - 4) * * .5 % 2 / / - 1)]\n",
  "62d34faad32b8c002a17d6d9": "def fifo(n, reference_list):\n    memory = [- 1] * n\n    c = 0\n    for ref in reference_list:\n    if ref in memory:\n    continue\n    memory[c] = ref\n    c = (c + 1) % n\n    return memory\n",
  "62e068c14129156a2e0df46a": "from functools import reduce\r\nfrom itertools import combinations\r\n\r\n\r\ndef _add(v0, v1):\r\n    return v0[0] + v1[0], v0[1] + v1[1]\r\n\r\n    def _mul(v, k):\r\n    return v[0] * k, v[1] * k\r\n    def _blindfold_chess(moves):\r\n    mcs = {k: [reduce(_add, c) for c in combinations(moves, k)]\r\n           for k in range(1, len(moves) + 1)}\r\n    i = 0\r\n    while mcs:\r\n    i += 1\r\n    for j, ms in reversed(mcs . items()):\r\n    if i % j == 0:\r\n    yield _mul(ms . pop(), i / / j)\r\n    if not ms:\r\n    del mcs[j]\r\n    break\r\n    else:\r\n    yield (0, 0)\r\n\r\n    def blindfold_chess(moves):\r\n    return list(_blindfold_chess(moves))\r\n",
  "62eb800ba29959001c07dfee": "# String comparison is enough, no need to convert\ndef brightest(colors):\n    return max(colors, key=lambda c: max(c[1: 3], c[3: 5], c[5:]))\n",
  "62ea53ae888e170058f00ddc": "def fibonacci_squared_sum(n): return int(\n    \"012650434056210098450676054890\" [n % 30])\n",
  "6112917ef983f2000ecbd506": "def places_around(dance_floor, row, col, empty=False):\r\n    places = []\r\n\r\n    for i in ((- 1, 0), (0, - 1), (0, 1), (1, 0)):\r\n    rel_row, rel_col = row + i[0], col + i[1]\r\n\r\n    if 0 <= rel_row < rows and 0 <= rel_col < cols and (not empty or dance_floor[rel_row][rel_col] == ' '):\r\n    places . append((rel_row, rel_col))\r\n\r\n    return places\r\n    def best_place(dance_floor):\r\n    global rows, cols\r\n    rows, cols = len(dance_floor), len(dance_floor[0])\r\n    empty_places = []\r\n\r\n    for row in enumerate(dance_floor):  # list all empty places\r\n    for col in enumerate(row[1]):\r\n    if col[1] == ' ':\r\n    empty_places . append((row[0], col[0]))\r\n\r\n    moshpit_places = set()\r\n\r\n    for row, col in empty_places:  # find 2x2 moshpits\r\n    if row < rows - 1 and col < cols - 1 and dance_floor[row][col + 1] == dance_floor[row + 1][col] == dance_floor[row + 1][col + 1] == ' ':\r\n    moshpit_places = moshpit_places . union(\r\n        {(row, col), (row, col + 1), (row + 1, col), (row + 1, col + 1)})\r\n\r\n    moshpit_checked = set()  # places that were already checked for branches\r\n    while True:  # branches of 2x2 moshpits\r\n    length = len(moshpit_places)\r\n    moshpit_unchecked = moshpit_places . difference(moshpit_checked)\r\n    moshpit_checked = moshpit_checked . union(moshpit_places)\r\n\r\n    for row, col in moshpit_unchecked:\r\n    moshpit_places = moshpit_places . union(\r\n        set(places_around(dance_floor, row, col, True)))\r\n\r\n    if length - len(moshpit_places) == 0:  # stop if no new branches were found\r\n    break\r\n    best_score = float('-inf')\r\n\r\n    for row, col in empty_places:\r\n    score = rows - row  # distance from stage\r\n    if row > 0:  # height of person in front\r\n    score *= .99 * * int(bin(ord(dance_floor[row - 1][col]))[- 5:], 2)\r\n\r\n    for rel_row, rel_col in places_around(dance_floor, row, col):  # beer\r\n    score *= 1 - dance_floor[rel_row][rel_col]. isupper() * .2\r\n    score -= 999 * ((row, col) in moshpit_places)  # moshpits\r\n    if score > best_score:  # keep track of best spot\r\n    best_score = score\r\n    best_place = (row, col)\r\n\r\n    return best_place\r\n",
  "62e41d4816d2d600367aee79": "from functools import cache\r\n\r\n\r\ndef solve(board):\r\n    moves, board = [], board . splitlines()\r\n    poss = {p: i for i, p in enumerate(\r\n        ((x, y) for x, r in enumerate(board) for y, v in enumerate(r) if v != '_'), 1)}\r\n\r\n    @ cache\r\n    def dfs(pegs):\r\n    if len(pegs) == 1:\r\n        return True\r\n    for (x, y), m in poss . items():\r\n    if (x, y) not in pegs:\r\n    for dx, dy in ((- 1, 0), (0, - 1), (1, 0), (0, 1)):\r\n    if ((x1 := x + dx), (y1 := y + dy)) in pegs and ((x2 := x + 2 * dx), (y2 := y + 2 * dy)) in pegs:\r\n    moves . append((poss[x2, y2], m))\r\n    if dfs(pegs - frozenset([(x1, y1), (x2, y2)]) | frozenset([(x, y)])):\r\n        return True\r\n    moves . pop()\r\n    return False\r\n    if dfs(frozenset((x, y) for x, y in poss if board[x][y] == 'O')):\r\n        return moves\r\n",
  "62e66bea9db63bab88f4098c": "from itertools import combinations\nfrom functools import reduce\nfrom operator import mul\n\n\ndef find_them(number_limit, primes):\n    res = 0\n    for ln in range(1, len(primes) + 1):\n    for cmb in combinations(primes, ln):\n    mlt, sgn = reduce(mul, cmb), (- 1) * * (ln + 1)\n    pw = (number_limit - 1) / / mlt\n    res += pw * (pw + 1) / / 2 * mlt * sgn\n    return res\n",
  "62e4df54323f44005c54424c": "def dist(arr):\r\n    for i in range(1, len(arr)):\r\n    if arr[- 1 - i] == arr[- 1]:\r\n    return i\r\n    return 0\r\n    def seq(n):\r\n    s = [0, 0]\r\n    for _ in range(n):\r\n    s . append(dist(s))\r\n    return s[n - 1]\r\n",
  "62975e268073fd002780cb0d": "import re\r\n\r\n\r\ndef parse_type(s):\r\n    tokens = re . findall(r'->|[()]|[A-Z][a-zA-Z0-9]*', s)\r\n    def next_token(): return tokens and tokens . pop(0) or None\r\n    def peek_token(): return tokens and tokens[0] or None\r\n    def parse_func():\r\n    ty = parse_atom()\r\n    if peek_token() == \"->\":\r\n    next_token()\r\n    ty = (ty, parse_func())\r\n    return ty\r\n    def parse_atom():\r\n    match next_token():\r\n    case \"(\":\r\n    ty = parse_func()\r\n    assert next_token() == \")\"\r\n    return ty\r\n    case ty:\r\n    return ty\r\n    return parse_func()\r\n\r\n    def parse_context(context):\r\n    res = {}\r\n    for r in context . split('\\n'):\r\n    if ':' in r:\r\n    val, s = map(str . strip, r . split(':'))\r\n    res[val] = parse_type(s)\r\n    return res\r\n    def parse_expr(expr):\r\n    tokens = re . findall(r'[()]|[a-z][a-zA-Z0-9]*', expr)\r\n    def next_token(): return tokens and tokens . pop(0) or None\r\n    def peek_token(): return tokens and tokens[0] or None\r\n    def parse_app():\r\n    e = parse_atom()\r\n    while peek_token() and peek_token() != ')':\r\n    e = (e, parse_atom())\r\n    return e\r\n    def parse_atom():\r\n    match next_token():\r\n    case '(':\r\n    e = parse_app()\r\n    assert next_token() == ')'\r\n    return e\r\n    case e:\r\n    return e\r\n    return parse_app()\r\n\r\n    def infer_type(context, expression):\r\n    ctx = parse_context(context)\r\n\r\n    def infer(expr):\r\n    match expr:\r\n    case(a, b):\r\n    ta, tb = map(infer, expr)\r\n    match ta:\r\n    case(t_arg, t_ret) if t_arg == tb:\r\n    return t_ret\r\n    case _:\r\n    raise \"Type error\"\r\n    case v:\r\n    return ctx[v]\r\n\r\n    def to_string(ty):\r\n    match ty:\r\n    case((a, b), c):\r\n    return f'( { to_string (( a , b ))} ) -> { to_string ( c )} '\r\n    case(a, b):\r\n    return f' { to_string ( a )} -> { to_string ( b )} '\r\n    case _:\r\n    return ty\r\n    return to_string(infer(parse_expr(expression)))\r\n",
  "62dcbe87f4ac96005f052962": "ALPHABET = str(). join(chr(i)\n                       for i in range(sum(range(len(str(complex))))) if chr(i). islower())\n",
  "6051151d86bab8001c83cc52": "from collections import Counter\r\n\r\n\r\ndef closest_string(list_str):\r\n    counters = [Counter(s[i] for s in list_str)\r\n                for i in range(len(list_str[0]))]\r\n    minweight = len(list_str[0]) + 1\r\n    mins = None\r\n    # backtracking with prunning:\r\n    def rec(s, weights):\r\n    nonlocal minweight, mins\r\n    if max(weights) >= minweight:\r\n    return\r\n    if len(s) == len(list_str[0]):\r\n    mins = s\r\n    minweight = max(weights)\r\n    return\r\n    for c in counters[len(s)]. keys():\r\n    rec(s + c, [\r\n        prevw + (c != list_str[i][len(s)])\r\n        for i, prevw in enumerate(weights)\r\n    ])\r\n\r\n    rec('', [0] * len(list_str))\r\n    return mins\r\n",
  "62dc0c5df4ac96003d05152c": "def score(ball: Ball) - > int:\n    res, left, right = ball . point, ball . previous, ball . next\n    while left:\n    res += left . point\n    left = left . previous\n    while right:\n    res += right . point\n    right = right . next\n    return res\n",
  "62dabb2225ea8e00293da513": "from itertools import combinations\r\n\r\n\r\ndef pass_or_fail(harmony):\r\n    for c1, c2 in zip(harmony, harmony[1:]):\r\n    for (n1, n2), (n3, n4) in combinations(zip(c1 . split(), c2 . split()), 2):\r\n    if n1 == n3 != n2 == n4:\r\n    return \"Fail\"\r\n    return \"Pass\"\r\n",
  "62d6b4990ba2a64cf62ef0c0": "def last(n): return (2 * - ~ n / / 3) * * 2 + 1 >> 1\n",
  "62d81c6361677d57d8ff86c9": "dmg = dict(zip(\"DBHW\", (0, 0.5, 0.8, 1)))\r\n\r\n\r\ndef jumping(arr):\r\n    hp = 20\r\n    for i, (p1, p2) in enumerate(zip(arr, arr[1:]), 1):\r\n    (h1, _), (h2, b) = p1 . split(), p2 . split()\r\n    hp -= max(0, int((int(h1) - int(h2) - 3.5) * (1 - dmg[b])))\r\n    if hp <= 0:\r\n    return f\"died on { i } \"\r\n    return f\"jumped to the end with { hp } remaining HP\"\r\n",
  "62d6d9e90ba2a6b6942ee6e5": "# d e f c h a n g e _ l i s t ( x ) :\n# f o r i , v i n e n u m e r a t e ( x [ : : - 1 ] ) :\n# i f i s i n s t a n c e ( v , b o o l ) :\n# x [ i ] = n o t v\n# e l i f i s i n s t a n c e ( v , s t r ) :\n# x [ i ] = v + v [ : : - 1 ]\n# e l s e :\n# x [ i ] = v * * 2\n# ' ' '\ndef change_list(x):\n    for i, v in enumerate(x[:: - 1]):\n    if isinstance(v, bool):\n    x[i] = not v\n    elif isinstance(v, str):\n    x[i] = v + v[:: - 1]\n    else:\n    x[i] = v * * 2\n    # ' ' '\n",
  "62d1d6389e2b3904b3825309": "def location(c, r=1):\r\n    while c > r:\r\n        c -= r\r\n        r += 1\r\n    return r, c\r\n",
  "62d1eb93e5994c003156b2ae": "tap_code = \"ABC,DEF,GHI|JKL,MNO,PQR|STU,VWX,YZ \"\r\ntable = {\r\n    char: ' ' . join(['.' * k, '.' * j, '.' * i])\r\n    for i, face in enumerate(tap_code . split('|'), 1)\r\n    for j, line in enumerate(face . split(','), 1)\r\n    for k, char in enumerate(line, 1)\r\n}\r\nreverse = {v: k for k, v in table . items()}\r\n\r\n\r\ndef encode(s):\r\n    return ' ' . join(map(table . get, s))\r\n\r\n    def decode(s):\r\n    return '' . join(map(reverse . get, map(' ' . join, zip(* [iter(s . split())] * 3))))\r\n",
  "5c2fd9188e358f301f5f7a7b": "def dry_ground(terrain, nDays=4):\r\n\r\n    if not terrain:\r\n    return 0, 0, 0, 0\r\n    def peak_height(mountain):\r\n    lst = [[0] * Y for _ in range(X)]\r\n\r\n    for x, row in enumerate(mountain):\r\n    for y, v in enumerate(row):\r\n    here = v == '^'\r\n    isBorderOrNoPeak = not (0 < x < X - 1 and 0 < y < Y - 1 and here)\r\n    lst[x][y] = here if isBorderOrNoPeak else here + \\\r\n        min(lst[x - 1][y], lst[x][y - 1])\r\n\r\n    for x in reversed(range(1, X - 1)):\r\n    for y in reversed(range(1, Y - 1)):\r\n    lst[x][y] = min(lst[x][y], lst[x + 1][y] + 1, lst[x][y + 1] + 1)\r\n\r\n    return lst\r\n    def flood(h):\r\n    bag = set(river)\r\n    while h and bag:\r\n    bag = {(a, b) for x, y in bag for a, b in ((x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1))\r\n           if (a, b) not in river and 0 <= a < X and 0 <= b < Y and flooded[a][b] < h}\r\n    river . update(bag)\r\n    return X * Y - len(river)\r\n\r\n    X, Y = len(terrain), len(terrain[0])\r\n    flooded = peak_height(terrain)\r\n    river = {(x, y) for x, r in enumerate(terrain)\r\n             for y, c in enumerate(r) if c == '-'}\r\n\r\n    return tuple(map(flood, range(nDays)))\r\n",
  "5e452a0a5111c7001faa2a71": "# Approach: A breadth first search (BSF) is applied to the image, where a desired cell is '*'\r\n# The BFS is itterative\r\nimport queue\r\n\r\n\r\nclass ConnectedChecker (object):\r\n\r\n    __WHITE_CELL__ = '*'\r\n    # part of the logic to find all connected shapes\r\n    @ staticmethod\r\n    def __inImage__(i, j, nR, nC):\r\n    if 0 <= i and i < nR and 0 <= j and j < nC:\r\n    return True\r\n    else:\r\n    return False\r\n    # -----end function\r\n    # part of the logic to find all connected shapes\r\n    # A desired cell is one that is a ship symbol and has not been visited yet\r\n    @ staticmethod\r\n    def __isDesiredCell__(img, hasVisited, i, j):\r\n    if img[i][j] == ConnectedChecker . __WHITE_CELL__ and not hasVisited[i][j]:\r\n    return True\r\n    else:\r\n    return False\r\n    # ---end function\r\n    # part of the logic to find all connected shapes\r\n    @ staticmethod\r\n    def __markCellAsVisited__(hasVisited, i, j):\r\n    hasVisited[i][j] = True\r\n    # end function\r\n    # Returns a list of coordinates of the shape connected at iRoot, jRoot\r\n\r\n    @ staticmethod\r\n    def __getConnectedShape__(img, hasVisited, nR, nC, iRoot, jRoot):\r\n        # di and dj specify the directions we are going to search dx=0 dy=1 means\r\n        # search north (one cell above), di=1 dj=-1 is one to right and one down\r\n    di = [0, 0, 1, - 1]\r\n    dj = [1, - 1, 0, 0]\r\n    numSearchDirs = len(di)\r\n\r\n    # i,j are lists that are going to hold the nodes conneced to the provided root (i,j)\r\n    iConnected, jConnected = [], []\r\n    q = queue . Queue()\r\n\r\n    # if provided root is desired, save it\r\n    if ConnectedChecker . __isDesiredCell__(img, hasVisited, iRoot, jRoot):\r\n    q . put((iRoot, jRoot))\r\n\r\n    ConnectedChecker . __markCellAsVisited__(hasVisited, iRoot, jRoot)\r\n\r\n    # Now we search for all connections along the allowed (four) directions\r\n    while q . empty() == False:\r\n    u, v = q . get()\r\n    iConnected . append(u)\r\n    jConnected . append(v)\r\n\r\n    # from the current position (u,v), search in the four cardinal directions\r\n    for s in range(numSearchDirs):\r\n    iNew = u + di[s]\r\n    jNew = v + dj[s]\r\n\r\n    # if we're in the image and found a desired cell, add it to the queue\r\n    if ConnectedChecker . __inImage__(iNew, jNew, nR, nC) and \\\r\n            ConnectedChecker . __isDesiredCell__(img, hasVisited, iNew, jNew):\r\n    ConnectedChecker . __markCellAsVisited__(hasVisited, iNew, jNew)\r\n    q . put((iNew, jNew))\r\n\r\n    # Should we get to this point, there does not exist a way to an exit of the maze\r\n    # from the starting location (path to exit: list(zip(xConnected, yConnected)))\r\n    return list(zip(iConnected, jConnected))\r\n    # ---end function\r\n    @ staticmethod\r\n    def countShapes(image):\r\n    img = image . split('\\n')\r\n    img = [row for row in img if row]\r\n    nC = len(img[0][:])\r\n    nR = len(img)\r\n\r\n    hasVisited = [[False for _ in range(nC)] for _ in range(nR)]\r\n    totalShapes = 0\r\n    for i in range(nR):\r\n    for j in range(nC):\r\n    if not hasVisited[i][j]:\r\n    startRow, startCol = i, j\r\n    shape = ConnectedChecker . __getConnectedShape__(\r\n        img, hasVisited, nR, nC, startRow, startCol)\r\n    if shape:\r\n    totalShapes += 1\r\n    return totalShapes\r\n    # ---end function\r\n    # end class\r\n    # driver for Kata\r\n    def connected_components(img):\r\n    c = ConnectedChecker()\r\n    return c . countShapes(img)\r\n    # end driver\r\n",
  "5c09ccc9b48e912946000157": "def peak_height(mountain):\r\n    M = {(r, c) for r, l in enumerate(mountain)\r\n         for c in range(len(l)) if l[c] == '^'}\r\n    h = 0\r\n    while M:\r\n    M -= {(r, c)\r\n          for r, c in M if {(r, c + 1), (r, c - 1), (r + 1, c), (r - 1, c)} - M}\r\n    h += 1\r\n    return h\r\n",
  "62cf27c0bf218d8f23bd1ca1": "def center(n): return ((n + 2) * n + 5) / 8 * (n % 4 == 1)\n",
  "58e6d83e19af2cb8840000b5": "from heapq import *\r\nfrom collections import defaultdict\r\nfrom itertools import product\r\nINF, STEP = float('inf'), (2 * 2 + 1) * * .5\r\nK_MOVES = tuple((a, b) for a, b in product(\r\n    range(- 2, 3), repeat=2) if abs(a) + abs(b) == 3)\r\n\r\n\r\ndef attack(start, end, obst):\r\n\r\n    def h(a, b, xF, yF):\r\n    a, b = a - xF, b - yF\r\n    return (a * a + b * b) * * .5 / STEP\r\n    soFar = INF\r\n    qS, qE = [(0, 0, start)], [(0, 0, end)]\r\n    sS, sE = defaultdict(lambda: INF), defaultdict(lambda: INF)\r\n    steps = ((qS, sS, sE, * end), (qE, sE, sS, * start))\r\n    for t in obst:\r\n        sS[t] = sE[t] = 0\r\n    sS[start] = sE[end] = 0\r\n    while qS and qE:\r\n    for q, s, sO, xF, yF in steps:\r\n\r\n    ch, c, pos = heappop(q)\r\n    x, y = pos\r\n    if ch > soFar:\r\n        return soFar\r\n    if pos in sO:\r\n    lenPath = s[pos] + sO[pos]\r\n    if lenPath > soFar:\r\n        return soFar\r\n    soFar = lenPath\r\n    else:\r\n    c += 1\r\n    for dx, dy in K_MOVES:\r\n    a, b = p = x + dx, y + dy\r\n    prev = s[p]\r\n    if c < prev:\r\n    heappush(q, (c + h(a, b, xF, yF), c, p))\r\n    s[p] = c\r\n    return soFar if soFar != INF else None\r\n",
  "62287e1766b26a0024b9e806": "from itertools import product\nfrom math import atan2, pi\nMOVES = [(2, 1), (1, 2), (- 1, 2), (- 2, 1),\n         (- 2, - 1), (- 1, - 2), (1, - 2), (2, - 1)]\nKNGIHT = 5 * * .5\nCLOCK = 2 * pi\n\n\ndef knight_path(* pnts):\n    (a, b), (i, j) = pnts\n    ang = atan2(j - b, i - a)\n    da, db = min(MOVES, key=smallestAngleWith(ang))\n\n    isSameSide = sameSideOfPredFactory(i - a, j - b, da, db)\n    movesOnSameSide = ((di, dj) for di, dj in MOVES if isSameSide(di, dj))\n\n    opp = ang + pi if ang < 0 else ang - pi\n    di, dj = min(movesOnSameSide, key=smallestAngleWith(opp))\n\n    x, y = crossingPoint(a, b, da, db, i, j, di, dj)\n    n1, n2 = getSteps(x, y, a, b), getSteps(x, y, i, j)\n\n    path1 = nStepsWithDirFrom(n1, da, db, a, b)\n    path2 = nStepsWithDirFrom(n2, di, dj, i, j)\n    link = pathsLinker(path1[- 2:], path2[- 2:])\n    path = behead(path1, link[0])\n    path . extend(link)\n    path . extend(reversed(behead(path2, link[- 1])))\n\n    return path\n    def smallestAngleWith(ang):\n    def mapper(dxy):\n    other = atan2(dxy[1], dxy[0])\n    v = (other - ang) % CLOCK\n    return min(abs(v), abs(CLOCK - v))\n    return mapper\n    def sameSideOfPredFactory(a, b, x, y):\n    ref = a * y - b * x\n    cmp = (ref > 0) - (ref < 0)\n    def predicate(i, j):\n    v = a * j - b * i\n    return cmp == (v > 0) - (v < 0)\n    return predicate\n    def crossingPoint(a, b, da, db, i, j, di, dj):\n    if (da, db) == (- di, - dj):\n    return i, j  # straight line => build one shot to the end...\n    v1 = b - a * db / da\n    v2 = j - i * dj / di\n    x = (v2 - v1) * da * di / (db * di - dj * da)\n    y = x * db / da + v1\n    return x, y\n    def getSteps(x, y, a, b):\n    return int(((a - x) * * 2 + (b - y) * * 2) * * .5 / KNGIHT)\n\n    def nStepsWithDirFrom(n, di, dj, i, j):\n    return [(i + di * z, j + dj * z) for z in range(n + 1)]\n\n    def behead(path, p):\n    while path[- 1] != p:\n        path . pop()\n    path . pop()\n    return path\n\n    def cachedLinks():\n        # all shortest paths from (0,0) to any position in a \"range(-8,9)\" around (x and y)\n    shortestTo = {(0, 0): [(0, 0)]}\n    bag = {(0, 0)}\n    while bag:\n    tmp = set()\n    for pos in bag:\n    for dx, dy in MOVES:\n    neigh = a, b = pos[0] + dx, pos[1] + dy\n    if - 9 < a < 9 and - 9 < b < 9 and neigh not in shortestTo:\n    shortestTo[neigh] = shortestTo[pos] + [neigh]\n    tmp . add(neigh)\n    bag = tmp\n    def getLinkFor(pair):\n    return shortestTo[tuple(x - a for a, x in zip(* pair))]\n\n    def pathHeadsLinker(head1, head2):\n    (a, b), _ = bestPair = min(product(head1, head2),\n                               key=lambda pair: len(getLinkFor(pair)))\n    return [(a + x, b + y) for x, y in getLinkFor(bestPair)]\n    return pathHeadsLinker\n    pathsLinker = cachedLinks()\n\n    \"\"\" \n Two to three times faster than the usual approaches. \n Here is why: \n When linking A to B, most soluitons try to stay as close as possible from the straight \n line between the two points. But once you got a shortest path, any permutation of its \n moves is also a shortest path. \n So, this shortest path (on the left) with shenanigans around B to get the shortest path, \n can be rearranged this way (on the right): \n A A \n \\ / \n / / \n / */ \n / */* \n \\ *\\ \n / \\ \n \\* \\ \n *B* B \n * \n \n So, here you go: \n 1) Identify the two optimal directions to use \n 2) Find the crossing point of the two lines and build straight paths up to that point \n 3) Take the last 2 points on each straight path and find what combination of 2 of them \n giving you the shortest path. \n Those \"links\" are computed once and cached, so that step is O(1) as well. \n 4) Assemble all the parts, \"beheading\" the redundant/useless points of the two straight lines \n Impact on performances: \n - 99% of the path is built with 2 list comprehensions (which are by assence faster than \n appending in a loop) \n - There is no decision to be done at each step (turning right or left), here. The only \n decisions to make are right at the start, to determine the 2 optimal directions to use. \n This aspect is critical about the performances because it makes the step by step approach \n O(N*x), with x a small constant factor (picking the right direction at each step), while \n the above approach is in comparison like O(N+x), because the optimal directions are picked \n once at the beginning. \n Both are linear in time, but the constant factor is lower here. \n \"\"\"\n",
  "62275b5bf6c169002379fa65": "def divide_and_multiply(n):\r\n    s, d = 1, []\r\n    for x in n:\r\n    b = x & - x\r\n    d . append(x / / b)\r\n    s *= b\r\n    return (sum(d) + max(d) * (s - 1)) % (10 * * 9 + 7)\r\n",
  "619d3f32156bbd000896463c": "# Prisoner 0 is the leader\n# He always leaves the lightbulb on\n# If he found the lightbulb off 100 times, it means everyone visited at least once\n# Other prisoners must turn off the lightbulb only if:\n# - they never turned it off before\n# - it is currently on\n# TLDR:\n# - turning the lightbulb on means \"I visited\"\n# - do not turn it on if you already did it\n# - prisoner 0 is in charge of resetting the lightbulb\ndef living_room(prisoner_number, lightbulb, previous_visits):\n    if prisoner_number == 0:\n    if len(previous_visits) - sum(previous_visits) == 100:\n    return True, True\n    return True, False\n    if lightbulb and not any(previous_visits):\n    return False, False\n    return lightbulb, False\n",
  "62cecd4e5487c10028996e04": "from math import ceil\n\n\ndef race_podium(b):\n    f = ceil((b) / 3) + 1\n    s = min(f - 1, b - f - 1)\n    return s, f, b - f - s\n",
  "62c75ce198d93d02a42ca7a3": "def most_points(m, n):\r\n    return [(0, 0)] if n == m == 1 else [(0, y) for y in range(m > 1, n)] + [(x, 0) for x in range(n > 1, m)]\r\n",
  "62b2072d62c66500159693ff": "from itertools import permutations\r\n# Missing digits\r\n\r\n\r\ndef get_unknown(puzzle):\r\n    return set(range(1, 10)) - set(puzzle)\r\n\r\n    # All possible tries to solve the puzzle\r\n    def get_possible(puzzle):\r\n    for perm in map(iter, permutations(get_unknown(puzzle))):\r\n    yield [x or next(perm) for x in puzzle]\r\n\r\n    # Check if a solution is valid\r\n    def check_possible(result):\r\n    return sum(result[: 4]) == sum(result[3: 7]) == sum(result[6:]) + result[0]\r\n\r\n    # Main function\r\n    def magic_triangle_solutions(puzzle):\r\n    return [* filter(check_possible, get_possible(puzzle))]\r\n",
  "62ca07aaedc75c88fb95ee2f": "def ascend_descend(l, m, M): return '' . join(\n    map(str, l * [* range(m, M + 1), * range(M - 1, m, - 1)]))[: l]\n",
  "62c93765cef6f10030dfa92b": "def solution(start, finish):\r\n    return sum(divmod(finish - start, 3))\r\n",
  "62cb487e43b37a5829ab5752": "FILTERS = set(FILTERS)\r\n\r\n\r\ndef is_valid(query: str) - > bool:\r\n    return all(u . split(':')[0] in FILTERS for u in query . split() if ':' in u)\r\n",
  "62c74a39fba7810016e601b1": "def sum_edges(n): return (n, n * (5 * n * n - 3 * n + 10) / 6 - 2)[n > 1]\n",
  "62cc917fedc75c95ef961ad1": "HEAVENLY_STEMS = '\u7532\u4e59\u4e19\u4e01\u620a\u5df1\u5e9a\u8f9b\u58ec\u7678'\r\nEARTHLY_BRANCHES = '\u5b50\u4e11\u5bc5\u536f\u8fb0\u5df3\u5348\u672a\u7533\u9149\u620c\u4ea5'\r\nYEAR = dict(\r\n    zip(map('' . join, zip(HEAVENLY_STEMS * 6, EARTHLY_BRANCHES * 5)), range(60)))\r\n\r\n\r\ndef how_old(birth_year, present_year):\r\n    a, b = YEAR[birth_year], YEAR[present_year]\r\n    return b - a + 60 * (a >= b)\r\n",
  "62c7b2ebb8d7c8005e3b1f23": "from math import factorial\r\nfrom functools import lru_cache\r\nf = lru_cache(maxsize=None)(factorial)\r\n\r\n\r\ndef pascal_pyr_layer(n):\r\n    return [[f(n - 1) / / f(n - 1 - i) / / f(i - j) / / f(j) for j in range(i + 1)] for i in range(n)]\r\n",
  "62c702489012c30017ded374": "import asyncio\n\n\nasync def request_manager(n: int) - > str:\n    return '' . join(await asyncio . gather(* (send_request() for _ in range(n))))\n",
  "62c4ad0e86f0166ec7bb8485": "def sum_corners(n): return n * n + 2 * (n > 1)\n",
  "62c376ce1019024820580309": "def get_cell_addresses(cell_range):\r\n    x, y = cell_range . split(':')\r\n    if x == y:\r\n        return []\r\n    a, b, c, d = ord(x[0]), abs(int(x[1:])), ord(y[0]), abs(\r\n        int(y[1:]))  # abs because the tests give some negative values\r\n    return [f\" { chr ( i )}{ j } \" for j in range(b, d + 1) for i in range(a, c + 1)]\r\n",
  "62b3356dacf409000f53cab7": "import re\r\nfrom itertools import *\r\n\r\n\r\ndef string_generator(pattern):\r\n    format = re . sub(\r\n        '\\[.*?\\]', '{}', pattern . replace('{', '{{'). replace('}', '}}'))\r\n    generators = [generator(x) for x in re . findall(\r\n        '\\[.*?\\]', pattern . replace(' ', ''))]\r\n    yield from starmap(format . format, zip(* generators)) if generators else repeat(pattern)\r\n\r\n    def generator(s):\r\n    match re . split('=|,', s[1: - 1]):\r\n    case[\"INC_INT\", * args]: yield from inc_int(* map(int, args))\r\n    case[\"INC_FLOAT\", * args]: yield from inc_float(precision(args), * map(float, args))\r\n    case[\"INTERVAL\", * args]: yield from interval(* map(int, args))\r\n    case[\"PERIODIC\", * args]: yield from periodic(* map(int, args))\r\n\r\n    def precision(args):\r\n    return max((len(x . split('.')[1]) for x in args), default=1)\r\n\r\n    def inc_int(start=1, step=1):\r\n    yield from count(start, step)\r\n\r\n    def inc_float(precision, start=0.1, step=0.1):\r\n    yield from map(f'{{ :. { precision } f}} ' . format, count(start, step))\r\n\r\n    def interval(first=1, last=None):\r\n    yield from cycle(range(first, (last or first) + 1))\r\n\r\n    def periodic(start=1, n=1):\r\n    yield from (start + x / / n for x in count())\r\n",
  "62bf879e8e54a4004b8c3a92": "def guess(colours, guesses, hats):\r\n    return colours[- sum(colours . index(c) for c in guesses + hats) % len(colours)]\r\n",
  "62b0c1d358e471005d28ca7e": "from itertools import cycle\r\n\r\n\r\ndef program(field, max_instructions):\r\n    dirs, fld = {'R': (0, 1), 'D': (1, 0)}, field . split('\\n')\r\n    ln = len(fld)\r\n    seen = {(0, 0)}\r\n    queue = [[(0, 0, '')]]\r\n\r\n    def is_path(path):\r\n    x, y = 0, 0\r\n    for p in cycle(path):\r\n    x, y = x + dirs[p][0], y + dirs[p][1]\r\n    if x >= ln or y >= ln:\r\n        return True\r\n    if fld[x][y] == 'H':\r\n        return False\r\n    for _ in range(max_instructions):\r\n    cur = []\r\n    for q in queue:\r\n    for k, (dx, dy) in dirs . items():\r\n    x, y = q[- 1][0] + dx, q[- 1][1] + dy\r\n    path = '' . join(x for _, _, x in q) + k\r\n    if x >= ln or y >= ln or is_path(path):\r\n    return path\r\n    if (x, y) not in seen and fld[x][y] != 'H':\r\n    cur . append(q + [(x, y, k)])\r\n    queue = cur[:]\r\n",
  "62bd9616aced6376cc37950e": "def pizza(n): return n * ~ - n * (n * n - 5 * n + 18) / / 24 + 1\n",
  "62bdd252d8ba0e0057da326c": "BASE = ord(\"a\") - 1\r\n\r\n\r\ndef encrypt(word, n):\r\n    xs = [x - BASE for x in map(ord, word)]\r\n    for _ in range(n):\r\n    xs[:] = (x * 3 - 5 for x in xs)\r\n    return xs\r\n    def decrypt(encrypted_word, n):\r\n    xs = encrypted_word[:]\r\n    for _ in range(n):\r\n    xs[:] = ((x + 5) / / 3 for x in xs)\r\n    return \"\" . join(chr(x + BASE) for x in xs)\r\n",
  "62b708450ee74b00589fcaba": "from datetime import datetime, timedelta\r\n# Encode the given velocity and interval information\r\n# (Velocity, start kms, stop kms)\r\nFAST = [\r\n    (34, 0, 200),\r\n    (32, 200, 400),\r\n    (30, 400, 600),\r\n    (28, 600, 1000),\r\n    (26, 1000, 1200),\r\n    (25, 1200, 1800),\r\n    (24, 1800, 2000),\r\n]\r\nSLOW = [\r\n    (20, 0, 60),\r\n    (15, 60, 600),\r\n    (11.428, 600, 1000),\r\n    (13.333, 1000, 1200),\r\n    (11, 1200, 1400),\r\n    (10, 1400, 1800),\r\n    (9, 1800, 2000),\r\n]\r\n\r\n\r\ndef duration_to_hms(duration):\r\n    \"\"\"Convert duration in decimal hours to hours, minutes, seconds to nearest second\"\"\"\r\n    hours = int(duration)\r\n    residue = duration - hours\r\n    mins = int(residue * 60)\r\n    residue -= mins / 60\r\n    secs = round(residue * 3600)\r\n    return hours, mins, secs\r\n    def calc_interval_and_durations(vel, start, stop):\r\n    \"\"\"Given velocity and start/stop distances calculate: \r\n 1. The interval. \r\n 2. The duration for full interval in decimal time. \r\n 3. The hours/minutes/seconds of the duration (to nearest second) \r\n \"\"\"\r\n    interval = stop - start\r\n    duration = interval / vel\r\n    hours, mins, secs = duration_to_hms(duration)\r\n    return interval, duration, hours, mins, secs\r\n    # Convert values to something a little more useful for calculation later\r\n    fast = [\r\n        calc_interval_and_durations(vel, start, stop)\r\n        for vel, start, stop in FAST\r\n    ]\r\n    slow = [\r\n        calc_interval_and_durations(vel, start, stop)\r\n        for vel, start, stop in SLOW\r\n    ]\r\n\r\n    def hh_mm_to_time(s):\r\n    \"\"\" \r\n Convert a string in the format HH:MM to hours and minutes after 2000-01-01 00:00:00.0 \r\n \"\"\"\r\n    hh, mm = s . split(':')\r\n    hh, mm = int(hh), int(mm)\r\n    return datetime(2000, 1, 1, hh, mm, 0)\r\n\r\n    def time_to_control(dt):\r\n    \"\"\" \r\n Convert a timestamp into the control format \r\n \"\"\"\r\n    if dt . second >= 30:\r\n       # Round up a minute\r\n    dt += timedelta(minutes=1)\r\n    hh_mm = f' { dt : % H : % M } '\r\n    if dt . day > 1:\r\n    return f' { hh_mm } (+ { dt . day - 1 } )'\r\n    return hh_mm\r\n    def calculate_control(stages, time, km):\r\n    \"\"\" \r\n Given the stages, the start time and the distance calculate the minimum timestamp for alloted arrival \r\n \"\"\"\r\n    timestamp = hh_mm_to_time(time)\r\n    for interval, duration, hours, mins, secs in stages:\r\n    if interval <= km:\r\n    timestamp += timedelta(hours=hours, minutes=mins, seconds=secs)\r\n    km -= interval\r\n    else:\r\n    hours, mins, secs = duration_to_hms(duration / interval * km)\r\n    timestamp += timedelta(hours=hours, minutes=mins, seconds=secs)\r\n    km = 0\r\n    if km == 0:\r\n    break\r\n    return timestamp\r\n    def control_open_time(time, km):\r\n    \"\"\" \r\n Given start time and distance find the open control time to nearest minute \r\n \"\"\"\r\n    timestamp = calculate_control(fast, time, km)\r\n    return time_to_control(timestamp)\r\n\r\n    def control_close_time(time, km):\r\n    \"\"\" \r\n Given start time and distance find the close control time to nearest minute \r\n \"\"\"\r\n    timestamp = calculate_control(slow, time, km)\r\n    # Allow for start time spread\r\n    timestamp += timedelta(hours=1)\r\n    return time_to_control(timestamp)\r\n",
  "62b931bcb16c630025076970": "# I mean, they work\r\ndef gcd_lcm(x, y):\r\n    if y % x == 0:\r\n    return x, y\r\n",
  "62b3e38df90eac002c7a983f": "import re\r\n\r\n\r\ndef solve(s):\r\n    stk = []\r\n    for m in re . finditer(r'\\[backspace\\](?:\\*(\\d*))?|.', s):\r\n    if m[0]. startswith('[backspace]'):\r\n    n = int(m[1] or 1)\r\n    while n and stk:\r\n        stk . pop()\r\n        n -= 1\r\n    else:\r\n    stk . append(m[0])\r\n    return '' . join(stk)\r\n",
  "62b1860db38ba1739bcaaebf": "def attack_plan(user_count, k):\r\n\r\n    dp = [[[- float(\"inf\")] * 4 for _ in range(k + 1)]\r\n          for _ in range(len(user_count) + 1)]  # [time][attacks][consecutive]\r\n    dp[0][0][0] = 0\r\n    for i, count in enumerate(user_count):\r\n    for r in range(k + 1):\r\n    dp[i + 1][r][0] = max(dp[i + 1][r][0], max(dp[i][r]))  # Stop attack\r\n    if r < k:\r\n    dp[i + 1][r + 1][1] = max(dp[i + 1][r + 1][1], dp[i][r][0])\r\n    dp[i + 1][r + 1][2] = max(dp[i + 1][r + 1][2], dp[i][r][1])\r\n    dp[i + 1][r + 1][3] = max(dp[i + 1][r + 1][3],\r\n                              dp[i][r][2] + count, dp[i][r][3] + count)\r\n\r\n    return max(dp[- 1][- 1])\r\n",
  "62ad72443809a4006998218a": "def like_or_dislike(lst):\r\n\t state = 'Nothing'\r\n for i in lst :\r\n\t\t state = 'Nothing' if i == state else i \r\n return state",
  "62a933d6d6deb7001093de16": "def get_the_vowels(word):\r\n    n = 0\r\n    for i in word:\r\n    if i == \"aeiou\" [n % 5]:\r\n    n += 1\r\n    return n\r\n",
  "62a3855fcaec090025ed2a9a": "from copy import deepcopy\r\n\r\n\r\ndef decode_smoke_signals(days):\r\n    days = deepcopy(days)\r\n    decoded = {}\r\n\r\n    # Keep eliminating signals until the puzzle has been solved\r\n    changed = True\r\n    while changed:\r\n        # Go through day by day and attempt to determine what each signal could be.\r\n    changed = False\r\n    signals = {}\r\n    for day in days:\r\n    for signal in day[0]:\r\n    if not signal in signals:\r\n        # Add all of today's events as possibilities for this signal\r\n    signals[signal] = set([a for a in day[1]])\r\n    else:\r\n        # Remove any previous possibilities that aren't in today's events\r\n    signals[signal] = signals[signal]. intersection(set(day[1]))\r\n\r\n    # Add any signals that were solved to the decoded list and remove them\r\n    # from the days list (and up to 1 instance of each corresponding event)\r\n    for signal, possible in signals . items():\r\n    if len(possible) == 1:\r\n    changed = True\r\n    event = list(possible)[0]\r\n    decoded[signal] = event\r\n    for day in days:\r\n    if signal in day[0]:\r\n    day[0]. remove(signal)\r\n    day[1]. remove(event)\r\n\r\n    return decoded\r\n",
  "62a611067274990047f431a8": "def alternate(n, first_value, second_value):\r\n    return [[first_value, second_value][i % 2] for i in range(n)]\r\n",
  "62a25309b070a3002f53b684": "import numpy as np\n\n\ndef surface_area(m):\n    return 2 * np . count_nonzero(m) + sum(abs(np . diff(m, 1, i, 0, 0)). sum() for i in range(2))\n",
  "62a0a24ed518853c3528683f": "from fractions import Fraction\r\nfrom functools import lru_cache\r\nfrom math import comb, factorial\r\nB = [Fraction(1, 1)]\r\nfor i in range(1, 141):\r\n    B . append(\r\n        1 - sum(comb(i, j) * Fraction(B[j], i - j + 1) for j in range(i)))\r\n\r\n    def build(\r\n        i, x, y): return f\" { abs ( x )}{ f'/ { y } ' * ( y > 1 )} n { f'^ { i } ' * ( i > 1 )} \"\r\n    fact = lru_cache(maxsize=None)(factorial)\r\n\r\n    def equation(k):\r\n    coeff = [build(k + 1, 1, k + 1), '+', build(k, 1, 2)]\r\n    for i in range(2, k + 1):\r\n    if (x := (B[i] * fact(k)) / (fact(i) * fact(k - i + 1))):\r\n    coeff . append(\"-+\" [x > 0])\r\n    coeff . append(build(k - i + 1, * x . as_integer_ratio()))\r\n    return ' ' . join(coeff)\r\n",
  "629e18298f2d21006516e381": "def permuts(n):\r\n    x = [1, 2]\r\n    for i in range(n):\r\n    x . append(x[- 1] + x[- 2])\r\n    return x[n - 1]\r\n",
  "620dd259f7b0000017fc7b45": "from math import gcd\n\n\ndef coins(coin1, coin2):\n    return - 1 if gcd(coin1, coin2) != 1 else (coin1 - 1) * (coin2 - 1) - 1\n",
  "629e4d5f24b98110a83b2d0d": "from functools import partial\r\nfrom re import compile\r\nr1 = partial(compile(r\"(?=[a-z])([^aeiou])\"). sub, r\"\\1o\\1\")\r\nr2 = partial(compile(r\"(?=[A-Z])([^AEIOU])\"). sub, r\"\\1O\\1\")\r\n\r\n\r\ndef robber_encode(sentence):\r\n    return r1(r2(sentence))\r\n",
  "626a887e8a33feabd6ad8f25": "class predicate:\r\n\r\n    def __init__(self, func): self . f = func\r\n    def __call__(self, * a, * * kw): return self . f(* a, * * kw)\r\n\r\n    def __invert__(self): return self . __class__(lambda * a, * * kw: not self . f(* a, * * kw))\r\n    def __or__(self, o): return self . __class__(lambda * a, * * kw: self . f(* a, * * kw) or o . f(* a, * * kw))\r\n    def __and__(self, o): return self . __class__(lambda * a, * * kw: self . f(* a, * * kw) and o . f(* a, * * kw))\r\n",
  "6297d639de3969003e13e149": "from itertools import permutations\r\n\r\n\r\ndef best_route(cities, costs):\r\n    nothome = [x for x in cities if x != 'Notgnihsaw']\r\n    tbl = {city1: {city2: cost for city2, cost in zip(\r\n        cities, row)} for city1, row in zip(cities, costs)}\r\n    return min(([* p, 'Notgnihsaw'] for p in permutations(nothome)), key=lambda tour: sum(tbl[a][b] for a, b in zip(['Notgnihsaw'] + tour, tour)))\r\n",
  "6294a4d0eb816e36363b9079": "from ipaddress import IPv4Address as ip\n\n\ndef match(net_addr: str, wc_mask: str, ipv4_addr: str) - > bool:\n    return int(ip(net_addr)) | int(ip(wc_mask)) == int(ip(ipv4_addr)) | int(ip(wc_mask))\n",
  "628f8211840e153e14346eaa": "from ipaddress import IPv4Network\n\n\ndef network_cidr(ipv4_addr, net_mask):\n    return str(IPv4Network(f' { ipv4_addr } / { net_mask } ', strict=False))\n",
  "62949a3deb816e36363b8ee6": "def is_wristband(arr):\r\n    note = {1, 2, 3, 4}\r\n    for i, j in zip(arr, arr[1:]):\r\n    if 1 in note and (len(set(i)) != 1 or len(set(j)) != 1):\r\n    note . remove(1)\r\n    if 2 in note and i != j:\r\n    note . remove(2)\r\n    if 3 in note and i[: - 1] != j[1:]:\r\n    note . remove(3)\r\n    if 4 in note and j[: - 1] != i[1:]:\r\n    note . remove(4)\r\n    if not note:\r\n    return False\r\n    return True\r\n",
  "628e3ee2e1daf90030239e8a": "def interlockable(a, b):\r\n    return not a & b\r\n",
  "628e6f112324192c65cd8c97": "def prescribe(d, a, b):\r\n    return max(x + (d - x) / / a * a for x in range(0, d + 1, b))\r\n",
  "629049687438580064f0e6dd": "import itertools\n\n\ndef pack(m): return tuple(tuple(sum(g)\n                                for k, g in itertools . groupby(r) if k) for r in m)\n\n\ndef encode(nonogram): return (pack(zip(* nonogram)), pack(nonogram))\n",
  "628df6b29070907ecb3c2d83": "def solution(s, t):\n\n    # Sprints are optimally placed at the end of the race\n    ''' \n    It is always beneficial to sprint at the end of the race \n    Sprints are optimally placed at the end of the race \n    e.g. RRRR...(SR)[n]S \n    We take a run without sprints are keep adding sprints at \n    the latest possible point until adding a sprint stops \n    increasing the total distance travelled \n\n    We can treat the final sprint as an add-on and count the number of \n    (SR) units we introduce into the race. Looking at this, each add \n    on unit changes the distance from 2*s to (3*s-3*n), so altering \n    the distance by (s-3*n). We find the largest n<s for which (s-3*n)>0 \n    to find the trade-off point. If this is longer than the race in general \n    we do as many (SR) as possible. \n\n\n    '''\n    trade_off = s / / 3\n    # trade off must be less than max available slots\n    best_n_rs = min((t - 1) / / 2, trade_off)\n    def d(n): return s * t + s * (n + 1) - 3 / 2 * n * (n + 1)\n    return d(best_n_rs)\n",
  "628d253eb110f3270a8a1789": "def determinateValue(x, y, n): return 1 + [y, x][(q := x + y) % 2] + q * (q + 1) / / 2 - max(q - n + 1, 0) * * 2\n",
  "628d1c71b091df00651f0d83": "# Return a list of 2-tuples of integers, representing\n# the integer coordinates of ALL possible squares that\n# satisfy the minimum number of total moves requirement\nfrom statistics import median_low, median_high\n\n\ndef move_grains(grains):\n    xcoords = [x for x, _ in grains]\n    ycoords = [y for _, y in grains]\n    return [(x, y) for x in range(median_low(xcoords), median_high(xcoords) + 1) for y in range(median_low(ycoords), median_high(ycoords) + 1)]\n",
  "628bd39474087000456cd126": "# The final state is the binary representation of\n# the input, n, in reverse i.e. reading from left\n# to right gives lsb to msb.\n# So number of bubbles in final state in box i\n# is equal to b_i from binary repr of n.\n# To obtain 1 bubble in box i requires:\n# S(i) = 2*S(i-1) + 1 steps with S(0)=0\n# Solving the recurrence gives:\n# S(i) = 2**i - 1\n# Hence number of steps in total to place all bubbles\n# is sigma{ b_i * S(i) } over all binary digits of n\n# = sigma{ b_i * 2**i } - sigma{ b_i }\n# = n - sigma{bits in n}\ndef moving_bubbles(n):\n    return n - n . bit_count()\n",
  "628b60fcb7d0770ddea8877d": "def get_status(wins):\n    A = B = 0\n    for n in wins:\n    if n == \"Anna\":\n        A += 1\n    else:\n        B += 1\n    if (A > 3 or B > 3) and abs(A - B) > 1:\n    return f\" { n } WINS\"\n    return (\"Anna ADVANTAGE\" if B + 1 == A > 3 else\n            \"Bob ADVANTAGE\" if A + 1 == B > 3 else\n            [\"0a\", \"15a\", \"30a\", \"DEUCE\"][min(A, 3)] if A == B else\n            f\"Bob {[ 0 , 15 , 30 , 40 ][ B ]} , Anna {[ 0 , 15 , 30 , 40 ][ A ]} \")\n",
  "628b633fb7d0770d57a88809": "from copy import deepcopy\r\nRADIATION_SOURCES = {\r\n    # You can easily modify:\r\n    # symbol: ((x, y, val), ...), # affected cells and impact value\r\n    'A': (\r\n         (- 1, - 1, 1), (0, - 1, 1), (1, - 1, 1),\r\n         (- 1, 0, 1), (1, 0, 1),\r\n         (- 1, 1, 1), (0, 1, 1), (1, 1, 1),\r\n    ),\r\n    'B': (\r\n         (0, - 2, 2),\r\n        (0, - 1, 2),\r\n        (- 2, 0, 2), (- 1, 0, 2), (1, 0, 2), (2, 0, 2),\r\n        (0, 1, 2),\r\n        (0, 2, 2),\r\n    ),\r\n    'C': (\r\n         (- 2, - 2, 3), (2, - 2, 3),\r\n        (- 1, - 1, 3), (1, - 1, 3),\r\n\r\n        (- 1, 1, 3), (1, 1, 3),\r\n        (- 2, 2, 3), (2, 2, 3),\r\n    ),\r\n}\r\n\r\n\r\ndef calculate_cells(field):\r\n    cp_field = deepcopy(field)\r\n    width = (height := len(cp_field)) and len(cp_field[0])\r\n    for y in range(height):\r\n    for x in range(width):\r\n    for a, b, val in RADIATION_SOURCES . get(cell := cp_field[y][x], []):\r\n    if 0 <= (ny := y + b) < height and 0 <= (nx := x + a) < width:\r\n    if (nv := cp_field[ny][nx]) not in RADIATION_SOURCES:\r\n    cp_field[ny][nx] = str(int(nv) + val)\r\n    return cp_field\r\n",
  "628ba76a85a2d500649da696": "def ipv4_address_class(ipv4_addr):\r\n    n = int(ipv4_addr . split(\".\")[0])\r\n    return \" EDCBA\" [(n <= 127) + (n <= 191) + (n <= 223) + (n <= 239) + (n <= 255)]\r\n",
  "6288de23ab7ede0031602521": "def ipv4_to_binary(ipv4_addr: str) - > str:\r\n    return \".\" . join(f\" { octet :0 8 b } \" for octet in map(int, ipv4_addr . split(\".\")))\r\n",
  "626ec08b40a15e2d250575cf": "from math import comb\n\n\ndef use_all_symbols(n, a):\n    return sum((- 1) * * i * comb(a, i) * (a - i) * * n for i in range(a + 1))\n",
  "60245d013b9cda0008f4da8e": "N = \"Alab,Alas,Am,Ari,Ark,Ca,Col,Con,De,Di,F,Ge,Gu,H,Id,Il,In,Io,Ka,Ke,L,Mai,Mar,Mas,Mic,Min,Missi,Misso,Mo,Neb,Nev,New H,New J,New M,New Y,North C,North D,Northe,Oh,Ok,Or,Pe,Pu,R,South C,South D,Ten,Tex,U.,Ut,Ve,Vi,Wa,We,Wi,Wy\" . split(\r\n    \",\")\r\nC = \"AL AK AS AZ AR CA CO CT DE DC FL GA GU HI ID IL IN IA KS KY LA ME MD MA MI MN MS MO MT NE NV NH NJ NM NY NC ND MP OH OK OR PA PR RI SC SD TN TX VI UT VT VA WA WV WI WY\" . split()\r\n\r\n\r\ndef abbr(s):\r\n    return next(c for n, c in zip(N, C) if s . startswith(n))\r\n",
  "627183ce5aa8580057592940": "def optimal_conversations(n):\r\n    if n == 2:\r\n        return [(1, 2)]\r\n    if n == 3:\r\n        return [(1, 2), (1, 3), (2, 3)]\r\n\r\n    # Optimal solution for 4 people\r\n    res = [(1, 2), (3, 4), (1, 3), (2, 4)]\r\n\r\n    # If more than 4 people, just get their information at first and give them the (1, 2, 3, 4) at the end\r\n    above_4 = [(1, i) for i in range(5, n + 1)]\r\n\r\n    return above_4 + res + above_4\r\n",
  "5597ca93d5b5b37db8000066": "from functools import cache\r\nfrom gmpy2 import is_prime, next_prime\r\n\r\n\r\n@ cache\r\ndef \u03c3(m, n):\r\n    s, p = 1, 2\r\n    while n > 1:\r\n    while n % p:\r\n    p = n if is_prime(n) else next_prime(p)\r\n    i = 1\r\n    while n % p == 0:\r\n    n / /= p\r\n    i += 1\r\n    s *= (p * * i - 1) / / (p - 1)\r\n    return s if m == 1 else \u03c3(m - 1, s)\r\n\r\n    def first_mk_perfectnumber(m, k):\r\n    i = 1\r\n    while \u03c3(m, i) != k * i:\r\n    i += 1\r\n    return i\r\n",
  "626d691649cb3c7acd63457b": "import re\r\n\r\n\r\ndef champion_rank(pilot: int, events: str) - > int:\r\n    arr = [i for i in range(1, 21)]\r\n    for x in re . findall(\"\\d+ [IO]\", events):\r\n    r, t = x . split()\r\n    if t == 'I':\r\n    arr . remove(int(r))\r\n    else:\r\n    j = arr . index(int(r))\r\n    arr[j], arr[j - 1] = arr[j - 1], arr[j]\r\n    return arr . index(pilot) + 1 if pilot in arr else - 1\r\n",
  "626d96eb49cb3c7a2f634bbf": "def white_black_frogs(n):\r\n    return '' . join('j' * i + 'wb' [i & 1] for i in range(n)) + '' . join('j' * (n - i) + 'bw' [(i + n) & 1] for i in range(n))\r\n",
  "626b949b40a15ed6e7055b8f": "def is_reachable(s, e):\r\n    ss, es = ['' . join(b[y][x] for y, x in [(0, 0), (1, 2), (2, 0), (0, 1),\r\n                        (2, 2), (1, 0), (0, 2), (2, 1)] if b[y][x] != '_') for b in (s, e)]\r\n    return s[1][1] == e[1][1] and ss in es * (1 + (len(es) < 8))\r\n",
  "62013b174c72240016600e60": "def resolver(guess, solution):\r\n    letters, answer = {}, ['b'] * len(guess)\r\n    for i, (g, s) in enumerate(zip(guess, solution)):\r\n    if g == s:\r\n        answer[i] = 'g'\r\n    else:\r\n        letters[s] = letters . get(s, 0) + 1\r\n    for i, (g, s) in enumerate(zip(guess, solution)):\r\n    if g != s and letters . get(g, 0) > 0:\r\n    answer[i] = 'y'\r\n    letters[g] -= 1\r\n    return '' . join(answer)\r\n",
  "626868a414c0146ddbe0e6be": "def limited_king(n):\r\n    res = n % 3 == 1 and [(0, j) for j in range(n)] or []\r\n\r\n    for x in range(bool(res), n, 3):\r\n    res . extend((k, l) for l in range(n - 1, - 1, - 1)\r\n                 for k in range(x, x + 2))\r\n    if x + 2 != n:\r\n    res . extend((x + 2, j) for j in range(n))\r\n\r\n    return res\r\n",
  "6267a007e67fba0058725ad2": "def partitions(n):\r\n    T = [1] + [0] * n\r\n    for i in range(1, n + 1):\r\n    for j in range(n, i - 1, - 1):\r\n    T[j] += T[j - i]\r\n    return T[- 1]\r\n",
  "62665d43e67fbaf7b37212d2": "def bell(n):\r\n    return [(i + 1) * (n - i) for i in range(n)]\r\n",
  "62652939385ccf0030cb537a": "def promotion(board):\r\n    pieces = [(i, j) for i, r in enumerate(board)\r\n              for j, p in enumerate(r) if p != ' ']\r\n    if not len(pieces) == 2:\r\n        return []\r\n    a, b = pieces\r\n    if a[0] == b[0] or a[1] == b[1]:\r\n    return ['queen', 'rook']\r\n    if {abs(a[0] - b[0]), abs(a[1] - b[1])} == {1, 2}:\r\n    return ['knight']\r\n    if abs(a[0] - b[0]) == abs(a[1] - b[1]):\r\n    return ['queen', 'bishop']\r\n    return []\r\n",
  "6262f9f7afc4729d8f5bef48": "def white_black_areas(cs, rs):\r\n    r_even, r_odd = sum(rs[1:: 2]), sum(rs[:: 2])\r\n    c_even, c_odd = sum(cs[1:: 2]), sum(cs[:: 2])\r\n    return (c_odd * r_odd + c_even * r_even, r_even * c_odd + r_odd * c_even)\r\n",
  "625d02d7a071210017c8f0c3": "def line_up(hints):\r\n    graph = dict((a, b) if side == 'right' else (b, a)\r\n                 for a, _, b, _, _, side in map(str . split, hints))\r\n    start = (set(graph) - set(graph . values())). pop()\r\n    queue = []\r\n    while start:\r\n    queue . append(start)\r\n    start = graph . get(start)\r\n    return queue\r\n",
  "615dd90346a119004af6d916": "from itertools import count\nfrom math import sin\n\n\ndef taylors_sine_terms(x: float, epsilon: float) - > int:\n    sin_x = sin(x)\n    approx = 0\n    fact = 1\n    for i in count(1):\n    approx -= (- 1) * * i * x * * (2 * i - 1) / fact\n    if abs(sin_x - approx) < epsilon:\n        return i\n    fact *= 2 * i * (2 * i + 1)\n",
  "625ea5c1a071210065c923af": "def plastic_balance(L):\r\n    if L and L[0] + L[- 1] != sum(L[1: - 1]):\r\n        return plastic_balance(L[1: - 1])\r\n    return L\r\n",
  "625d1c5b2f6c2c00300d97b7": "def xorr(n):\r\n    return (n, 1, n + 1, 0)[n % 4]\r\n\r\n    def xor_reduction(m, n):\r\n    return xorr(m - 1) ^ xorr(n)\r\n",
  "6255e6f2c53cc9001e5ef629": "from collections import Counter\r\n\r\n\r\ndef wordle(wordlist, guesses):\r\n    for g, r in guesses:\r\n    z = Counter(d for d, p in zip(g, r) if p != '-')\r\n    wordlist = [w for w in wordlist if all((p == 'G') == (c == d) and not (p == '-' and w . count(\r\n        d) > z[d]) for c, d, p in zip(w, g, r)) and all(w . count(c) >= v for c, v in z . items())]\r\n    return wordlist\r\n",
  "624f3171c0da4c000f4b801d": "def barista(coffees, n):\r\n    coffees = sorted([v for v in coffees if v])\r\n    times = coffees[: n]\r\n    for v in coffees[n:]:\r\n    times . append(times[- n] + 2 + v)\r\n    return sum(times)\r\n",
  "62524390983b35002c8ff1e5": "def mul37(num):\n    k = (2 * num + 6) / / 7\n    a, b = 7 * k - 2 * num, num - 3 * k\n    return f'3 * { a } + 7 * { b } '\n",
  "624fc787983b3500648faf11": "def conceal(msg, pixels):\r\n    bits = '' . join(f' { ord ( c ) : 0 > 8 b } .' for c in msg)\r\n    if len(bits) <= len(pixels) * 3:\r\n    bits = iter(bits)\r\n    return [[mix(v, next(bits, \".\")) for v in p] for p in pixels]\r\n\r\n    def mix(v, b):\r\n    return v if b == \".\" else v >> 1 << 1 | int(b)\r\n",
  "624dfbc87ee0d200157ad483": "def interweave(a, b):\n    b = sorted(list(b))\n    i, j, s = 0, len(b) - 1, []\n    for c in a:\n    match c:\n    case '<':\n    s . append(b[i])\n    i += 1\n    case other:\n    s . append(b[j])\n    j -= 1\n    s . append(b[i])\n    return s\n    # from itertools import permutations, zip_longest\n    #\n    # def interweave(ineqs, ints):\n    # for xs in permutations(ints):\n    # #print(s)\n    # s = ''.join([str(a) if o is None else f\"{a}{o}\" for a,o in zip_longest(xs,ineqs)])\n    # r = eval(s)\n    # if r:\n    # return s\n",
  "624e0a4c3e1d7b0031588666": "def recurrence(values):\n    # let's take the first item as nadir, the previous item is temporarily equal to nadir\n    prev = nadir = values[0]\n    counter = 0  # a counter of ever higher successive values\n    bio = False  # 3 consecutive rising PSA values after reaching the nadir value, now it's False\n    for val in values[1:]:  # get next value from the list\n    if val < nadir:  # new nadir?\n    nadir = val  # if yes we start counting again, so:\n    bio = False  # - reset the bio\n    counter = 0  # - reset the counter\n    elif val > prev:  # if we detected an increase:\n    counter += 1  # - mark it\n    else:  # if we detected not an increase:\n    counter = 0  # - reset the counter to count again\n    prev = val  # remember previous item\n    if counter > 2:  # if we have 3 consecutive rising PSA values:\n    bio = True  # - we found 'biochemical recurrence'\n    return bio\n",
  "62443a1ea8fca9002346d72c": "def winner(choices, p1, p2):\r\n    if p1 == p2:\r\n    return \"Draw!\"\r\n    r = (choices . index(p2) - choices . index(p1)) % len(choices)\r\n    if r == len(choices) / 2:\r\n    return \"Draw!\"\r\n    if r < len(choices) / 2:\r\n    return \"Player 2 won!\"\r\n    return \"Player 1 won!\"\r\n",
  "6243819a58ad06b6c663d32b": "def next_pos(s): return [f + r for f in 'abcdefgh' for r in '12345678' if ~ int(f + r + s, 24) * * 4 % 577 ^ 4 < 4]\n",
  "6202149e89771200306428f0": "def is_possible(db: dict) - > bool:\r\n    db = dict(db)\r\n    stk = list(db)\r\n    day = [0] * len(db)\r\n\r\n    while stk:\r\n    a = stk . pop()\r\n    if a not in db:\r\n        continue\r\n    lst = db . pop(a)\r\n    day[a] = day[a] or 1\r\n    oppDay = day[a] ^ 3\r\n    for b in lst:\r\n    if day[b] and day[b] != oppDay:\r\n        return False\r\n    day[b] = oppDay\r\n    stk . extend(lst)\r\n    return True\r\n",
  "62396d476f40250024bcfce9": "# return the minimum number of stops, otherwise -1\ndef get_stops(up, down, n_floors, floor):\n    visited = {1}\n    queue = [(1, 0)]\n    while queue:\n        fl, stops = queue.pop(0)\n        if fl == floor: return stops\n        for f in [fl+up, fl-down]:\n            if 1 <= f <= n_floors and not f in visited:\n                visited.add(f)\n                queue.append((f, stops+1))\n    return -1"
}